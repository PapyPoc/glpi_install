#!/usr/bin/env bash
#
# GLPI install script
# Author: PapyPoc
# Version: 1.8.0
# Script d'installation GLPI
# Langage pris en compte français et anglais
#
set -Eeuo pipefail
clear # Nettoyer le terminal
# Définition des variables Globales
ROUGE='\033[0;31m' # Red
CYAN='\033[0;36m' # Cyan
NC='\033[0m' # No Color
REP_SCRIPT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" # Répertoire du script
ORIG_USER="${SUDO_USER:-$(logname 2>/dev/null || echo "${USER:-unknown}")}"
ERRORFILE="${REP_SCRIPT}/install_error.log"
DEPENDENCIES="curl jq openssl sudo dialog git shadow"
GIT="https://github.com/PapyPoc/glpi_install.git" # URL du dépôt git
export ROUGE CYAN NC ORIG_USER ERRORFILE REP_SCRIPT GIT
# Fonctions d'affichage
warn() {
    echo -e "${ROUGE}$1${NC}"
}
info() {
    echo -e "${CYAN}$1${NC}"
}
# Vérifie et installe les dépendances manquantes
ensure_dependencies() {
    # Indique si une ré-exécution du script est nécessaire après installation
    NEED_RESTART=0
    local missing=()
    # Accepte soit une chaîne d'éléments séparés par des espaces, soit rien pour utiliser ${DEPENDENCIES}
    local -a check_cmds
    if [ $# -ge 1 ] && [ -n "$1" ]; then
        # split the provided string into an array
        read -r -a check_cmds <<< "$1"
    else
        read -r -a check_cmds <<< "$DEPENDENCIES"
    fi
    for cmd in "${check_cmds[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing+=("$cmd")
        fi
    done
    if [ ${#missing[@]} -eq 0 ]; then
        return 0
    fi
    echo "Dépendances manquantes : ${missing[*]}. Tentative d'installation..."
    local pkgmgr install_cmd
    local pkgs="${missing[*]}"
    if command -v apt-get >/dev/null 2>&1; then
        pkgmgr="apt-get"
        install_cmd="apt-get update -qq && apt-get install -y -qq ${pkgs}"
    elif command -v dnf >/dev/null 2>&1; then
        pkgmgr="dnf"
        install_cmd="dnf install -y -q ${pkgs}"
    elif command -v yum >/dev/null 2>&1; then
        pkgmgr="yum"
        install_cmd="yum install -y -q ${pkgs}"
    elif command -v apk >/dev/null 2>&1; then
        pkgmgr="apk"
        install_cmd="apk add --no-cache ${pkgs}"
    elif command -v pacman >/dev/null 2>&1; then
        pkgmgr="pacman"
        install_cmd="pacman -Syu --noconfirm ${pkgs}"
    elif command -v zypper >/dev/null 2>&1; then
        pkgmgr="zypper"
        install_cmd="zypper install -y ${pkgs}"
    else
        warn "Aucun gestionnaire de paquets pris en charge trouvé pour installer : ${pkgs}"
        return 1
    fi
    info "Installation via ${pkgmgr} : ${pkgs}"

    if ! bash -c "$install_cmd"; then
        warn "Échec de l'installation des dépendances : ${pkgs}"
        return 1
    fi
    local still_missing=()
    for cmd in "${check_cmds[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            still_missing+=("$cmd")
        fi
    done
    if [ ${#still_missing[@]} -gt 0 ]; then
        warn "Commandes toujours manquantes après l'installation : ${still_missing[*]}"
        sleep 5
        return 1
    fi
    NEED_RESTART=1
    export NEED_RESTART
    return 0
}
get_git_branch() {
    local repo="$1"
    local branch="unknown"
    if git -C "$repo" rev-parse --git-dir >/dev/null 2>&1; then
        branch=$(git -C "$repo" symbolic-ref --short HEAD 2>/dev/null || true)
        if [ -z "$branch" ] || [ "$branch" = "HEAD" ]; then
            branch=$(git -C "$repo" describe --tags --exact-match 2>/dev/null || true)
            if [ -z "$branch" ]; then
                branch=$(git -C "$repo" rev-parse --abbrev-ref HEAD 2>/dev/null || true)
            fi
        fi
    fi
    # Nettoyage : n'autorise que des caractères sûrs
    branch="${branch//[^A-Za-z0-9._\\/-]/_}"
    printf '%s' "${branch:-unknown}"
}

BRANCHE="$(get_git_branch "$REP_SCRIPT")"
export BRANCHE
echo "Branche git détectée : ${BRANCHE}"
# Détection de la distribution
if source /etc/os-release 2>/dev/null; then
    DISTRO_ID=$(echo "$ID" | tr '[:upper:]' '[:lower:]')
    info "Distribution détectée : ${DISTRO_ID^} $(echo "${VERSION_ID}" | xargs)"
else
    warn "Distribution non détectée ou non prise en charge."
    exit 1
fi
# Détermination du groupe administrateur
case "$DISTRO_ID" in
    debian|ubuntu)
        ADMIN_GROUP="sudo"
        ;;
    centos|rhel|rocky|almalinux|fedora)
        ADMIN_GROUP="wheel"
        ;;
    *)
        ADMIN_GROUP="sudo"
        info "Distribution non reconnue. Utilisation de '${ADMIN_GROUP}' par défaut."
        ;;
esac
# Vérification des droits root
if [ "$EUID" -ne 0 ]; then
    if id -nG "$ORIG_USER" 2>/dev/null | grep -Eqw "sudo|wheel"; then
        info "Relance du script avec les droits administrateur..."
        sleep 2
        info "Utilisation de l'utilisateur ${ORIG_USER} avec les droits ${ADMIN_GROUP}."
        if command -v "$ADMIN_GROUP" >/dev/null 2>&1; then
            exec "$ADMIN_GROUP" -E "$0" "$@"
        else
            warn "Aucune commande disponible pour élever les privilèges (sudo/su)."
            exit 1
        fi
    else
        warn "L'utilisateur ${ORIG_USER} n'a pas les droits administrateur (${ADMIN_GROUP})."
        if command -v usermod >/dev/null 2>&1; then
            usermod -aG "$ADMIN_GROUP" "$ORIG_USER" || true
        elif command -v adduser >/dev/null 2>&1; then
            # Cas Alpine ou BusyBox
            adduser "$ORIG_USER" "$ADMIN_GROUP" || true
        else
            warn "Impossible d'ajouter $ORIG_USER au groupe $ADMIN_GROUP : aucune commande compatible trouvée."
            sleep 5
            exit 1
        fi
        warn "Ajout de ${ORIG_USER} au groupe ${ADMIN_GROUP}. Veuillez vous reconnectter et relancer le script."
        sleep 5
        exit 1
    fi
fi
# Vérification et installation des dépendances
if ensure_dependencies "curl jq openssl sudo dialog shellcheck"; then # Ajout de shellcheck
    info "Toutes les dépendances sont satisfaites."
    sleep 5
else
    warn "Échec de la vérification ou installation des dépendances."
    sleep 5
    exit 1
fi
if [ "${NEED_RESTART:-0}" -eq 1 ]; then
    info "Dépendances installées. Redémarrage du script..."
    sleep 5
    exec "$0" "$@"
fi
# Gestion du dépôt glpi_install
if [ -d "${REP_SCRIPT}/glpi_install/.git" ]; then
    cd "${REP_SCRIPT}/glpi_install" && git pull origin "${BRANCHE}"&& cd ..
else
    git clone "${GIT}" -b "${BRANCHE}" "${REP_SCRIPT}/glpi_install"
fi
chmod +x "${REP_SCRIPT}/glpi_install/glpi-install"
# Lancer le script principal en remplaçant le processus courant
if [ -x "${REP_SCRIPT}/glpi_install/glpi-install" ]; then
    exec "${REP_SCRIPT}/glpi_install/glpi-install" "$@"
else
    warn "Le script '${REP_SCRIPT}/glpi_install/glpi-install' n'est pas exécutable ou introuvable."
    exit 1
fi