#!/usr/bin/env bash
#
# GLPI install script
# Author: PapyPoc
# Version: 1.8.0
# Function file
#
set -Eeuo pipefail
# Ne pas continuer si le script est ex√©cut√© directement
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo -e "Ce fichier doit √™tre sourc√©, pas ex√©cut√©.\n">> "${ERRORFILE}"
    return 1
fi
# Affichage d'alerte
function warn(){
    local msg="$1"
    export_display_env
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    echo -e "${ROUGE}${expanded}${NC}" # Couleur rouge
}
# Affichage d'information
function info(){
    local msg="$1"
    export_display_env
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    echo -e "${CYAN}${expanded}${NC}" # Couleur cyan
}
# Exporter une liste blanche de variables utilis√©es dans les fichiers de langue pour que envsubst puisse les remplacer
export_display_env() {
    # Exporter un ensemble complet de variables (majuscules et minuscules)
    # pouvant √™tre r√©f√©renc√©es comme espaces r√©serv√©s dans les fichiers de langue.
    # Les valeurs par d√©faut sont vides si elles ne sont pas d√©finies.
    local vars_maj=(
        ORIG_USER ADMIN_GROUP ID VERSION_ID ID NAME PRETTY_NAME MSG_NONOK NEW_VERSION REP_GLPI FICHIER_MSG
        ERRORFILE LOGFILE TASK_INDEX TASK_KEY LANGUAGE TIMEZONE IPADRESS INTERFACE DOWNLOADLINK
        DB_USER DB_NAME SQLROOTPWD SQLGLPIPWD ADMINGLPIPWD POSTGLPIPWD TECHGLPIPWD NORMGLPIPWD
        REP_BACKUP BDD_BACKUP REP_SCRIPT MYSQL_CMD MYSQLDUMP_CMD OUTPUT GLPI_CLI_VERSION PHPVERSION
        DEBIAN_VERSIONS UBUNTU_VERSIONS ALMA_VERSIONS CENTOS_VERSIONS ROCKY_VERSIONS REDHAT_VERSIONS MSG_UPGRADE_DISTRO
        NEW_VERSION TAGS VERSION_SELECT
    )
    local vars_min=(
        orig_user admin_group id version_id id name pretty_name msg_nonok new_version rep_glpi fichier_msg
        errorfile logfile task_index task_key language timezone ipadress interface downloadlink
        db_user db_name sqlrootpwd sqlglpipwd adminglpipwd postglpipwd techglpipwd normglpipwd
        rep_backup bdd_backup rep_script mysql_cmd mysqldump_cmd output glpi_cli_version phpversion
        debian_versions ubuntu_versions alma_versions centos_versions rocky_versions redhat_versions msg_upgrade_distro
        new_version tags version_select
    )
    local v _val
    for v in "${vars_maj[@]}" "${vars_min[@]}"; do
        _val="${!v:-}"
        export "$v"="$_val"
    done
}
# Ex√©cuter une t√¢che et g√©rer les erreurs et les logs
function run_task() {
    echo "$(date '+%F %T') [$$][DEBUG:run_task] Entr√©e dans la fonction" >> "${LOGFILE}"
    local task_key="$1"
    local task_cmd="$2"
    local index="$3"
    local total="$4"
    info "T√¢che: $index/$total - $task_key"
    info "$MSG_COMMAND: $task_cmd"
    echo "$(date '+%Y-%m-%d %H:%M:%S'): START: $task_cmd" | sudo tee -a "$LOGFILE"
    trap 'echo "[ERREUR] Ligne $LINENO : commande √©chou√©e"; exit 1' ERR | sudo tee -a "$LOGFILE"
    local output
    output=$(eval "$task_cmd")
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S'): SUCCESS: $task_cmd" | sudo tee -a "$LOGFILE"
        echo "$output" | sudo tee -a "$LOGFILE" 2>> "${ERRORFILE}"
    else
        warn "$MSG_ERROR_TASK: $task_key" 2>> "${ERRORFILE}" 1>>"${ERRORFILE}"
        return 1
    fi  
    echo "$(date '+%F %T') [$$][DEBUG:run_task] Fin de la fonction" >> "${LOGFILE}"
}
# Ex√©cuter les t√¢ches avec barre de progression
function glpi_install() {
    echo "$(date '+%F %T') [$$][DEBUG:glpi_install] Entr√©e dans la fonction" >> "${LOGFILE}"
    declare -A tasks=(
        ["$MSG_T01"]="update_distro"
        ["$MSG_T02"]="install_packages"
        ["$MSG_T03"]="network_info"
        ["$MSG_T04"]="mariadb_configure"
        ["$MSG_T05"]="install_glpi"
        ["$MSG_T06"]="setup_glpi"
        ["$MSG_T07"]="maj_user_glpi"
        ["$MSG_T08"]="write_credentials"
    )
    local task_order=("$MSG_T01" "$MSG_T02" "$MSG_T03" "$MSG_T04" "$MSG_T05" "$MSG_T06" "$MSG_T07" "$MSG_T08")
    local total_tasks=${#task_order[@]}
    local task_index=0
    (
        trap 'echo "[ERREUR] Ligne $LINENO : commande √©chou√©e" >> "$ERRORFILE"; exit 1' ERR
        for task_key in "${task_order[@]}"; do
            task_index=$((task_index + 1))
            progress=$((task_index * 100 / total_tasks))
            echo "$progress"
            echo "XXX"
            echo "$task_index/$total_tasks - $task_key : ${MSG_START}"
            echo "XXX"
            # Ex√©cution et logging
            if run_task "$task_key" "${tasks[$task_key]}" "$task_index" "$total_tasks"; then
                echo "$progress"
                echo "XXX"
                echo "$task_index/$total_tasks - $task_key : ${MSG_END}"
                echo "XXX"
                echo "$(date '+%F %T'): [OK] $task_key termin√©." >> "${LOGFILE}"
            else
                echo "100"
                echo "XXX"
                echo "$task_index/$total_tasks - $task_key : ${MSG_NONOK}"
                echo "XXX"
                echo "$(date '+%F %T'): [ERREUR] $task_key a √©chou√©." >> "${ERRORFILE}"
                echo "$MSG_ERROR_INSTALL" >> "${ERRORFILE}"
                sleep 1
                exit 1
            fi
            sleep 0.3
        done
    ) | dialog --clean --backtitle "$MSG_TITRE" --title "$MSG_TITRE_GAUGE" --gauge "" 8 120
    # Message de fin
    if [[ $? -eq 0 ]]; then
        dialog --title "GLPI" --msgbox "\n${MSG_INSTALL_DONE}\n\nLogs : ${LOGFILE}" 8 70
    else
        dialog --title "Erreur" --msgbox "\n${MSG_ERROR_INSTALL}\n\nConsultez : ${ERRORFILE}" 8 70
    fi
    echo "$(date '+%F %T') [$$][DEBUG:glpi_install] Fin de la fonction" >> "${LOGFILE}"
}
# V√©rifie si la distribution est prise en compte pour l'installation de GLPI
function check_distro(){
    echo "$(date '+%F %T') [$$][DEBUG:check_distro] Entr√©e dans la fonction" >> "${LOGFILE}"
    # V√©rifie si le fichier os-release existe
    source_os_release
    # V√©rifie si la distribution est bas√©e sur Debian, Ubuntu, Alma Linux, Centos ou Rocky Linux
    if [[ "${ID}" =~ ^(debian|ubuntu|almalinux|centos|rocky|rhel)$ ]]; then
        if compatible "$VERSION_ID" DEBIAN_VERSIONS || compatible "$VERSION_ID" UBUNTU_VERSIONS || compatible "$VERSION_ID" ALMA_VERSIONS || compatible "$VERSION_ID" CENTOS_VERSIONS || compatible "$VERSION_ID" ROCKY_VERSIONS || compatible "$VERSION_ID" REDHAT_VERSIONS; then
            info "$MSG_DISTRO_OK"
            return 0
        else
            warn "$MSG_DISTRO_NONOK"
            warn "$MSG_FORCE_DISTRO"
            if [ -t 0 ]; then
                info "$MSG_FORCE_DISTRO_QUESTION"
                read -r RESPONSE
                case $RESPONSE in
                    O|o|Y|y)
                        info "$MSG_CONTINUING"
                        ;;
                    N|n)
                        info "$MSG_EXITING"
                        return 1
                        ;;
                    *)
                        warn "$MSG_INVALID_ANSWER"
                        return 1
                        ;;
                esac
            else
                warn "$MSG_SCRIPT_NON_INTERACTIVE_DISTRO"
                return 1
            fi
        fi
        export VERSION_ID ID
        return 0
    else
        warn "$MSG_DISTRO_INVALID"
        return 1
    fi
    echo "$(date '+%F %T') [$$][DEBUG:check_distro] Fin de la fonction" >> "${LOGFILE}"
}
# Chargement du fichier de langue
function load_language() {
    echo "$(date '+%F %T') [$$][DEBUG:load_language] Entr√©e dans la fonction" >> "${LOGFILE}"
    local syslang="${LC_ALL:-${LANG:-}}"
    if [[ $syslang =~ ^fr ]]; then
        LANG_FILE="$REP_SCRIPT/lang/fr.lang"
        LANGUAGE="fr_FR"
    else
        LANG_FILE="$REP_SCRIPT/lang/en.lang"
        LANGUAGE="en_US"
    fi
    if [[ -f $LANG_FILE ]]; then
        # Ensure environment variables used in messages are exported for envsubst
        export_display_env
    # Lire le fichier ligne par ligne, g√©rer CRLF, commentaires, sections
    # et valeurs entre guillemets
        while IFS= read -r line || [ -n "$line" ]; do
            # supprimer CR si pr√©sent (fichiers format Windows)
            line="${line%%$'\r'}"
            # skip empty lines and comments
            # supprimer les espaces de t√™te
            trimmed="${line#"${line%%[![:space:]]*}"}"
            if [ -z "$trimmed" ]; then
                continue
            fi
            case "$trimmed" in
                "#"* | ";"*)
                    continue
                    ;;
            esac
            # ignorer les ent√™tes de section
            [[ $line =~ ^[[:space:]]*\[.*\] ]] && continue
            if [[ $line =~ ^[[:space:]]*([^=[:space:]]+)[[:space:]]*=(.*)$ ]]; then
                local key="${BASH_REMATCH[1]}"
                local value="${BASH_REMATCH[2]}"
                # trim leading/trailing whitespace from value
                value="${value#"${value%%[![:space:]]*}"}"
                value="${value%"${value##*[![:space:]]}"}"
                # remove surrounding single or double quotes if present
                if [[ $value =~ ^\'(.*)\'$ ]]; then
                    value="${BASH_REMATCH[1]}"
                elif [[ $value =~ ^\"(.*)\"$ ]]; then
                    value="${BASH_REMATCH[1]}"
                fi
                # D√©velopper les espaces r√©serv√©s dans la valeur avec envsubst
                # (pr√©f√©r√©) ou utiliser eval en secours
                local expanded_value
                if command -v envsubst >/dev/null 2>&1; then
                    # envsubst reads from the environment, so ensure variables are exported
                    expanded_value=$( ( set +u; printf '%s' "$value" | envsubst ) )
                else
                    # fallback : effectuer l'expansion de param√®tres en toute s√©curit√©
                    # (autoriser les variables non d√©finies)
                    expanded_value=$( ( set +u; eval "printf '%s' \"$value\"" ) )
                fi
                # affecter en toute s√©curit√© √† une variable nomm√©e par $key
                printf -v "$key" '%s' "$expanded_value"
            fi
        done < "$LANG_FILE"
        info "$MSG_LANG_LOADED ($LANGUAGE)"
    else
        warn "Language file not found: $LANG_FILE"
    fi
    echo "$(date '+%F %T') [$$][DEBUG:load_language] Fin de la fonction" >> "${LOGFILE}"
}
# Demander √† l'utilisateur de choisir la version de GLPI (4 derni√®res), le r√©pertoire d'installation, le nom de la base et l'utilisateur BDD via dialog
function prompt_install_options(){
    echo "$(date '+%F %T') [$$][DEBUG:prompt_install_options] Entr√©e dans la fonction" >> "${LOGFILE}"
    local tags=""
    local installed_version=""
    local installed_dir=""
    installed_dir=$(find /var/www -type f -name 'console' -print -quit 2>/dev/null)
    if [ -n "${installed_dir}" ]; then
        if grep -qi "glpi" "$installed_dir"; then
            # installed_dir points to bin/console ‚Äî d√©terminer le r√©pertoire racine de GLPI
            local installed_root
            installed_root=$(dirname "$(dirname "${installed_dir}")")
            installed_version=$(sed -n '1p' "${installed_root}/version" 2>/dev/null || true)
            installed_version="${installed_version//[[:space:]]/}"
            # normaliser avec slash final
            REP_GLPI="${installed_root%/}/"
        else
            dialog --title "${MSG_INFO}" --msgbox "Erreur : le fichier '${installed_dir}' ne semble pas appartenir √† GLPI." 7 60
            return 1
        fi
    fi
    local api_url="https://api.github.com/repos/glpi-project/glpi/tags"
    tags=$(curl -s "${api_url}" | jq -r '.[].name' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | sort -Vr | uniq | head -n 16)
    if [ -n "${tags}" ]; then
        if [ -n "${installed_version}" ]; then
            tags=$(printf '%s\n' "${tags}" | sort -Vr | awk -v v="${installed_version}" '$0 > v' | uniq | head -n 16)
        else
            tags=$(printf '%s\n' "${tags}" | sort -Vr | uniq | head -n 16)
        fi
        if [ -z "${tags}" ]; then
            dialog --title "${MSG_INFO}" --msgbox "Aucune version plus r√©cente que ${installed_version} n'est disponible." 7 60
            return 1
        fi
    else
        dialog --title "${MSG_INFO}" --msgbox "${MSG_GITHUB_VERSIONS_FAILED}" 7 60
        warn "${MSG_GITHUB_VERSIONS_FAILED}"
        return 1
    fi
    local args=()
    local first=ON
    local number=1
    local version_map=()
    while IFS= read -r tag; do
        args+=("${number}" "GLPI ${tag}" "${first}")
        version_map+=("${tag}")
        first=OFF
        number=$((number + 1))
    done <<< "${tags}"
    exec 3>&1
    VERSION_SELECT=$(dialog --backtitle "$MSG_TITRE" --title "${MSG_PARAM_VERSION}" --clear \
    --radiolist "${MSG_PARAM_VERSION_CHOIX}" 23 50 8 "${args[@]}" 3>&1 1>&2 2>&3)
    local rc=$?
    exec 3>&-
    if [ "${rc}" -ne 0 ]; then
        warn "S√©lection de la version annul√©e."
        return 1
    fi
    # VERSION_SELECT retourne le tag choisi (ici nous utilisons des tags num√©riques mapping -> version_map)
    if ! [[ "${VERSION_SELECT}" =~ ^[0-9]+$ ]]; then
        warn "Valeur de version invalide retourn√©e : ${VERSION_SELECT}"
        return 1
    fi
    local index=$((VERSION_SELECT - 1))
    if [ $index -lt 0 ] || [ $index -ge ${#version_map[@]} ]; then
        warn "Index de version hors plage : ${index}"
        return 1
    fi
    index=$((VERSION_SELECT - 1))
    VERSION_SELECT="${version_map[$index]}"
    local WIDTH_REP=$(( ${#MSG_PARAM_REP} ))
    local WIDTH_DB_HOST=$(( ${#MSG_PARAM_DB_HOST} ))
    local WIDTH_DB_NAME=$(( ${#MSG_PARAM_DB_NAME} ))
    local WIDTH_DB_USER=$(( ${#MSG_PARAM_DB_USER} ))
    local WIDTH=$(( WIDTH_REP > WIDTH_DB_HOST ? WIDTH_REP : WIDTH_DB_HOST ))
    local WIDTH=$(( WIDTH > WIDTH_DB_NAME ? WIDTH : WIDTH_DB_NAME ))
    local WIDTH=$(( WIDTH > WIDTH_DB_USER ? WIDTH : WIDTH_DB_USER ))
    local WIDTH=$(( WIDTH + 6 ))
    exec 3>&1
    form=$(dialog --backtitle "$MSG_TITRE" --title "$MSG_PARAM_TITLE" --clear \
    --form "${MSG_GLPI_SELECT_PARAM_1} ${VERSION_SELECT} ${MSG_GLPI_SELECT_PARAM_2}" 18 68 8 \
    "üìÅ ${MSG_PARAM_REP}"     1 2 "${REP_GLPI:-/var/www/html/glpi/}" 1 ${WIDTH} 20 40 \
    "üóÑÔ∏è ${MSG_PARAM_DB_HOST}" 3 2 "${DB_HOST:-localhost}"            3 ${WIDTH} 20 20 \
    "üíæ ${MSG_PARAM_DB_NAME}" 5 2 "${DB_NAME:-glpi}"                 5 ${WIDTH} 20 20 \
    "üë§ ${MSG_PARAM_DB_USER}" 7 2 "${DB_USER:-glpi_user}"            7 ${WIDTH} 20 20 \
    2>&1 1>&3)
    rc=$?
    exec 3>&-
    if [ "${rc}" -ne 0 ]; then
        warn "Formulaire annul√©."
        return 1
    fi
    IFS=$'\n' read -r rep_glpi db_host db_name db_user <<< "$form" || true
    local _def_rep="${REP_GLPI:-/var/www/html/glpi/}"
    local _def_db_host="${DB_HOST:-localhost}"
    local _def_db="${DB_NAME:-glpi}"
    local _def_user="${DB_USER:-glpi_user}"
    rep_glpi="${rep_glpi#"${rep_glpi%%[![:space:]]*}"}"; rep_glpi="${rep_glpi%"${rep_glpi##*[![:space:]]}"}"
    db_host="${db_host#"${db_host%%[![:space:]]*}"}"; db_host="${db_host%"${db_host##*[![:space:]]}"}"
    db_name="${db_name#"${db_name%%[![:space:]]*}"}"; db_name="${db_name%"${db_name##*[![:space:]]}"}"
    db_user="${db_user#"${db_user%%[![:space:]]*}"}"; db_user="${db_user%"${db_user##*[![:space:]]}"}"
    rep_glpi="${rep_glpi//[^A-Za-z0-9_\/.-]/_}"
    db_host="${db_host//[^A-Za-z0-9_\/.-]/_}"
    db_name="${db_name//[^A-Za-z0-9_]/_}"
    db_user="${db_user//[^A-Za-z0-9_]/_}"
    [ -z "$rep_glpi" ] && rep_glpi="$_def_rep"
    [ -z "$db_host" ] && db_host="$_def_db_host"
    [ -z "$db_name" ] && db_name="$_def_db"
    [ -z "$db_user" ] && db_user="$_def_user"
    if [[ ! "$db_name" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
        db_name="glpi_${db_name}"
    fi
    rep_glpi="${rep_glpi//\\//}"
    if [ -z "${rep_glpi}" ] || [[ "${rep_glpi}" != /* ]]; then
        rep_glpi="${_def_rep}"
    fi
    rep_glpi="$(printf '%s' "${rep_glpi}" | sed -E 's#/{2,}#/#g')"
    DB_HOST="$db_host"
    REP_GLPI="${rep_glpi%/}/"
    DB_NAME="$db_name"
    DB_USER="$db_user"
    DOWNLOADLINK="https://github.com/glpi-project/glpi/releases/download/${VERSION_SELECT}/glpi-${VERSION_SELECT}.tgz"
    export DB_HOST REP_GLPI DB_NAME DB_USER DOWNLOADLINK tags
    echo "$(date '+%F %T') [$$][DEBUG:prompt_install_options] Fin de la fonction" >> "${LOGFILE}"
}
# V√©rifie si la version est compatible
function compatible() {
    echo "$(date '+%F %T') [$$][DEBUG:compatible] Entr√©e dans la fonction" >> "${LOGFILE}"
    local version="$1"
    local -n versions_array="$2"
    [[ ${versions_array[*]} =~ ${version} ]]
    echo "$(date '+%F %T') [$$][DEBUG:compatible] Fin de la fonction" >> "${LOGFILE}"
}
# V√©rifie si GLPI est install√© ou pas
function check_install() {
    echo "$(date '+%F %T') [$$][DEBUG:check_install] Entr√©e dans la fonction" >> "${LOGFILE}"
    set +e  # ne pas casser le script sur une erreur ici
    local FIND_REP_GLPI=""
    local installed_version=""
    local version_file=""
    # Recherche du r√©pertoire GLPI
    for path in /var/www /srv /opt /usr/share; do
        FIND_REP_GLPI=$(find "$path" -maxdepth 3 -type d -name "glpi" -print -quit 2>/dev/null)
        [[ -n "$FIND_REP_GLPI" ]] && break
    done
    # Si GLPI est d√©j√† install√©
    if [[ -n "$FIND_REP_GLPI" ]]; then
        FIND_REP_GLPI="${FIND_REP_GLPI%/}/"
        echo "R√©pertoire GLPI trouv√© : $FIND_REP_GLPI" | sudo tee -a "${LOGFILE}"
        version_file="${FIND_REP_GLPI}/version"
        if [[ -f "$version_file" ]]; then
            installed_version=$(head -n1 "$version_file" | tr -d '[:space:]')
            echo "$(date '+%F %T'): Version GLPI d√©tect√©e : ${installed_version}" >> "${LOGFILE}"
        else
            warn "Fichier version introuvable dans ${FIND_REP_GLPI}" >> "${ERRORFILE}"
        fi
        # Comparaison avec la version √† installer
        if [[ -n "$installed_version" && -n "$VERSION_SELECT" && "$installed_version" != "$VERSION_SELECT" ]]; then
            echo "$(date '+%F %T'): Version cible : ${VERSION_SELECT}" >> "${LOGFILE}"
            
            if [[ "$(printf '%s\n%s\n' "$installed_version" "$VERSION_SELECT" | sort -V | head -n1)" == "$installed_version" ]]; then
                dialog --title "GLPI" --sleep 5 --infobox "\n\n${MSG_GLPI_UPDATE}\n\nGLPI ${installed_version} ‚Üí ${VERSION_SELECT}" 10 50
                info "$MSG_CONTINUING" >> "${LOGFILE}"

                if update; then
                    dialog --title "GLPI" --sleep 5 --infobox "Mise √† jour GLPI ${installed_version} ‚Üí ${VERSION_SELECT} termin√©e." 10 50
                    info "Mise √† jour GLPI ${installed_version} ‚Üí ${VERSION_SELECT} termin√©e." >> "${LOGFILE}"
                    return 0
                else
                    dialog --title "Erreur" --msgbox "La mise √† jour a √©chou√© ou a √©t√© annul√©e." 6 60
                    warn "√âchec de la mise √† jour GLPI." >> "${ERRORFILE}"
                    return 1
                fi
            else
                dialog --title "GLPI" --sleep 5 --infobox "Version actuelle (${installed_version}) plus r√©cente que la cible (${VERSION_SELECT}), aucune mise √† jour." 10 50
                info "Version actuelle (${installed_version}) plus r√©cente que la cible (${VERSION_SELECT}), aucune mise √† jour." >> "${LOGFILE}"
                return 0
            fi
        else
            info "GLPI ${installed_version:-inconnue} d√©j√† install√©, aucune action requise." >> "${LOGFILE}"
            return 0
        fi
    else
        # --- Pas d'installation d√©tect√©e ---
        dialog --title "GLPI" --sleep 5 --infobox "\n\n${MSG_GLPI_NEW}\n\nGLPI ${VERSION_SELECT}" 10 50
        glpi_install
        if [ $? -eq 0 ]; then
            dialog --title "GLPI" --sleep 5 --infobox "Installation de GLPI ${VERSION_SELECT} termin√©e." 10 50
            info "Installation de GLPI ${VERSION_SELECT} termin√©e." >> "${LOGFILE}"
            return 0
        else
            dialog --title "Erreur" --msgbox "L'installation de GLPI a √©chou√© ou a √©t√© annul√©e." 6 60
            warn "√âchec de l'installation GLPI." >> "${ERRORFILE}"
            return 1
        fi
    fi
    echo "$(date '+%F %T') [$$][DEBUG:check_install] Fin de la fonction" >> "${LOGFILE}"
}
# Mise √† jour de la distribution
function update_distro(){
    echo "$(date '+%F %T') [$$][DEBUG:update_distro] Entr√©e dans la fonction" >> "${LOGFILE}"
    source_os_release
    warn "$(date '+%Y-%m-%d %H:%M:%S'): DEBUG: entering update_distro (ID=${ID:-unknown})" >> "${LOGFILE}"
    if [[ "${ID}" =~ ^(debian|ubuntu)$ ]]; then
           info "$MSG_UPGRADE_DISTRO"
           timedatectl set-ntp true # Synchronise l'heure
           sleep 5
           apt-get update && apt-get upgrade -y
    elif [[ "${ID}" =~ ^(almalinux|centos|rocky|rhel)$ ]]; then
           info "$MSG_UPGRADE_DISTRO"
           chronyc makestep # Synchronise l'heure
           sleep 5
           yum update -y && yum upgrade -y
	fi
    echo "$(date '+%F %T') [$$][DEBUG:update_distro] Fin de la fonction" >> "${LOGFILE}"
}
# Adresse IP de la machine
function network_info() {
    echo "$(date '+%F %T') [$$][DEBUG:network_info] Entr√©e dans la fonction" >> "${LOGFILE}"
    # D√©tection de l‚Äôinterface principale (hors loopback et interfaces virtuelles)
    INTERFACE=$(ip route get 1.1.1.1 2>/dev/null | awk '/dev/ {print $5; exit}')
    if [[ -z "$INTERFACE" ]]; then
        INTERFACE=$(ip -o link show | awk -F': ' '!/lo|docker|vir|veth/ {print $2; exit}')
    fi
    # R√©cup√©ration de l‚Äôadresse IP associ√©e
    IPADRESS=$(ip -4 addr show "$INTERFACE" 2>/dev/null | awk '/inet / {print $2}' | cut -d'/' -f1 | head -n1)
    # V√©rification et export
    if [[ -n "$IPADRESS" ]]; then
        export IPADRESS
        echo "$(date '+%F %T'): INFO: Interface d√©tect√©e : ${INTERFACE}, IP : ${IPADRESS}" >> "${LOGFILE}"
    else
        warn "Impossible de d√©terminer l‚Äôadresse IP du serveur via l‚Äôinterface ${INTERFACE:-inconnue}" >> "${ERRORFILE}"
        IPADRESS="127.0.0.1"
        export IPADRESS
    fi
    echo "$(date '+%F %T') [$$][DEBUG:network_info] Fin de la fonction" >> "${LOGFILE}"
}
# Installation des √©l√©ments n√©cessaire
function install_packages(){
    echo "$(date '+%F %T') [$$][DEBUG:install_packages] Entr√©e dans la fonction" >> "${LOGFILE}"
    source_os_release
    warn "$(date '+%Y-%m-%d %H:%M:%S'): DEBUG: entering install_packages (ID=${ID:-unknown})" >> "${LOGFILE}"
    if [[ "${ID:-}" =~ ^(debian|ubuntu)$ ]]; then
        sleep 1
        export DEBIAN_FRONTEND=noninteractive
        # update cache first
        if command -v apt-get >/dev/null 2>&1; then
            echo "$(date '+%Y-%m-%d %H:%M:%S'): DEBUG: apt-get update" >> "${LOGFILE}"
            if ! apt-get update >/dev/null 2>>"${ERRORFILE}"; then
                warn "apt-get update failed"
                # continue, maybe cached; but log
            fi
        else
            warn "apt-get not found, cannot install packages on Debian/Ubuntu branch" >> "${ERRORFILE}"
            return 1
        fi
        info "$MSG_INSTALL_EXT_PHP"
        if ! sudo apt-get install -y php-{bcmath,mysql,mbstring,curl,gd,xml,intl,ldap,apcu,opcache,xmlrpc,zip,bz2} 2>>"${ERRORFILE}"; then
            warn "$MSG_PHP_EXT_FAILED" 2>>"${ERRORFILE}"
            return 1
        fi
        info "$MSG_INSTALL_SERVICE"
        if ! sudo apt-get install -y wget composer tar apache2 apache2-bin mariadb-server mariadb-client perl php 2>>"${ERRORFILE}"; then
            warn "$MSG_LAMP_FAILED" 2>>"${ERRORFILE}"
            return 1
        fi
        info "$MSG_ACTIVE_START_BDD"
        if ! systemctl enable mariadb > /dev/null 2>>"${ERRORFILE}"; then
            echo "√âchec de l'activation de MariaDB." 2>>"${ERRORFILE}"
            return 1
        fi
        if ! systemctl restart mariadb > /dev/null 2>>"${ERRORFILE}"; then
            echo "√âchec du red√©marrage de MariaDB." 2>>"${ERRORFILE}"
            return 1
        fi
        info "$MSG_ACTIVE_START_WEB"
        if ! systemctl enable apache2 > /dev/null 2>>"${ERRORFILE}"; then
            echo "√âchec de l'activation d'Apache2." 2>>"${ERRORFILE}"
            return 1
        fi
        if ! systemctl restart apache2 > /dev/null 2>>"${ERRORFILE}"; then
            echo "√âchec du red√©marrage d'Apache2." 2>>"${ERRORFILE}"
            return 1
        fi
    elif [[ "${ID:-}" =~ ^(almalinux|centos|rocky|rhel|fedora)$ ]]; then
        sleep 1
        if ! command -v dnf >/dev/null 2>&1; then
            warn "dnf not found, cannot install packages on RHEL-like branch"
            return 1
        fi
        echo "$(date '+%Y-%m-%d %H:%M:%S'): DEBUG: dnf makecache" >> "${LOGFILE}"
        if ! dnf makecache --refresh >>"${LOGFILE}" 2>>"${ERRORFILE}"; then
            warn "$MSG_EPEL_FAILED"
            # continue; attempt install may still work
        fi
        if ! dnf install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm >>"${LOGFILE}" 2>>"${ERRORFILE}"; then
            warn "$MSG_EPEL_FAILED"
            return 1
        fi
        if ! dnf module reset -y php nginx mariadb composer >>"${LOGFILE}" 2>>"${ERRORFILE}"; then
            warn "$MSG_MODULES_RESET_FAILED"
            return 1
        fi
        if ! dnf module install -y php:8.2 >>"${LOGFILE}" 2>>"${ERRORFILE}"; then
            warn "$MSG_PHP_INSTALL_FAILED"
            return 1
        fi
        if ! dnf module install -y nginx:1.24 >>"${LOGFILE}" 2>>"${ERRORFILE}"; then
            warn "$MSG_NGINX_INSTALL_FAILED"
            return 1
        fi
        if ! dnf module install -y mariadb:10.11 >>"${LOGFILE}" 2>>"${ERRORFILE}"; then
            warn "$MSG_MARIADB_INSTALL_FAILED"
            return 1
        fi
        info "$MSG_AUTO_UPDATES"
        if ! dnf install dnf-automatic -y >>"${LOGFILE}" 2>>"${ERRORFILE}"; then
            warn "$MSG_DNF_AUTO_FAILED"
            return 1
        fi
        sed -i 's/^\(;\?\)\(apply_updates =\).*/\2 yes/' /etc/dnf/automatic.conf
        sed -i 's/^\(;\?\)\(reboot =\).*/\2 when-needed/' /etc/dnf/automatic.conf
        sed -i 's/^\(;\?\)\(upgrade_type =\).*/\2 security/' /etc/dnf/automatic.conf
        if ! mkdir /etc/systemd/system/dnf-automatic.timer.d 2>/dev/null; then
            warn "$MSG_DNF_AUTO_DIR_FAILED"
            return 1
        fi
        sudo tee /etc/systemd/system/dnf-automatic.timer.d/override.conf > /dev/null << 'EOF'
[Unit]
Description=dnf-automatic timer
ConditionPathExists=!/run/ostree-booted
Wants=network-online.target

[Timer]
OnCalendar=*-*-* 6:00
RandomizedDelaySec=60m
Persistent=true
EOF
        if ! systemctl enable --now dnf-automatic.timer >>"${LOGFILE}" 2>>"${ERRORFILE}"; then
            warn "$MSG_DNF_AUTO_ACTIVATE_FAILED"
            return 1
        fi
        info "$MSG_INSTALL_EXT_PHP"
        if ! dnf install -y php-{bcmath,mysql,mbstring,curl,gd,xml,intl,ldap,apcu,opcache,xmlrpc,zip,bz2} >>"${LOGFILE}" 2>>"${ERRORFILE}"; then
            warn "$MSG_PHP_EXT_FAILED"
            return 1
        fi
        info "$MSG_INSTALL_SERVICE lamp..."
        if ! dnf install -y crontabs logrotate cronie tar nginx mariadb-server mariadb perl curl jq php epel-release >>"${LOGFILE}" 2>>"${ERRORFILE}"; then
            warn "$MSG_LAMP_FAILED"
            return 1
        fi
        sed -i 's/^\(;\?\)\(user =\).*/\2 nginx/' /etc/php-fpm.d/www.conf
        sed -i 's/^\(;\?\)\(group =\).*/\2 nginx/' /etc/php-fpm.d/www.conf
        info "$MSG_ACTIVE_START_WEB MariaDB, d'ENGINE X et de PHP-FPM"
        if ! systemctl enable --now mariadb nginx php-fpm >>"${LOGFILE}" 2>>"${ERRORFILE}"; then
            warn "$MSG_SERVICES_START_FAILED"
            return 1
        fi
        if ! firewall-cmd --permanent --zone=public --add-service=http || ! firewall-cmd --reload >>"${LOGFILE}" 2>>"${ERRORFILE}"; then
            warn "$MSG_FIREWALL_FAILED"
            return 1
        fi
    fi
    echo "$(date '+%F %T') [$$][DEBUG:install_packages] Fin de la fonction" >> "${LOGFILE}"
}
# Configuration de la base de donn√©es MariaDB
function mariadb_configure() {
    echo "$(date '+%F %T') [$$][DEBUG:mariadb_configure] Entr√©e dans la fonction" >> "${LOGFILE}"
    warn "$(date '+%Y-%m-%d %H:%M:%S'): DEBUG: entering mariadb_configure (ID=${ID:-unknown})" >> "${LOGFILE}"
    info "$MSG_BDD_CONFIG" >> "${LOGFILE}"
    # D√©tecter la commande MySQL/MariaDB
    MYSQL_CMD=$(command -v mysql 2>/dev/null || command -v mariadb 2>/dev/null || echo mysql) 
    if [ -z "$MYSQL_CMD" ]; then 
        warn "Commande MySQL/MariaDB introuvable" >> "${ERRORFILE}"
        return 1
    fi
    sleep 1
    # Construire la commande SQL et l'ex√©cuter avec -e (√©vite les probl√®mes d'heredoc et de quoting)
    local _sql_root
    _sql_root="ALTER USER 'root'@'localhost' IDENTIFIED BY '${SQLROOTPWD}';"
    _sql_root+="\nDELETE FROM mysql.user WHERE User='';"
    _sql_root+="\nDELETE FROM mysql.user WHERE User='root' AND Host!='localhost';"
    _sql_root+="\nDROP DATABASE IF EXISTS test;"
    _sql_root+="\nDELETE FROM mysql.db WHERE Db='test' OR Db LIKE 'test_%';"
    _sql_root+="\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION;"
    _sql_root+="\nCREATE DATABASE IF NOT EXISTS \`${DB_NAME}\`;"
    _sql_root+="\nCREATE USER IF NOT EXISTS '${DB_USER}'@'localhost' IDENTIFIED BY '${SQLGLPIPWD}';"
    _sql_root+="\nGRANT ALL PRIVILEGES ON \`${DB_NAME}\`.* TO '${DB_USER}'@'localhost';"
    _sql_root+="\nGRANT SELECT ON mysql.time_zone_name TO '${DB_USER}'@'localhost';"
    _sql_root+="\nFLUSH PRIVILEGES;"
    if ! MYSQL_PWD="${SQLROOTPWD}" "${MYSQL_CMD}" -u root --batch --silent -e "${_sql_root}" mysql >>"${LOGFILE}" 2>>"${ERRORFILE}"; then
        warn "$MSG_ERROR_TASK: base de donn√©es - √©chec des modifications en bloc"
        return 1
    fi
    # D√©tection du fuseau horaire
    if [ -z "${TIMEZONE:-}" ]; then
        if command -v timedatectl >/dev/null 2>&1; then
            TIMEZONE=$(timedatectl show -p Timezone --value 2>/dev/null || true)
        fi
        if [ -z "${TIMEZONE:-}" ] && [ -f /etc/timezone ]; then
            TIMEZONE=$(sed -n '1p' /etc/timezone 2>/dev/null || true)
        fi
        if [ -z "${TIMEZONE:-}" ]; then
            if [ -L /etc/localtime ] || [ -f /etc/localtime ]; then
                tzfile=$(readlink -f /etc/localtime 2>/dev/null || true)
                case "$tzfile" in
                    */usr/share/zoneinfo/*) TIMEZONE=${tzfile#*/usr/share/zoneinfo/} ;;
                esac
            fi
        fi
        if [ -z "${TIMEZONE:-}" ] && [ -f /etc/sysconfig/clock ]; then
            TIMEZONE=$(awk -F= '/^ZONE/ {gsub(/"/,"",$2); print $2}' /etc/sysconfig/clock 2>/dev/null || true)
        fi
        TIMEZONE=${TIMEZONE:-UTC}
        export TIMEZONE
        info "Fuseau horaire d√©tect√© : ${TIMEZONE}"
    fi
    info "$MSG_TIMEZONE_CONFIG"
    if ! mysql_tzinfo_to_sql /usr/share/zoneinfo 2>/dev/null | MYSQL_PWD="${SQLROOTPWD}" "${MYSQL_CMD}" -u root mysql; then
        warn "$MSG_ERROR_TASK: import du timezone √©chou√©"
        return 1
    fi
    systemctl restart mariadb >/dev/null 2>&1 || warn "Impossible de red√©marrer MariaDB (v√©rifiez le service)"
    sleep 5
    echo "$(date '+%F %T') [$$][DEBUG:mariadb_configure] Fin de la fonction" >> "${LOGFILE}"
}
# T√©l√©chargement et d√©compression de GLPI
function install_glpi(){
    echo "$(date '+%F %T') [$$][DEBUG:install_glpi] Entr√©e dans la fonction" >> "${LOGFILE}"
    info "$MSG_DOWNLOAD_INSTALL_GLPI"
    # T√©l√©chargement de GLPI
    tmp_file="$(mktemp /tmp/glpi_XXX.tar.gz)"
    if ! wget -q -O "$tmp_file" "${DOWNLOADLINK}"; then
        warn "$MSG_DOWNLOAD_FAILED"
        rm -f "$tmp_file"
        return 1
    fi
    if [ ! -d "$REP_GLPI" ]; then
        mkdir -p "$REP_GLPI" || { warn "$MSG_CREATE_DIR_FAILED"; rm -f "$tmp_file"; return 1; }
    fi
    # Extraire l'archive dans le r√©pertoire d'installation
    tar xzf "$tmp_file" --strip-components=1 -C "$REP_GLPI"
    rm -f "$tmp_file"
    sleep 5;
    echo "$(date '+%F %T') [$$][DEBUG:install_glpi] Fin de la fonction" >> "${LOGFILE}"
}
# Mise en place des r√©glage pour GLPI
function setup_glpi(){
    echo "$(date '+%F %T') [$$][DEBUG:setup_glpi] Entr√©e dans la fonction" >> "${LOGFILE}"
    source_os_release
    info "$MSG_CONFIG_GLPI" >> "${LOGFILE}"
    mkdir -p /var/log/glpi
    mkdir -p /etc/glpi/config
    mkdir -p /var/lib/glpi/files
    mv -f "${REP_GLPI}"/files /var/lib/glpi
    sudo tee /etc/glpi/config/local_define.php > /dev/null <<'EOF'
<?php
    define('GLPI_VAR_DIR', '/var/lib/glpi/files');
    define('GLPI_LOG_DIR', '/var/log/glpi');
EOF
    sleep 1
    sudo tee "${REP_GLPI}"/inc/downstream.php > /dev/null <<EOF
<?php
    define('GLPI_CONFIG_DIR', '/etc/glpi/config');
    if (file_exists(GLPI_CONFIG_DIR . '/local_define.php')) {
        require_once GLPI_CONFIG_DIR . '/local_define.php';
    }
EOF
    network_info
    if [[ "${ID}" =~ ^(debian|ubuntu)$ ]]; then
        # Configuration d'Apache pour GLPI
        sudo tee /etc/apache2/sites-available/glpi.conf > /dev/null <<EOF
<VirtualHost *:80>
    ServerName ${IPADRESS}
    DocumentRoot ${REP_GLPI}/public
    <Directory ${REP_GLPI}/public>
        Require all granted
        RewriteEngine On
        RewriteCond %{HTTP:Authorization} ^(.+)$
        RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
        RewriteCond %{REQUEST_FILENAME} !-f
        RewriteRule ^(.*)$ index.php [QSA,L]
    </Directory>
    ErrorLog /var/log/glpi/error.log
    CustomLog /var/log/glpi/access.log combined
</VirtualHost>
EOF
        phpversion=$(php -v | grep -i '(cli)' | awk '{print $2}' | cut -d. -f1,2)
        sed -i 's/^\(;\?\)\(session.cookie_httponly\).*/\2 =on/' /etc/php/"$phpversion"/apache2/php.ini
        sleep 1
        # Disable Apache Web Server Signature
        echo "ServerSignature Off" >> /etc/apache2/apache2.conf
        echo "ServerTokens Prod" >> /etc/apache2/apache2.conf
        # Activation du module rewrite d'apache
        {
            # Enable Apache modules and site configuration
            # Mode rewrite activ√©
            a2enmod rewrite;
            # D√©activer le site par d√©faut
            a2dissite 000-default.conf;
            # Activer le site GLPI
            a2ensite glpi.conf;
            # Recharger la configuration d'Apache
            systemctl reload apache2;
            # Change permissions
            rights_glpi || { 
                warn "√âchec de la modification des droits pour GLPI." >>"${ERRORFILE}"
                return 1
            }
        } 1>>"${LOGFILE}" 2>>"${LOGFILE}" || {
            warn "√âchec de la configuration d'Apache pour GLPI." >>"${ERRORFILE}"
            return 1
        }
        # Installation de GLPI en ligne de commande
        CMD="${REP_GLPI}/bin/console db:install \
 --db-host localhost \
 --db-port=3306 \
 --db-name=${DB_NAME} \
 --db-user=${DB_USER} \
 --db-password=${SQLGLPIPWD} \
 --default-language=${LANGUAGE} \
 --force \
 --no-telemetry \
 --quiet \
 --no-interaction"
        echo "$(date '+%Y-%m-%d %H:%M:%S') - [INFO] Ex√©cution : sudo -u www-data php ${CMD}" 1>>"${LOGFILE}" || true
        # Ex√©cuter la commande en tant que www-data. Utiliser sudo tee pour √©crire vers les fichiers prot√©g√©s.
        if eval "sudo -u www-data php ${CMD}" 2>>"${ERRORFILE}" 1>>"${LOGFILE}"; then
            info "Installation GLPI termin√©e avec succ√®s." >>"${LOGFILE}"
        else
            warn "√âchec de l'installation GLPI via console." >>"${ERRORFILE}"
            return 1
        fi
        systemctl restart apache2
        # Configuration de la t√¢che Cron
        echo "*/2 * * * * www-data /usr/bin/php ""${REP_GLPI}""front/cron.php &>/dev/null" >> /etc/cron.d/glpi
    elif [[ "${ID}" =~ ^(almalinux|centos|rocky|rhel)$ ]]; then
        network_info
        sudo tee /etc/nginx/conf.d/glpi.conf > /dev/null << EOF
server {
    listen 80;
    server_name "${IPADRESS}";
    root ${REP_GLPI}public;
    location / {
        try_files \$uri /index.php\$is_args\$args;
    }
    location ~ ^/index\.php$ {
        # the following line needs to be adapted, as it changes depending on OS distributions and PHP versions
        fastcgi_pass unix:/var/run/php-fpm/www.sock;
        fastcgi_split_path_info ^(.+\.php)(/.*)$;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;
    }
}
EOF
        sudo tee /etc/logrotate.d/glpi > /dev/null << EOF
# Rotate GLPI logs daily, only if not empty
# Save 14 days old logs under compressed mode
/var/lib/glpi/files/_log/*.log {
    su nginx nginx
    daily
    rotate 14
    compress
    notifempty
    missingok
    create 644 nginx nginx
}
EOF
        chmod 0644 /etc/logrotate.d/glpi
        chown root:root /etc/logrotate.d/glpi
        chcon system_u:object_r:etc_t:s0 /etc/logrotate.d/glpi
        sed -i 's/^\(;\?\)\(session.cookie_httponly\).*/\2 = on/' /etc/php.ini
        # Change permissions
        rights_glpi || { 
            warn "√âchec de la modification des droits pour GLPI." >>"${ERRORFILE}"
            return 1
        }
        # Recharger la configuration de Nginx
        systemctl reload nginx php-fpm
        sleep 2
        # Installation de GLPI en ligne de commande
        CMD="php ${REP_GLPI}bin/console db:install --db-host=\"localhost\" --db-port=3306 --db-name=${DB_NAME} --db-user=${DB_USER} --db-password=\"${SQLGLPIPWD}\" --default-language=\"${LANGUAGE}\" --force --no-telemetry --no-interaction"
        eval sudo -u nginx "${CMD}"
        echo "*/2 * * * * nginx /usr/bin/php ""${REP_GLPI}""front/cron.php &>/dev/null" >> /etc/cron.d/glpi
    fi
    sleep 5
    rm -Rf "${REP_GLPI}"install/install.php
	sleep 2;
    echo "$(date '+%F %T') [$$][DEBUG:setup_glpi] Fin de la fonction" >> "${LOGFILE}"
}
# Mise √† jour des mot de passe des utilisateurs de GLPI
function maj_user_glpi(){
    echo "$(date '+%F %T') [$$][DEBUG:maj_user_glpi] Entr√©e dans la fonction" >> "${LOGFILE}"
    info "${MSG_CHANGE_MDP_GLPI}"
    # Ensure we have a mysql client command; fallback to detecting it if not set
    MYSQL_CMD=$(command -v mysql 2>/dev/null || command -v mariadb 2>/dev/null || echo mysql)
    # Verify mysql client exists
    if ! command -v "${MYSQL_CMD}" >/dev/null 2>&1; then
        warn "mysql client not found: ${MYSQL_CMD}"
        return 1
    fi
    # Construire la requ√™te SQL et ex√©cuter via -e
    local _sql_user
    _sql_user="USE '${DB_NAME}';"
    _sql_user+="\nUPDATE glpi_users SET password = MD5('${ADMINGLPIPWD}') WHERE name = 'glpi';"
    _sql_user+="\nUPDATE glpi_users SET password = MD5('${POSTGLPIPWD}') WHERE name = 'post-only';"
    _sql_user+="\nUPDATE glpi_users SET password = MD5('${TECHGLPIPWD}') WHERE name = 'tech';"
    _sql_user+="\nUPDATE glpi_users SET password = MD5('${NORMGLPIPWD}') WHERE name = 'normal';"
    _sql_user+="\nUPDATE glpi_configs SET value = '${TIMEZONE}' WHERE context = 'core' AND name = 'timezone';"
    _sql_user+="\nUPDATE glpi_configs SET value = '${LANGUAGE}' WHERE context = 'core' AND name = 'language';"
    _sql_user+="\nUPDATE glpi_configs SET value = '${IPADRESS}' WHERE context = 'core' AND name = 'url_base';"
    echo "${_sql_user}" >> "${LOGFILE}"
    # Execute the SQL commands
    if ! MYSQL_PWD="${SQLGLPIPWD}" "${MYSQL_CMD}" -u "${DB_USER}" --batch --silent -e "${_sql_user}" >>"${LOGFILE}" 2>>"${ERRORFILE}"; then
        warn "$MSG_ERROR_TASK: base de donn√©es - √©chec des modifications en bloc"
        return 1
    fi
    echo "$(date '+%F %T') [$$][DEBUG:maj_user_glpi] Fin de la fonction" >> "${LOGFILE}"
}
function source_os_release(){
    echo "$(date '+%F %T') [$$][DEBUG:source_os_release] Entr√©e dans la fonction" >> "${LOGFILE}"
    if [[ -f /etc/os-release ]]; then
        source /etc/os-release
    fi
    if [[ -f /etc/lsb-release ]]; then
        source /etc/lsb-release
    fi
    if [[ -z "${ID:-}" ]]; then
        ID=$(uname -s | tr '[:upper:]' '[:lower:]')
    fi
    if [[ -z "${VERSION_ID:-}" ]]; then
        VERSION_ID=$(uname -r)
    fi
    if [ -z "${ID:-}" ] || [ -z "${VERSION_ID:-}" ]; then
        warn "Variables ID ou VERSION_ID non d√©finies apr√®s sourcing de /etc/os-release" >> "${ERRORFILE}"
        return 1
    fi
    echo "$(date '+%F %T'): INFO: OS d√©tect√© : ${ID} ${VERSION_ID}" >> "${LOGFILE}"
    echo "$(date '+%F %T') [$$][DEBUG:source_os_release] Fin de la fonction" >> "${LOGFILE}"
}
function rights_glpi(){
    echo "$(date '+%F %T') [$$][DEBUG:rights_glpi] Entr√©e dans la fonction" >> "${LOGFILE}"
    source_os_release
    echo "$(date '+%F %T'): INFO: after source_os_release (ID=${ID:-unknown})" >> "${LOGFILE}"
    # Changer les droits des r√©pertoires et fichiers
    {
        info "$MSG_RIGHTS_GLPI"
        for dir in /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}"; do
            [[ -d "$dir" ]] || continue
            find "$dir" -type d -exec chmod 755 {} \; 2>/dev/null
            find "$dir" -type f -exec chmod 644 {} \; 2>/dev/null
        done
    } >> "${LOGFILE}" 2>> "${ERRORFILE}"
    # Changer le propri√©taire des r√©pertoires
    case "${ID}" in
        debian|ubuntu)
            {
                sudo chown -Rc www-data:www-data /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}" 2>/dev/null
            } >> "${LOGFILE}" 2>> "${ERRORFILE}"
            ;;
        almalinux|centos|rocky|rhel)
            {
                sudo chown -Rc nginx:nginx /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}" 2>/dev/null
                if command -v semanage >/dev/null 2>&1; then
                    setsebool -P httpd_can_network_connect on
                    setsebool -P httpd_can_network_connect_db on
                    setsebool -P httpd_can_sendmail on
                    for p in "${REP_GLPI}" /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}/marketplace"; do
                        semanage fcontext -a -t httpd_sys_rw_content_t "${p}(/.*)?"
                    done
                    restorecon -R "${REP_GLPI}" /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}/marketplace"
                else
                    echo "$(date '+%F %T'): WARN: semanage non disponible ‚Äî SELinux non configur√©" >> "${ERRORFILE}"
                fi
            } >> "${LOGFILE}" 2>> "${ERRORFILE}"
            ;;
        *)
            echo "$(date '+%F %T'): WARN: Distribution ${ID:-unknown} non reconnue ‚Äî aucun changement propri√©taire" >> "${ERRORFILE}"
            ;;
    esac
    echo "$(date '+%F %T'): INFO: Fin de rights_glpi pour ${ID}" >> "${LOGFILE}"
    echo "$(date '+%F %T') [$$][DEBUG:rights_glpi] Fin de la fonction" >> "${LOGFILE}"
}
# Afficher le r√©sultat final
function display_result() {
    echo "$(date '+%F %T') [$$][DEBUG:display_result] Entr√©e dans la fonction" >> "${LOGFILE}"
    MESSAGE=""
	if [[ -f "$FICHIER_MSG" ]]; then
        while IFS= read -r ligne; do
            MESSAGE+="${ligne}\n"
        done < "$FICHIER_MSG"
        dialog --backtitle "$MSG_TITRE" --title "$MSG_TITRE_OK" --msgbox "$MESSAGE" 0 0
    else
        while IFS= read -r ligne; do
            MESSAGE+="${ligne}\n"
        done < "$ERRORFILE"
        dialog --backtitle "$MSG_TITRE" --title "$MSG_TITRE_NONOK" --msgbox "$MSG_NONOK\n\n$MESSAGE" 0 0
        warn "$MSG_ERROR_FICHIER_MSG"
    fi
    echo "$(date '+%F %T') [$$][DEBUG:display_result] Fin de la fonction" >> "${LOGFILE}"
}
# Ecriture du fichier pour sauvegarder les mot de passe du serveur GLPI
function write_credentials(){
    echo "$(date '+%F %T') [$$][DEBUG:write_credentials] Entr√©e dans la fonction" >> "${LOGFILE}"
    if [[ "${LANGUAGE}" == "fr_FR" ]]; then
        cat > "$FICHIER_MSG" << EOF
<==========================> D√©tails de l'installation de GLPI <=================================>
GLPI Version: ${VERSION_SELECT}
R√©pertoire d'installation de GLPI: ${REP_GLPI}

Les comptes utilisateurs par d√©faut sont :
UTILISATEUR   -  MOT DE PASSE       -       ACCES
 glpi         -  ${ADMINGLPIPWD}     -  compte admin
 post-only    -  ${POSTGLPIPWD}     -  compte post-only
 tech         -  ${TECHGLPIPWD}     -  compte tech
 normal       -  ${NORMGLPIPWD}     -  compte normal

Vous pouvez acc√©der √† la page web de GLPI √† partir d'une adresse IP ou d'un nom d'h√¥te :
http://${IPADRESS}

==> Base de donn√©es:
H√¥te de la base de donn√©es: ${DB_HOST}
Port de la base de donn√©es: 3306
Nom de la base de donn√©es GLPI: ${DB_NAME}
Mot de passe root: ${SQLROOTPWD}
Mot de passe ${DB_USER}: ${SQLGLPIPWD}

Fichier de sauvegarde enregistr√© dans ${FICHIER_MSG}
<===============================================================================================>

Si vous rencontrez un probl√©me avec ce script, veuillez le signaler sur GitHub : https://github.com/PapyPoc/glpi_install/issues
EOF
	else
		cat > "$FICHIER_MSG" << EOF
<=============================> GLPI installation details <====================================>
GLPI version: ${VERSION_SELECT}
GLPI installation directory: ${REP_GLPI}

The default user accounts are:
  USER         -    PASSWORD        -       ACCESS
glpi           -  ${ADMINGLPIPWD}      -  admin account
post-only      -  ${POSTGLPIPWD}      -  post-only account
tech           -  ${TECHGLPIPWD}      -  tech account
normal         -  ${NORMGLPIPWD}      -  normal account

You can access the GLPI web page from the following address :
http://${IPADRESS}

==> Database:
Database host: ${DB_HOST}
Database port: 3306
GLPI database name: ${DB_NAME}
Root password: ${SQLROOTPWD}
$DB_USER password: ${SQLGLPIPWD}

Backup file saved to ${FICHIER_MSG}
<===============================================================================================>

If you encounter a problem with this script, please report it on GitHub : https://github.com/PapyPoc/glpi_install/issues
EOF
	fi
    echo "$(date '+%F %T') [$$][DEBUG:write_credentials] Fin de la fonction" >> "${LOGFILE}"
}
# Activ√© ou d√©activ√© le mode maintenance (1 ou 0)
function maintenance(){
    echo "$(date '+%F %T') [$$][DEBUG:maintenance] Entr√©e dans la fonction" >> "${LOGFILE}"
    if [ "$1" == "1" ]; then
        warn "${MSG_ACTIVE_SERVICE}"
        if [[ "${ID}" =~ ^(debian|ubuntu)$ ]]; then
            sudo -u www-data php "${REP_GLPI}"bin/console glpi:maintenance:enable
        elif [[ "${ID}" =~ ^(almalinux|centos|rocky|rhel)$ ]]; then
            sudo -u nginx php "${REP_GLPI}"bin/console glpi:maintenance:enable
        fi
    elif [ "$1" == "0" ]; then
        info "$MSG_DEACTIVE_SERVICE"
        if [[ "${ID}" =~ ^(debian|ubuntu)$ ]]; then
            sudo -u www-data php "${REP_GLPI}"bin/console glpi:maintenance:disable
        elif [[ "${ID}" =~ ^(almalinux|centos|rocky|rhel)$ ]]; then
            sudo -u nginx php "${REP_GLPI}"bin/console glpi:maintenance:disable
        fi
    fi
	sleep 2;
    echo "$(date '+%F %T') [$$][DEBUG:maintenance] Fin de la fonction" >> "${LOGFILE}"
}
# Sauvegarde de la base de donn√©e et des fichiers de GLPI
function backup_glpi() {
    echo "$(date '+%F %T') [$$][DEBUG:backup_glpi] Entr√©e dans la fonction" >> "${LOGFILE}"
    info "=== D√©marrage de la sauvegarde GLPI ===" >>"${LOGFILE}"
    # V√©rification pr√©liminaire
    if [ -z "${REP_GLPI}" ] || [ -z "${REP_BACKUP_COMPRESS}" ] || [ -z "${INVOKING_HOME}" ]; then
        warn "Variables d'environnement manquantes (REP_GLPI, REP_BACKUP_COMPRESS, INVOKING_HOME)" >>"${ERRORFILE}"
        return 1
    fi
    # Lecture des informations MySQL
    local DB_NAME PASSWORD
    DB_NAME=$(sed -n 's/.*\(Nom de la base de donn√©es GLPI\|GLPI database name\): \([^ ]*\).*/\2/p' "${INVOKING_HOME}/sauve_mdp.txt")
    PASSWORD=$(sed -n 's/.*\(Mot de passe root\|Root password\): \([^ ]*\).*/\2/p' "${INVOKING_HOME}/sauve_mdp.txt")
    if [ -z "${DB_NAME}" ] || [ -z "${PASSWORD}" ]; then
        warn "Impossible de lire le nom de base ou le mot de passe depuis sauve_mdp.txt" >>"${ERRORFILE}"
        return 1
    fi
    # D√©termination de l‚Äôoutil de dump
    local MYSQLDUMP_CMD
    MYSQLDUMP_CMD=$(command -v mysqldump 2>/dev/null || command -v mariadb-dump 2>/dev/null || echo mysqldump)
    # R√©pertoires de sauvegarde
    REP_BACKUP="${INVOKING_HOME}/backup_glpi_$(date +"%Y-%m-%d")"
    local BDD_BACKUP; BDD_BACKUP="bdd_glpi_$(date +"%Y-%m-%d_%H-%M-%S").sql"
    mkdir -p "${REP_BACKUP}"
    # --- Sauvegarde BDD ---
    info "${MSG_MYSQL_DUMP}" >>"${LOGFILE}"
    if ${MYSQLDUMP_CMD} -u root -p"${PASSWORD}" --databases "${DB_NAME}" > "${REP_BACKUP}/${BDD_BACKUP}" 2>>"${ERRORFILE}"; then
        info "${MSG_DUMP_SUCCESS}" >>"${LOGFILE}"
    else
        warn "√âchec de la sauvegarde de la base ${DB_NAME}" >>"${ERRORFILE}"
        return 1
    fi
    # --- Sauvegarde des fichiers ---
    info "${MSG_SITE_COPY}" >>"${LOGFILE}"
    for SRC in "/etc/glpi/config" "/var/lib/glpi/files" "${REP_GLPI}/plugins" "${REP_GLPI}/marketplace" "${REP_GLPI}/inc/downstream.php"; do
        if [ -e "${SRC}" ]; then
            cp -Rf "${SRC}" "${REP_BACKUP}/" >>"${LOGFILE}" 2>>"${ERRORFILE}"
        else
            warn "Source manquante : ${SRC}" >>"${ERRORFILE}"
        fi
    done
    info "${MSG_SITE_COPY_OK}" >>"${LOGFILE}"
    # --- Compression ---
    info "${MSG_COMPRESS_BACKUP}" >>"${LOGFILE}"
    mkdir -p "${REP_BACKUP_COMPRESS}"
    local BACKUP_FILE; BACKUP_FILE="${REP_BACKUP_COMPRESS}/backup_glpi_$(date +"%Y-%m-%d_%H-%M-%S").tar.gz"
    if tar -czf "${BACKUP_FILE}" -C "${REP_BACKUP}" . 2>>"${ERRORFILE}"; then
        info "${MSG_COMPRESS_BACKUP_OK} (${BACKUP_FILE})" >>"${LOGFILE}"
        # V√©rifier que le fichier compress√© n'est pas vide
        if [ ! -s "${BACKUP_FILE}" ]; then
            warn "Fichier de sauvegarde vide, suppression annul√©e." >>"${ERRORFILE}"
            return 1
        fi
        # Suppression s√©curis√©e de l‚Äôancien GLPI
        info "${MSG_REMOVE_OLD_GLPI_DIR}"
        if [ -n "${REP_GLPI}" ] && [ -d "${REP_GLPI}" ]; then
            rm -rf "${REP_GLPI:?}/"
            info "R√©pertoire ${REP_GLPI} supprim√©." >>"${LOGFILE}"
        else
            warn "R√©pertoire GLPI introuvable : ${REP_GLPI}" >>"${ERRORFILE}"
        fi
    else
        warn "${MSG_COMPRESS_BACKUP_FAILED}" >>"${ERRORFILE}"
        return 1
    fi
    info "=== Sauvegarde GLPI termin√©e avec succ√®s ===" >>"${LOGFILE}"
    sleep 2
    export REP_BACKUP
    echo "$(date '+%F %T') [$$][DEBUG:backup_glpi] Fin de la fonction" >> "${LOGFILE}"
}
# Mise √† jour de GLPI
function update_glpi() {
    echo "$(date '+%F %T') [$$][DEBUG:update_glpi] Entr√©e dans la fonction" >> "${LOGFILE}"
    info "=== D√©but de la mise √† jour GLPI ===" 1>>"${LOGFILE}"
    # V√©rification de base
    if [ -z "${REP_BACKUP}" ] || [ -z "${REP_GLPI}" ]; then
        warn "Variables REP_BACKUP ou REP_GLPI non d√©finies, arr√™t de la mise √† jour." 1>>"${ERRORFILE}"
        return 1
    fi
    # --- √âtape 1 : restauration des dossiers ---
    for DIR in config files plugins marketplace; do
        SRC="${REP_BACKUP}/${DIR}"
        if [ -d "${SRC}" ]; then
            case "${DIR}" in
                config) DEST="/etc/glpi/config" ;;
                files) DEST="/var/lib/glpi/files" ;;
                plugins) DEST="${REP_GLPI}/plugins" ;;
                marketplace) DEST="${REP_GLPI}/marketplace" ;;
            esac
            mkdir -p "${DEST}"
            if compgen -G "${SRC}/*" > /dev/null; then
                if cp -Rf "${SRC}/"* "${DEST}/" 2>>"${ERRORFILE}"; then
                    info "Restauration de ${DIR} vers ${DEST} termin√©e." 1>>"${LOGFILE}"
                else
                    warn "Erreur lors de la copie de ${DIR}." 2>>"${ERRORFILE}"
                fi
            else
                warn "R√©pertoire ${SRC} vide, rien √† copier." 2>>"${ERRORFILE}"
            fi
        fi
    done
    # --- √âtape 2 : fichier sp√©cifique downstream.php ---
    if [ -f "${REP_BACKUP}/inc/downstream.php" ]; then
        mkdir -p "${REP_GLPI}/inc"
        if cp -Rf "${REP_BACKUP}/inc/downstream.php" "${REP_GLPI}/inc/" 2>>"${ERRORFILE}"; then
            info "Fichier downstream.php restaur√©." 1>>"${LOGFILE}"
        else
            warn "Erreur lors de la restauration de downstream.php" 2>>"${ERRORFILE}"
        fi
    fi
    # --- √âtape 3 : suppression de la sauvegarde ---
    info "${MSG_REMOVE_OLD_FILES}"
    if [ -d "${REP_BACKUP}" ]; then
        rm -rf "${REP_BACKUP:?}"
        info "R√©pertoire ${REP_BACKUP} supprim√© avec succ√®s." 1>>"${LOGFILE}"
    else
        warn "R√©pertoire ${REP_BACKUP} introuvable." 2>>"${ERRORFILE}"
    fi
    # --- √âtape 4 : mise √† jour de la base GLPI ---
    info "${MSG_UPDATE_GLPI_DATABASE}"
    rights_glpi
    if [[ "${ID}" =~ ^(debian|ubuntu)$ ]]; then
        sudo -u www-data php "${REP_GLPI}/bin/console" db:update --quiet --no-interaction --force 1>"${LOGFILE}" 2>>"${ERRORFILE}"
    elif [[ "${ID}" =~ ^(almalinux|centos|rocky|rhel)$ ]]; then
        sudo -u nginx php "${REP_GLPI}/bin/console" db:update --quiet --no-interaction --force 1>"${LOGFILE}" 2>>"${ERRORFILE}"
    fi
    if [ $? -eq 0 ]; then
        info "Mise √† jour de la base GLPI r√©ussie." 1>>"${LOGFILE}"
    else
        warn "√âchec de la mise √† jour de la base GLPI." 2>>"${ERRORFILE}"
        return 1
    fi
    # --- √âtape 5 : nettoyage final ---
    info "${MSG_UPDATE_CLEAN}"
    rm -f "${REP_GLPI}/install/install.php" 2>>"${ERRORFILE}"
    rm -rf "${REP_BACKUP}/backup_glpi" 2>>"${ERRORFILE}"

    info "=== Fin de la mise √† jour GLPI ===" 1>>"${LOGFILE}"
    sleep 2
    echo "$(date '+%F %T') [$$][DEBUG:update_glpi] Fin de la fonction" >> "${LOGFILE}"
}
# Fonction principale pour ex√©cuter les t√¢ches avec barre de progression
function update() {
    echo "$(date '+%F %T') [$$][DEBUG:update] Entr√©e dans la fonction" >> "${LOGFILE}"
    declare -A tasks=(
        ["$MSG_T20"]="maintenance 1"
        ["$MSG_T21"]="update_distro"
        ["$MSG_T22"]="backup_glpi"
        ["$MSG_T23"]="install_glpi"
        ["$MSG_T24"]="update_glpi"
        ["$MSG_T25"]="maintenance 0"
    )
    task_order=("$MSG_T20" "$MSG_T21" "$MSG_T22" "$MSG_T23" "$MSG_T24" "$MSG_T25")
    total_tasks=${#task_order[@]}
    task_index=0
    (
        for task_key in "${task_order[@]}"; do
            task_index=$((task_index + 1))
            progress=$((task_index * 100 / total_tasks))
            echo "$progress"
            echo "XXX"
            echo "$task_index/$total_tasks - $task_key"
            echo "XXX"
            if run_task "$task_key" "${tasks[$task_key]}" "$task_index" "$total_tasks"; then
                echo "$progress"
                echo "XXX"
                echo "$task_index/$total_tasks - $task_key : ${MSG_OK}"
                echo "XXX"
            else
                echo "100"
                echo "XXX"
                echo "$task_index/$total_tasks - $task_key : ${MSG_NONOK}"
                echo "XXX"
                exit 1   # <-- remonte l'erreur au parent
            fi
            sleep 0.5
        done
    ) | dialog --backtitle "$MSG_TITRE" --title "$MSG_TITRE_GAUGE" --gauge "" 8 120
    # R√©cup√©rer le code de retour du sous-shell
    if [ ${PIPESTATUS[0]} -ne 0 ]; then
        warn "Une t√¢che a √©chou√© pendant l'ex√©cution de update()." >>"${ERRORFILE}"
        return 1
    fi
    info "Toutes les t√¢ches ont √©t√© ex√©cut√©es avec succ√®s." >>"${LOGFILE}"
    echo "$(date '+%F %T') [$$][DEBUG:update] Fin de la fonction" >> "${LOGFILE}"
}
