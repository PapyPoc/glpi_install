#!/usr/bin/env bash
#
# GLPI install script
# Author: PapyPoc
# Version: 1.9.0
# Function file
#
# set -Eeuo pipefail
# Ne pas continuer si le script est exécuté directement

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo -e "Ce fichier doit être sourcé, pas exécuté.\n" >&2
    echo -e "This file must be sourced, not executed.\n" >&2
    exit 1
fi
# Affichage d'erreur en rouge
function error(){
    local msg="$1"
    export_display_env
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    #echo -e "${ROUGE}${expanded}${NC}" # Couleur rouge # Affichage à l'écran désactivé
    printf '%s\n' "${expanded}" | tee -a "${ERRORFILE}" >/dev/null
}
# Affichage d'alerte en orange
function warn(){
    local msg="$1"
    export_display_env
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    # echo -e "${ORANGE}${expanded}${NC}" # Couleur orange # Affichage à l'écran désactivé
    printf '%s\n' "${expanded}" | tee -a "${ERRORFILE}" >/dev/null # Affichage dans le fichier d'alerte
}
# Affichage d'information en bleu
function info(){
    local msg="$1"
    export_display_env
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    # echo -e "${CYAN}${expanded}${NC}" # Couleur cyan # Affichage à l'écran désactivé
    printf '%s\n' "${expanded}" | tee -a "${INFOFILE}" >/dev/null # Affichage dans le fichier d'info
}
# Affichage debug en normal
function debug(){
    local msg="$1"
    export_display_env
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    # echo -e "${NC}${expanded}${NC}" # Couleur normale Affichage à l'écran désactivé
    printf '%s\n' "${expanded}" | tee -a "${DEBUGFILE}" >/dev/null # Affichage dans le fichier de debug
}
# Exporter une liste blanche de variables utilisées dans les fichiers de langue pour que envsubst puisse les remplacer
function export_display_env() {
    # Exporter un ensemble complet de variables (majuscules et minuscules)
    # pouvant être référencées comme espaces réservés dans les fichiers de langue.
    # Les valeurs par défaut sont vides si elles ne sont pas définies.
    local vars_maj=(
        ORIG_USER ADMIN_GROUP ID VERSION_ID ID NAME PRETTY_NAME ICON_KO NEW_VERSION REP_GLPI FICHIER_MSG
        ERRORFILE LOGFILE TASK_INDEX TASK_KEY LANGUAGE TIMEZONE IPADRESS INTERFACE DOWNLOADLINK MODE
        DB_USER DB_NAME SQLROOTPWD SQLGLPIPWD ADMINGLPIPWD POSTGLPIPWD TECHGLPIPWD NORMGLPIPWD GLPI_CLI_VERSION
        REP_BACKUP BDD_BACKUP REP_SCRIPT MYSQL_CMD MYSQLDUMP_CMD OUTPUT PHPVERSION DISTRO_ID VERSION_ID
        DEBIAN_VERSIONS UBUNTU_VERSIONS ALMA_VERSIONS CENTOS_VERSIONS ROCKY_VERSIONS REDHAT_VERSIONS MSG_UPGRADE_DISTRO
        NEW_VERSION TAGS VERSION_SELECT TASK_CMD DISTRO_ID VERSION_ID WEB_USER LANG_FILE
        ICON_WARN ICON_INFO ICON_ERROR ICON_DEBUG MSG_ERROR_ON_ERROR_1 MSG_ERROR_ON_ERROR_2 MSG_ERROR_ON_ERROR_3
        MSG_ERROR_ON_ERROR_4 MSG_ERROR_ON_ERROR_5 MSG_ERROR_DIALOG_TITLE MSG_ERROR_DIALOG_ERROR MSG_CHECK_DISTRO_OK
        MSG_CHECK_DISTRO_NONOK MSG_CHECK_DISTRO_FORCE MSG_CHECK_DISTRO_FORCE_QUESTION MSG_CHECK_DISTRO_CONTINUING
        MSG_CHECK_DISTRO_EXITING MSG_CHECK_DISTRO_INVALID MSG_LANG_FILE MSG_LANG_NOT_FOUND MSG_DEBUG_START MSG_DEBUG_END
        INTERFACE INVOKING_HOME REP_BACKUP_COMPRESS API_URL PATHS_TO_CHECK MSG_SCRIPT_NON_INTERACTIVE_DISTRO
    )
    local vars_min=(
        orig_user admin_group id version_id id name pretty_name ICON_KO new_version rep_glpi fichier_msg
        errorfile logfile task_index task_key language timezone ipadress interface downloadlink mode
        db_user db_name sqlrootpwd sqlglpipwd adminglpipwd postglpipwd techglpipwd normglpipwd glpi_cli_version
        rep_backup bdd_backup rep_script mysql_cmd mysqldump_cmd output phpversion distro_id version_id
        debian_versions ubuntu_versions alma_versions centos_versions rocky_versions redhat_versions msg_upgrade_distro
        new_version tags version_select task_cmd distro_id version_id web_user lang_file
        icon_warn icon_info icon_error icon_debug msg_error_on_error_1 msg_error_on_error_2 msg_error_on_error_3
        msg_error_on_error_4 msg_error_on_error_5 msg_error_dialog_title msg_error_dialog_error msg_check_distro_ok
        msg_check_distro_nonok msg_check_distro_force msg_check_distro_force_question msg_check_distro_continuing
        msg_check_distro_exiting msg_check_distro_invalid msg_lang_file msg_lang_not_found msg_debug_start msg_debug_end
        interface invoking_home rep_backup_compress api_url paths_to_check msg_script_non_interactive_distro
    )
    local v _val
    for v in "${vars_maj[@]}" "${vars_min[@]}"; do
        _val="${!v:-}"
        export "$v"="$_val"
    done
}
# Gestion des erreurs avec trap
function on_error() {
    local rc=$?
    local cmd=$BASH_COMMAND
    local line=${BASH_LINENO[0]}
    local message="${MSG_ERROR_ON_ERROR_1}'${cmd}' (code=$rc)${MSG_ERROR_ON_ERROR_2}$line\n"
    message+="${MSG_ERROR_ON_ERROR_3}\n"
    for ((i=${#FUNCNAME[@]}-1; i>=0; i--)); do
        message+="${MSG_ERROR_ON_ERROR_4}${FUNCNAME[$i]}()${MSG_ERROR_ON_ERROR_5}${BASH_SOURCE[$i]}:${BASH_LINENO[$((i-1))]}\n"
    done
    message+="──────────────────────────────"
    dialog --backtitle "${MSG_ERROR_DIALOG_TITLE}" \
           --title "${MSG_ERROR_DIALOG_ERROR}" \
           --msgbox "$message" 60 100 || true
    error "${ICON_ERROR} $message"
    exit "$rc"
}
# Vérifie si la version est compatible
function compatible() {
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Depuis ${FUNCNAME[1]:-main}"
    local version="$1"
    local -n versions_array="$2"
    [[ ${versions_array[*]} =~ ${version} ]]
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Fin de ${FUNCNAME[1]:-main}"
}
# Vérifie si la distribution est prise en compte pour l'installation de GLPI
function check_distro(){
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Depuis ${FUNCNAME[1]:-main}"
    # Vérifie si le fichier os-release existe
    source_os_release
    # Vérifie si la distribution est basée sur Debian, Ubuntu, Alma Linux, Centos ou Rocky Linux
    if [[ "${ID}" =~ ^(debian|ubuntu|almalinux|centos|rocky|rhel)$ ]]; then
        if [[ "$ID" == "debian" || "$ID" == "ubuntu" ]]; then
            WEB_USER="www-data"
        else
            WEB_USER="nginx"
        fi
        if compatible "${VERSION_ID}" DEBIAN_VERSIONS || compatible "$VERSION_ID" UBUNTU_VERSIONS || compatible "$VERSION_ID" ALMA_VERSIONS || compatible "$VERSION_ID" CENTOS_VERSIONS || compatible "$VERSION_ID" ROCKY_VERSIONS || compatible "$VERSION_ID" REDHAT_VERSIONS; then
            info "${ICON_INFO} ${MSG_CHECK_DISTRO_OK}"
        else
            warn "${ICON_WARN} ${MSG_CHECK_DISTRO_NONOK}"
            warn "${ICON_WARN} ${MSG_CHECK_DISTRO_FORCE}"
            if [ -t 0 ]; then
                info "${ICON_INFO} ${MSG_CHECK_DISTRO_FORCE_QUESTION}"
                read -r RESPONSE
                case $RESPONSE in
                    O|o|Y|y)
                        info "${ICON_INFO} ${MSG_CHECK_DISTRO_CONTINUING}"
                        ;;
                    N|n)
                        info "${ICON_INFO} ${MSG_CHECK_DISTRO_EXITING}"
                        return 1
                        ;;
                    *)
                        warn "${ICON_WARN} ${MSG_CHECK_DISTRO_INVALID_ANSWER}"
                        return 1
                        ;;
                esac
            else
                warn "${ICON_WARN} ${MSG_SCRIPT_NON_INTERACTIVE_DISTRO}"
                return 1
            fi
        fi
        export VERSION_ID ID WEB_USER
    else
        warn "${ICON_WARN} ${MSG_CHECK_DISTRO_INVALID}"
        return 1
    fi
    export VERSION_ID ID WEB_USER
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Depuis ${FUNCNAME[1]:-main}"
}
# Chargement du fichier de langue
function load_language() {
    debug "DEBUG : $(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Depuis ${FUNCNAME[1]:-main}"
    local syslang="${LC_ALL:-${LANG:-}}"
    if [[ $syslang =~ ^fr ]]; then
        LANG_FILE="$REP_SCRIPT/lang/fr_lang.ini"
        LANGUAGE="fr_FR"
    else
        LANG_FILE="$REP_SCRIPT/lang/en_lang.ini"
        LANGUAGE="en_US"
    fi
    if [[ -f $LANG_FILE ]]; then
        # Ensure environment variables used in messages are exported for envsubst
        export_display_env
    # Lire le fichier ligne par ligne, gérer CRLF, commentaires, sections
    # et valeurs entre guillemets
        while IFS= read -r line || [ -n "$line" ]; do
            # supprimer CR si présent (fichiers format Windows)
            line="${line%%$'\r'}"
            # skip empty lines and comments
            # supprimer les espaces de tête
            trimmed="${line#"${line%%[![:space:]]*}"}"
            if [ -z "$trimmed" ]; then
                continue
            fi
            case "$trimmed" in
                "#"* | ";"*)
                    continue
                    ;;
            esac
            # ignorer les entêtes de section
            [[ $line =~ ^[[:space:]]*\[.*\] ]] && continue
            if [[ $line =~ ^[[:space:]]*([^=[:space:]]+)[[:space:]]*=(.*)$ ]]; then
                local key="${BASH_REMATCH[1]}"
                local value="${BASH_REMATCH[2]}"
                # trim leading/trailing whitespace from value
                value="${value#"${value%%[![:space:]]*}"}"
                value="${value%"${value##*[![:space:]]}"}"
                # remove surrounding single or double quotes if present
                if [[ $value =~ ^\'(.*)\'$ ]]; then
                    value="${BASH_REMATCH[1]}"
                elif [[ $value =~ ^\"(.*)\"$ ]]; then
                    value="${BASH_REMATCH[1]}"
                fi
                # Développer les espaces réservés dans la valeur avec envsubst
                # (préféré) ou utiliser eval en secours
                local expanded_value
                if command -v envsubst >/dev/null 2>&1; then
                    # envsubst reads from the environment, so ensure variables are exported
                    expanded_value=$( ( set +u; printf '%s' "$value" | envsubst ) )
                else
                    # fallback : effectuer l'expansion de paramètres en toute sécurité
                    # (autoriser les variables non définies)
                    expanded_value=$( ( set +u; eval "printf '%s' \"$value\"" ) )
                fi
                # affecter en toute sécurité à une variable nommée par $key
                printf -v "$key" '%s' "$expanded_value"
            fi
        done < "$LANG_FILE"
        info "${ICON_INFO} ${MSG_LANG_FILE}"
    else
        warn "${ICON_WARN} ($MSG_LANG_NOT_FOUND)"
    fi
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Fin de ${FUNCNAME[1]:-main}"
}
# Recherche si GLPI est déjà installé
function check_glpi_installed(){
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    FIND_REP_GLPI=$?
    glpi_dirs=()
    # Parcours des répertoires standards à explorer
    for path in ${PATHS_TO_CHECK}; do
        # Recherche des dossiers contenant "glpi" jusqu’à 3 niveaux de profondeur
        FOUND=$(find "${path}" -maxdepth 3 -type d -name "*glpi*" 2>/dev/null)
        # Si le répertoire correspond à FIND_REP_GLPI, on enregistre FIND_REP_GLPI et sort de la boucle
        if [[ "${FOUND}" == "${FIND_REP_GLPI}" ]]; then
            FIND_REP_GLPI="${FOUND}"
            break
        fi
        # Si un ou plusieurs répertoires sont trouvés, on les ajoute au tableau
        if [[ -n "$FOUND" ]]; then
            # On lit chaque ligne de la sortie de find et on l’ajoute au tableau
            while IFS= read -r dir; do
                glpi_dirs+=("$dir")
            done <<< "$FOUND"
        fi
    done
    export glpi_dirs FIND_REP_GLPI
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
} 
# Vérifie l'utilisateur web pour le répertoire GLPI
function check_install_user(){
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    info "${MSG_CHECK_WEB_USER}"
    REP_GLPI="${1:-/var/www/html/glpi}"
    if ! WEB_USER=$(stat -c '%U' "${REP_GLPI}") >/dev/null 2>&1; then
        debug "${ICON_DEBUG} ${MSG_WEB_USER_NOT_FOUND} ${REP_GLPI}."
        return 1
    fi
    debug "${ICON_DEBUG} ${MSG_WEB_USER_FOUND} ${WEB_USER}"
    export WEB_USER REP_GLPI
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Choix entre installation ou mise à jour
function install_update(){
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    # Demander à l'utilisateur s'il souhaite installer ou mettre à jour GLPI
    exec 3>&1
    INSTALL_OR_UPDATE=$(dialog \
        --backtitle "$MSG_INSTALL_UPDATE_BACK_TITLE" \
        --title "${MSG_INSTALL_UPDATE_TITRE}" \
        --radiolist "${MSG_INSTALL_UPDATE_RADIOLIST}" 10 50 2 \
        1 "${MSG_INSTALL_UPDATE_INSTALL}" ON \
        2 "${MSG_INSTALL_UPDATE_UPDATE}" OFF \
        3>&1 1>&2 2>&3)
    rc=$?
    exec 3>&-
    if [[ $rc -ne 0 ]]; then
        error "${ICON_ERROR} ${MSG_INSTALL_UPGRADE_CANCELLED}"
        exec 3>&1
        dialog --title "${MSG_DIALOG_TITLE_CANCEL}" --msgbox "${MSG_INSTALL_UPGRADE_CANCELLED}" 7 50
        exec 3>&-
        return 1
    fi
    export INSTALL_OR_UPDATE
    info "Choix de l'utilisateur : $INSTALL_OR_UPDATE"
    prompt_install_options
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
#  Demander à l'utilisateur de choisir le répertoire d'installation,
# la version de GLPI à installer ou de lancer une installation complète via dialog.
function prompt_install_options(){
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    info "Choix de l'utilisateur : $INSTALL_OR_UPDATE"
    # Recherche des installations GLPI existantes
    if [[ "${INSTALL_OR_UPDATE}" == 2 ]]; then
        check_glpi_installed
        # Si au moins un répertoire GLPI trouvé, demander à l'utilisateur de choisir
        if [[ "${#glpi_dirs[@]}" -gt 0 ]]; then
            # Préparer les arguments pour dialog
            find_rep=()
            rep_map=()
            number=1
            first="ON"
            # Correction : boucle while → for (syntaxe correcte)
            for dir in "${glpi_dirs[@]}"; do
                find_rep+=("${number}" "${dir}" "${first}")
                rep_map+=("${dir}")
                first="OFF"
                ((number++))
            done
            # Vérification utilisateur/distro avant exécution
            if check_install_user "${REP_GLPI}"; then
                GLPI_CLI_VERSION=$(sudo -u "${WEB_USER}" php "${REP_GLPI}/bin/console" --no-ansi --version 2>/dev/null | awk '{print $3}' || true)
            fi
            # Récupération des versions GLPI disponibles sur GitHub
            tags=""
            # Récupère les tags au format X.Y.Z
            tags=$(curl -s "${API_URL}" | jq -r '.[].name' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | grep -v -E '(rc|beta|alpha)' | uniq | head -n 16) 
            # Filtrage : ne garder que les versions avant GLPI_CLI_VERSION (donc plus récentes) ---
            newer_tags=()
            for tag in ${tags}; do
                if [[ "${tag}" == "${GLPI_CLI_VERSION}" ]]; then
                    break  # On s'arrête dès qu'on atteint la version installée
                fi
                newer_tags+=("${tag}")
            done
            # Préparation du menu de sélection de version GLPI
            tag=""; find_version=(); version_map=(); number=1; first="ON"
            for tag in "${newer_tags[@]}"; do
                find_version+=("" "GLPI ${tag}" "${first}")
                version_map+=("${tag}")
                first="OFF"
                ((number++))
            done
            # Menu de sélection d’installation GLPI
            exec 3>&1
            FIND_REP_GLPI=$(dialog \
                --backtitle "$MSG_PROMPT_INSTALL_OPTIONS_BACKTITLE_UPDATE" \
                --title "${MSG_PROMPT_INSTALL_OPTIONS_DIR_TITLE_UPDATE}" \
                --radiolist "${MSG_PROMPT_INSTALL_OPTIONS_DIR_RADIOLIST_UPDATE}" 20 70 8 \
                "${find_rep[@]}" \
                3>&1 1>&2 2>&3)
            rc=$?
            exec 3>&-
            # Convertir le numéro choisi en index du tableau (0-based)
            local index=""
            index=$((FIND_REP_GLPI - 1))
            # Récupérer le vrai chemin correspondant
            REP_GLPI="${rep_map[$index]}"
            if [[ $rc -ne 0 ]]; then
                warn "${ICON_WARN} Sélection du répertoire d'installation GLPI annulée par l'utilisateur." | tee -a "${DEBUGFILE}"
                dialog --title "Annulation" --msgbox "Installation annulée par l'utilisateur." 7 50
                return 1
            fi
            # Sélecteur de version GLPI
            exec 3>&1
            VERSION_SELECT=$(dialog \
                --backtitle "$MSG_PROMPT_INSTALL_OPTIONS_BACKTITLE_UPDATE" \
                --title "${MSG_PROMPT_INSTALL_OPTIONS_VERSION_TITLE_UPDATE}" \
                --radiolist "${MSG_PROMPT_INSTALL_OPTIONS_VERSION_RADIOLIST_UPDATE}" 23 50 8 \
                "${find_version[@]}" \
                3>&1 1>&2 2>&3)
            rc=$?
            exec 3>&-
            if [[ "${rc}" -ne 0 ]]; then
                warn "${ICON_WARN} Sélection de la version annulée."
                return 1
            fi
            # Convertir le numéro choisi en index du tableau (0-based)
            local index=""
            index=$((VERSION_SELECT - 1))
            # Récupérer le vrai tag correspondant
            VERSION_SELECT="${version_map[$index]}"
            dialog --title "${MSG_INFO}" --msgbox "${MSG_PROMPT_INSTALL_OPTIONS_VERSION_MSG_UPDATE}" 10 100
            export DOWNLOADLINK="https://github.com/glpi-project/glpi/releases/download/${VERSION_SELECT}/glpi-${VERSION_SELECT}.tgz"
            export VERSION_SELECT REP_GLPI DOWNLOADLINK REP_BACKUP_COMPRESS INVOKING_HOME GLPI_CLI_VERSION
            # Lancement de la mise à jour
            run_sequence "update"
        fi
    elif [[ "${INSTALL_OR_UPDATE}" == 1 ]]; then
        tags=""
        # Récupère les tags au format X.Y.Z
        tags=$(curl -s "${API_URL}" | jq -r '.[].name' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | grep -v -E '(rc|beta|alpha)' | uniq | head -n 16) 
        local args=() first=ON number=1 version_map=()
        while IFS= read -r tag; do
            args+=("" "GLPI ${tag}" "${first}")
            version_map+=("${tag}")
            first=OFF
            number=$((number + 1))
        done <<< "${tags}"
        exec 3>&1
        VERSION_SELECT=$(dialog --backtitle "$MSG_PROMPT_INSTALL_OPTIONS_BACKTITLE_INSTALL" --title "${MSG_PROMPT_INSTALL_OPTIONS_VERSION_TITLE_INSTALL}" \
        --radiolist "${MSG_PROMPT_INSTALL_OPTIONS_VERSION_RADIOLIST_INSTALL}" 23 50 8 "${args[@]}" 3>&1 1>&2 2>&3)
        local rc=$?
        exec 3>&-
        if [ "${rc}" -ne 0 ]; then
            warn "${ICON_WARN} ${MSG_PROMPT_INSTALL_OPTIONS_ABORT_INSTALL}"
            return 1
        fi
        # VERSION_SELECT retourne le tag choisi (ici nous utilisons des tags numériques mapping -> version_map)
        if ! [[ "${VERSION_SELECT}" =~ ^[0-9]+$ ]]; then
            warn "${ICON_WARN} ${MSG_PROMPT_INSTALL_OPTIONS_VERSION_INVALID} ${VERSION_SELECT}"
            return 1
        fi
        # Convertir le numéro choisi en index du tableau (0-based)
        local index=""
        index=$((VERSION_SELECT - 1))
        # Récupérer le vrai tag correspondant
        VERSION_SELECT="${version_map[$index]}"
        if [ $index -lt 0 ] || [ $index -ge ${#version_map[@]} ]; then
            warn "${ICON_WARN} ${MSG_PROMPT_INSTALL_OPTIONS_VERSION_OUT_OF_RANGE} ${index}"
            return 1
        fi
        WIDTH_REP=$(( ${#MSG_PROMPT_INSTALL_OPTIONS_PARAM_REP} ))
        WIDTH_DB_HOST=$(( ${#MSG_PROMPT_INSTALL_OPTIONS_PARAM_DB_HOST} ))
        WIDTH_DB_NAME=$(( ${#MSG_PROMPT_INSTALL_OPTIONS_PARAM_DB_NAME} ))
        WIDTH_DB_USER=$(( ${#MSG_PROMPT_INSTALL_OPTIONS_PARAM_DB_USER} ))
        WIDTH=$(( WIDTH_REP > WIDTH_DB_HOST ? WIDTH_REP : WIDTH_DB_HOST ))
        WIDTH=$(( WIDTH > WIDTH_DB_NAME ? WIDTH : WIDTH_DB_NAME ))
        WIDTH=$(( WIDTH > WIDTH_DB_USER ? WIDTH : WIDTH_DB_USER ))
        WIDTH=$(( WIDTH + 6 ))
        local _def_rep="" rep_glpi="" _def_db_host="" db_host="" _def_db_name="" db_name="" _def_db_user="" db_user=""
        local _def_db_host="${DB_HOST:-localhost}" _def_db="${DB_NAME:-glpi}" _def_user="${DB_USER:-glpi_user}"
        while true; do
            exec 3>&1
            form=$(dialog --backtitle "$MSG_PROMPT_INSTALL_OPTIONS_BACKTITLE_INSTALL" --title "$MSG_PROMPT_INSTALL_OPTIONS_VERSION_TITLE_INSTALL" \
                --form "${MSG_PROMPT_INSTALL_OPTIONS_VERSION_TITLE_PARAM_1} ${VERSION_SELECT} ${MSG_PROMPT_INSTALL_OPTIONS_VERSION_TITLE_PARAM_2}" 18 68 8 \
                "📁 ${MSG_PROMPT_INSTALL_OPTIONS_PARAM_REP}"     1 2 "${_def_rep}"     1 ${WIDTH} 20 40 \
                "🖥️ ${MSG_PROMPT_INSTALL_OPTIONS_PARAM_DB_HOST}" 3 2 "${_def_db_host}" 3 ${WIDTH} 20 20 \
                "🗄️ ${MSG_PROMPT_INSTALL_OPTIONS_PARAM_DB_NAME}" 5 2 "${_def_db}"      5 ${WIDTH} 20 20 \
                "👤 ${MSG_PROMPT_INSTALL_OPTIONS_PARAM_DB_USER}" 7 2 "${_def_user}"    7 ${WIDTH} 20 20 \
                2>&1 1>&3)
            rc=$?
            exec 3>&-
            # Transformer les lignes du formulaire en variables
            IFS=$'\n' read -r rep_glpi db_host db_name db_user <<< "$form"
            rep_glpi="${rep_glpi#"${rep_glpi%%[![:space:]]*}"}"; rep_glpi="${rep_glpi%"${rep_glpi##*[![:space:]]}"}"
            db_host="${db_host#"${db_host%%[![:space:]]*}"}"; db_host="${db_host%"${db_host##*[![:space:]]}"}"
            db_name="${db_name#"${db_name%%[![:space:]]*}"}"; db_name="${db_name%"${db_name##*[![:space:]]}"}"
            db_user="${db_user#"${db_user%%[![:space:]]*}"}"; db_user="${db_user%"${db_user##*[![:space:]]}"}"
            rep_glpi="${rep_glpi//[^A-Za-z0-9_\/.-]/_}"
            db_host="${db_host//[^A-Za-z0-9_\/.-]/_}"
            db_name="${db_name//[^A-Za-z0-9_]/_}"
            db_user="${db_user//[^A-Za-z0-9_]/_}"
            [ -z "$rep_glpi" ] && rep_glpi="$_def_rep"
            [ -z "$db_host" ] && db_host="$_def_db_host"
            [ -z "$db_name" ] && db_name="$_def_db"
            [ -z "$db_user" ] && db_user="$_def_user"
            if [[ ! "$db_name" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
                db_name="glpi_${db_name}"
            fi
            rep_glpi="${rep_glpi//\\//}"
            if [ -z "${rep_glpi}" ] || [[ "${rep_glpi}" != /* ]]; then
                rep_glpi="${_def_rep}"
            fi
            rep_glpi="$(printf '%s' "${rep_glpi}" | sed -E 's#/{2,}#/#g')"
            REP_GLPI="${rep_glpi%/}/"
            DB_HOST="$db_host"
            DB_NAME="$db_name"
            DB_USER="$db_user"
            # Si annulation ou ESC
            if [[ $rc -ne 0 ]]; then
                warn "${ICON_WARN} ${MSG_PROMPT_INSTALL_OPTIONS_ABORT_INSTALL}"
                dialog --title "${MSG_PROMPT_INSTALL_OPTIONS_BACKTITLE_INSTALL}" --msgbox "${MSG_PROMPT_INSTALL_OPTIONS_ABORT_INSTALL}" 7 60
                exit 1
            fi
            # --- VALIDATIONS ---
            # Répertoire d’installation
            if ! validate_glpi_path "$REP_GLPI"; then
                continue
            fi
            # Hôte de la base de données
            if ! validate_db_host "$DB_HOST"; then
                continue
            fi
            # Nom de la base de données
            if ! validate_db_name "$DB_NAME"; then
                continue
            fi
            # Utilisateur de la base de données
            if ! validate_db_user "$DB_USER"; then
                continue
            fi
            # Si tout est valide
            break
        done
        # Assignation des valeurs finales
        local DOWNLOADLINK="https://github.com/glpi-project/glpi/releases/download/${VERSION_SELECT}/glpi-${VERSION_SELECT}.tgz"
        local DB_HOST="${DB_HOST}"
        local REP_GLPI="${REP_GLPI}"
        local DB_NAME="${DB_NAME}"
        local DB_USER="${DB_USER}"
        local INVOKING_HOME="${PWD}"
        local TIMEZONE="${TIMEZONE:-UTC}"
        local VERSION_SELECT="${VERSION_SELECT}"
        export DOWNLOADLINK DB_HOST REP_GLPI DB_NAME DB_USER INVOKING_HOME TIMEZONE
        # Lancement de l’installation
        run_sequence "install"
    fi
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Valide le répertoire d’installation de GLPI
function validate_glpi_path() {
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    local path="$1"
    local clean_path
    # Nettoyage
    clean_path="$(printf '%s' "$path" | tr -d '\r\n' | sed -E 's#/{2,}#/#g' \
        | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    # Vérification du format
    if ! [[ "$clean_path" =~ ^(/var/www|/srv|/opt|/usr/share)/[^[:space:]]*glpi[^[:space:]]*$ ]]; then
        dialog --title "${MSG_VALIDATE_GLPI_PATH_DIALOG_TITLE}" --msgbox "${MSG_VALIDATE_GLPI_PATH_DIALOG_FAILED_1} ${clean_path}${MSG_VALIDATE_GLPI_PATH_DIALOG_FAILED_2}" 12 70
        warn "${ICON_WARN} ${MSG_VALIDATE_GLPI_PATH_FAILED} (${clean_path})"
        return 1
    fi
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Valide le répertoire d’installation de GLPI
function validate_db_host() {
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    host=$1
    # 1️⃣ Nettoyage de base
    clean_host=$(printf '%s' "$host" \
        | tr -d '\r' \
        | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
    # 2️⃣ Cas simples
    case "$clean_host" in
        localhost|::1|\[::1\])
            return 0 ;;
    esac
    # 3️⃣ Vérif IPv4 (structure correcte)
    if printf '%s\n' "$clean_host" | grep -Eq '^([0-9]{1,3}\.){3}[0-9]{1,3}$'; then
        IFS=.
        set -- $clean_host
        for o in "$@"; do
            case $o in
                *[!0-9]*) dbhost_err "$clean_host"; return 1 ;;
            esac
            [ "$o" -ge 0 ] 2>/dev/null && [ "$o" -le 255 ] 2>/dev/null || {
                dbhost_err "$clean_host"; return 1;
            }
        done
        return 0
    fi
    # 4️⃣ Vérif nom de domaine (FQDN simple)
    if printf '%s\n' "$clean_host" | grep -Eq '^([A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?\.)+[A-Za-z]{2,}$'; then
        return 0
    fi
    # 5️⃣ Sinon invalide
    dbhost_err "$clean_host"
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Helper message d'erreur + log
function dbhost_err() {
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    v=$1
    dialog --title "${MSG_VALIDATE_DB_HOST_DIALOG_TITLE}" --msgbox "${MSG_VALIDATE_DB_HOST_DIALOG_FAILED_1} ${v}${MSG_VALIDATE_DB_HOST_DIALOG_FAILED_2}" 10 70
    warn "${ICON_WARN} ${MSG_VALIDATE_DB_HOST_FAILED} (${v})"
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Valide le nom de la base de données
function validate_db_name() {
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    local name="$1"
    local clean_name
    clean_name="$(printf '%s' "$name" | tr -d '\r\n' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    # Vérifier si la base de données est déjà utiliser dans les fichiers de sauvegarde
    if find "${INVOKING_HOME}" -name "${FICHIER_MSG}${clean_name}*" -print -quit | grep -q .; then
        dialog --title --msgbox "${MSG_VALIDATE_DB_NAME_DIALOG_FAILED_1} ${clean_name}${MSG_VALIDATE_DB_NAME_DIALOG_FAILED_2}" 12 70
        warn "${ICON_WARN} ${MSG_VALIDATE_DB_NAME_FAILED_1} (${clean_name})"
        return 1
    fi
    if [[ ! "$clean_name" =~ ^[A-Za-z_][A-Za-z0-9_]{0,63}$ ]]; then
        dialog --msgbox "${MSG_VALIDATE_DB_NAME_DIALOG_FAILED_3} ${clean_name}${MSG_VALIDATE_DB_NAME_DIALOG_FAILED_4}" 12 70
        warn "${ICON_WARN} ${MSG_VALIDATE_DB_NAME_FAILED_2} (${clean_name})"
        return 1
    fi
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Valide le nom d’utilisateur de la base de données
function validate_db_user() {
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    local user="$1"
    local clean_user
    clean_user="$(printf '%s' "$user" | tr -d '\r\n' \
        | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    if [[ "$clean_user" == "root" || ! "$clean_user" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
        dialog --msgbox "${ICON_WARN} ${MSG_VALIDATE_DB_USER_DIALOG_FAILED}" 12 70
        warn "${ICON_WARN} ${MSG_VALIDATE_DB_USER_FAILED} (${clean_user})"
        debug "${ICON_DEBUG} ${ICON_KO} ${MSG_DEBUG_END}"
        return 1
    fi
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Sequence principale d'installation et de mise à jour de GLPI
function run_sequence() {
    local mode="$1"
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    trap 'on_error' ERR
    declare -A tasks
    local task_order=()
    # --- Sélection du mode ---
    case "${mode}" in
        install)
            tasks=(
                ["${MSG_T01}"]="update_distro"
                ["${MSG_T02}"]="install_packages"
                ["${MSG_T03}"]="network_info"
                ["${MSG_T04}"]="mariadb_configure"
                ["${MSG_T05}"]="download_untar_glpi"
                ["${MSG_T06}"]="setup_glpi"
                ["${MSG_T07}"]="maj_user_glpi"
                ["${MSG_T08}"]="write_credentials"
            )
            task_order=(
                "${MSG_T01}" "${MSG_T02}" "${MSG_T03}" "${MSG_T04}" "${MSG_T05}" "${MSG_T06}" "${MSG_T07}" "${MSG_T08}"
            )
            ;;
        update)
            tasks=(
                ["${MSG_T20}"]="maintenance 1"
                ["${MSG_T21}"]="update_distro"
                ["${MSG_T22}"]="backup_glpi"
                ["${MSG_T23}"]="download_untar_glpi"
                ["${MSG_T24}"]="update_glpi"
                ["${MSG_T25}"]="maintenance 0"
            )
            task_order=(
                "${MSG_T20}" "${MSG_T21}" "${MSG_T22}" "${MSG_T23}" "${MSG_T24}" "${MSG_T25}"
            )
            ;;
        *)
            warn "${ICON_WARN} ${MSG_RUN_SEQUENCE_UNKNOWN_MODE}"
            return 1
            ;;
    esac
    # --- Initialisation ---
    local total_tasks=${#task_order[@]}
    local task_index=0
    (
        for task_key in "${task_order[@]}"; do
            ((task_index++))
            local progress=$((task_index * 100 / total_tasks))
            local task_cmd="${tasks[${task_key}]}"
            # --- Affichage dans la jauge ---
            echo "${progress}"
            echo "XXX"
            echo "${task_index}/${total_tasks} - ${task_key} ${ICON_INPROGRESS}"
            echo "XXX"
            debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG] ${ICON_OK} ${MSG_RUN_SEQUENCE_START} '${task_key}' → ${task_cmd}"
            # --- Exécution de la tâche ---
            if run_task "${task_key}" "${task_cmd}" "${task_index}" "${total_tasks}"; then
                echo "${progress}"
                echo "XXX"
                echo "${task_index}/${total_tasks} - ${task_key} ${ICON_VALIDATE}"
                echo "XXX"
                debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG] ${ICON_VALIDATE} ${MSG_RUN_SEQUENCE_END} '${task_key}'."
                sleep 0.5  # légère pause visuelle
            else
                echo "100"
                echo "XXX"
                echo "${task_index}/${total_tasks} - ${task_key} ${ICON_KO}"
                echo "XXX"
                debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG] ${ICON_KO} ${MSG_RUN_SEQUENCE_END} '${task_key}'."
                sleep 5
                return 1
            fi
        done
    ) | dialog --clear \
               --backtitle "$MSG_TITRE" \
               --title "$MSG_TITRE_GAUGE" \
               --gauge "" 8 120
    # --- Vérification du sous-shell ---
    if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
        warn "${ICON_WARN} ${MSG_RUN_SEQUENCE_FAILED_MODE}"
        debug "${ICON_DEBUG} ${MSG_DEBUG_END} (${ICON_KO})"
        return 1
    fi
    info "${ICON_INFO} ${MSG_RUN_SEQUENCE_END}"
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Exécute une tâche individuelle
function run_task() {
    local task_key="$1" task_cmd="$2" index="$3" total="$4"
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    info "${ICON_INFO} ${MSG_RUN_TASK_TASK} ${index}/${total} : ${task_key} — ${MSG_RUN_TASK_COMMAND} : ${task_cmd}"
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG] ${MSG_RUN_TASK_COMMAND} ${task_cmd}"
    # Exécution isolée
    local output exit_code
    output=$(eval "${task_cmd}" 2>&1)
    exit_code=$?
    if (( exit_code == 0 )); then
        debug "${ICON_DEBUG} ${output}"
        debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG] ✅ ${task_key} ${MSG_RUN_TASK_SUCCESS_END}"
    else
        warn "${ICON_WARN} ${task_key} ${MSG_RUN_TASK_FAILED_END} (exit=${exit_code})"
        [[ -n "${output}" ]] && warn "↳ ${output}"
        debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG] ❌ ${task_key} — ${MSG_RUN_TASK_FAILED} '${task_cmd}'"
        return ${exit_code}
    fi
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG] ${MSG_TASK_END} ${FUNCNAME[0]} → ${task_key}"
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
    return 0
}
# Mise à jour de la distribution
function update_distro(){
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    if [[ "${ID}" =~ ^(debian|ubuntu)$ ]]; then
           info "${ICON_INFO} ${MSG_UPDATE_DISTRO_START}"
           timedatectl set-ntp true # Synchronise l'heure
           sleep 5
           apt-get update && apt-get upgrade -y >> "${UPDATEFILE}" 2>> "${ERRORFILE}"
    elif [[ "${ID}" =~ ^(almalinux|centos|rocky|rhel)$ ]]; then
           info "${ICON_INFO} ${MSG_UPDATE_DISTRO_START}"
           chronyc makestep # Synchronise l'heure
           sleep 5
           yum update -y && yum upgrade -y >> "${UPDATEFILE}" 2>> "${ERRORFILE}"
    else
        warn "${ICON_WARN} ${MSG_UPDATE_DISTRO_NOT_SUPPORTED}"
        exit 1
    fi
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Adresse IP de la machine
function network_info() {
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    # Détection de l’interface principale (hors loopback et interfaces virtuelles)
    INTERFACE=$(ip route get 1.1.1.1 2>/dev/null | awk '/dev/ {print $5; exit}')
    if [[ -z "${INTERFACE}" ]]; then
        INTERFACE=$(ip -o link show | awk -F': ' '!/lo|docker|vir|veth/ {print $2; exit}')
    fi
    # Récupération de l’adresse IP associée
    IPADRESS=$(ip -4 addr show "${INTERFACE}" 2>/dev/null | awk '/inet / {print $2}' | cut -d'/' -f1 | head -n1)
    # Vérification et export
    if [[ -n "${IPADRESS}" ]]; then
        # Adresse IP valide trouvée
        info "${ICON_INFO} ${MSG_NETWORK_INFO_INTERFACE} ${INTERFACE}, ${MSG_NETWORK_INFO_IP} : ${IPADRESS}"
        export IPADRESS
    else
        # Aucune adresse IP valide trouvée
        warn "${ICON_WARN} ${MSG_NETWORK_INFO_IP_NOT_FOUND}"
        IPADRESS="127.0.0.1"
        export IPADRESS
    fi
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Installation des éléments nécessaire
function install_packages(){
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    info "${ICON_INFO} ${MSG_INSTALL_PACKAGES_START}"
    source_os_release
    if [[ "${ID:-}" =~ ^(debian|ubuntu)$ ]]; then
        export DEBIAN_FRONTEND=noninteractive
        # update cache first
        debug "$(date '+%Y-%m-%d %H:%M:%S'): DEBUG: apt-get update"
        if command -v apt-get update >> "${UPDATEFILE}" 2>/dev/null; then
            debug "$(date '+%Y-%m-%d %H:%M:%S'): DEBUG: apt-get upgrade -y"
            if ! apt-get upgrade -y >> "${UPDATEFILE}" 2>/dev/null; then
                warn "${ICON_WARN} ${MSG_INSTALL_PACKAGES_UPGRADE_FAILED}"
            fi
        fi
        info "${ICON_INFO} ${MSG_INSTALL_PHP_EXTENSIONS_START}"
        if ! sudo apt-get install -y php-{bcmath,mysql,mbstring,curl,gd,xml,intl,ldap,apcu,opcache,xmlrpc,zip,bz2} \
            | sudo tee -a "${UPDATEFILE}" 2> >(sudo tee -a "${ERRORFILE}" >&2)
            info "${ICON_INFO} ${MSG_INSTALL_PHP_EXTENSIONS_COMPLETED}"
        then
            error "${ICON_ERROR} ${MSG_INSTALL_PHP_EXTENSIONS_FAILED}"
            return 1
        fi
        info "${ICON_INFO} ${MSG_INSTALL_SERVICES_START}"
        if ! sudo apt-get install -y wget tar apache2 apache2-bin mariadb-server mariadb-client perl php \
            | sudo tee -a "${UPDATEFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2)
            info "${ICON_INFO} ${MSG_INSTALL_SERVICES_COMPLETED}"
        then
            error "${ICON_ERROR} ${MSG_INSTALL_SERVICES_FAILED}"
            return 1
        fi
        manage_service "mariadb" "MariaDB" || return 1
        manage_service "apache2" "Apache2" || return 1
    elif [[ "${ID:-}" =~ ^(almalinux|centos|rocky|rhel|fedora)$ ]]; then
        dnf makecache --refresh
        if ! command -v dnf >/dev/null 2>&1; then
            error "${ICON_ERROR} ${MSG_INSTALL_PACKAGES_DNF_NOT_FOUND}" | tee -a "${ERRORFILE}"
            return 1
        fi
        if dnf makecache --refresh \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "${ICON_INFO} ${MSG_INSTALL_PACKAGES_DNF_CACHE_REFRESHED}"
        else
            error "${ICON_ERROR} ${MSG_INSTALL_PACKAGES_DNF_CACHE_REFRESHED_FAILED}"
        fi
        if dnf install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm \
        | sudo tee -a "${DEBUGFILE}" \
        2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "${ICON_OK} ${MSG_INSTALL_PACKAGES_EPEL}"
        else
            error "${ICON_ERR} ${MSG_INSTALL_PACKAGES_EPEL_FAILED}"
            return 1
        fi
        if dnf module reset -y php nginx mariadb composer \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "${ICON_OK} ${MSG_INSTALL_PACKAGES_MODULES_RESET}"
        else
            error "${ICON_ERROR} ${MSG_INSTALL_PACKAGES_MODULES_RESET_FAILED}"
            return 1
        fi
        if dnf module install -y php:8.2 \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "${ICON_OK} ${MSG_INSTALL_PACKAGES_PHP}"
        else
            error "${ICON_ERROR} ${MSG_INSTALL_PACKAGES_PHP_FAILED}"
            return 1
        fi
        if dnf module install -y nginx:1.24 \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "${ICON_OK} ${MSG_INSTALL_PACKAGES_NGINX}"
        else
            error "${ICON_ERROR} ${MSG_INSTALL_PACKAGES_NGINX_FAILED}"
            return 1
        fi
        if dnf module install -y mariadb:10.11 \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "${ICON_OK} ${MSG_INSTALL_PACKAGES_MARIADB}"
        else
            error "${ICON_ERROR} ${MSG_INSTALL_PACKAGES_MARIADB_FAILED}"
            return 1
        fi
        if dnf install dnf-automatic -y \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "${ICON_OK} ${MSG_INSTALL_PACKAGES_AUTO_UPDATES}"
        else
            error "${ICON_ERROR} ${MSG_INSTALL_PACKAGES_AUTO_UPDATES_FAILED}"
            return 1
        fi
        if {
            sed -i 's/^\s*;\?\s*\(apply_updates\s*=\s*\).*/\1yes/' /etc/dnf/automatic.conf
            sed -i 's/^\s*;\?\s*\(reboot\s*=\s*\).*/\1when-needed/' /etc/dnf/automatic.conf
            sed -i 's/^\s*;\?\s*\(upgrade_type\s*=\s*\).*/\1security/' /etc/dnf/automatic.conf
        } >>"${DEBUGFILE}" 2>>"${ERRORFILE}"; then
            info "${ICON_OK} ${MSG_INSTALL_PACKAGES_DNF_AUTO_CONFIG}"
        else
            error "${ICON_ERR} ${MSG_INSTALL_PACKAGES_DNF_AUTO_CONFIG_FAILED}"
            return 1
        fi
        if mkdir /etc/systemd/system/dnf-automatic.timer.d \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "${ICON_OK} ${MSG_INSTALL_PACKAGES_DNF_AUTO_DIR}"
        else
            warn "${ICON_WARN} ${MSG_INSTALL_PACKAGES_DNF_AUTO_DIR_FAILED}"
            return 1
        fi
        content="
[Unit]
    Description=dnf-automatic timer
    ConditionPathExists=!/run/ostree-booted
    Wants=network-online.target

[Timer]
    OnCalendar=*-*-* 6:00
    RandomizedDelaySec=60m
    Persistent=true"
echo "$content" | 
        if sudo tee /etc/systemd/system/dnf-automatic.timer.d/override.conf 1>>"${DEBUGFILE}" 2>>"${ERRORFILE}"; then
            info "${ICON_OK} ${MSG_INSTALL_PACKAGES_DNF_AUTO_OVERRIDE}"
        else
            echo "${ICON_WARN} ${MSG_INSTALL_PACKAGES_DNF_AUTO_OVERRIDE_FAILED}"
            return 1
        fi
        if systemctl enable --now dnf-automatic.timer; then
            info "${ICON_INFO} ${MSG_INSTALL_PACKAGES_DNF_AUTO_ACTIVATED}"
        else
            warn "${ICON_WARN} ${MSG_INSTALL_PACKAGES_DNF_AUTO_ACTIVATED_FAILED}"
            return 1
        fi
        info "${ICON_INFO} ${MSG_INSTALL_PACKAGES_INSTALL_EXT_PHP}"
        if ! dnf install -y php-{bcmath,mysql,mbstring,curl,gd,xml,intl,ldap,apcu,opcache,xmlrpc,zip,bz2}; then
            warn "${ICON_WARN} ${MSG_INSTALL_PACKAGES_PHP_EXT_FAILED}"
            return 1
        fi
        info "${ICON_INFO} ${MSG_INSTALL_PACKAGES_INSTALL_SERVICE_LAMP}"
        if ! dnf install -y crontabs logrotate cronie tar nginx mariadb-server mariadb perl curl jq php epel-release; then
            warn "${ICON_WARN} ${MSG_INSTALL_PACKAGES_INSTALL_SERVICES_FAILED}"
            return 1
        fi
        sed -i 's/^\(;\?\)\(user =\).*/\2 nginx/' /etc/php-fpm.d/www.conf
        sed -i 's/^\(;\?\)\(group =\).*/\2 nginx/' /etc/php-fpm.d/www.conf
        if systemctl enable --now mariadb nginx php-fpm; then
            info "${ICON_INFO} ${MSG_INSTALL_PACKAGES_SERVICES_STARTED}"
        else
            warn "${ICON_WARN} ${MSG_INSTALL_PACKAGES_SERVICES_START_WEB_FAILED}"
            return 1
        fi
        if firewall-cmd --permanent --zone=public --add-service=http && firewall-cmd --reload; then
            info "${ICON_INFO} ${MSG_INSTALL_PACKAGES_FIREWALL_OK}"
        else
            warn "${ICON_WARN} ${MSG_INSTALL_PACKAGES_FIREWALL_FAILED}"
            return 1
        fi
    fi
    info "${ICON_INFO} ${MSG_INSTALL_PACKAGES_END}"
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
function manage_service() {
    local service="$1"
    local label="$2"
    info "${ICON_INFO} ${MSG_MANAGE_SERVICE_START} ${label}..."
    {
        systemctl enable "${service}"
        systemctl restart "${service}"
    } >>"${DEBUGFILE}" 2>>"${ERRORFILE}" || {
        error "${ICON_ERROR} ${MSG_MANAGE_SERVICE_FAILED} ${label}."
        return 1
    }
    info "${ICON_INFO} ${MSG_MANAGE_SERVICE_INFO} ${label}."
}
function get_timezone() {
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    # Détection du fuseau horaire
    info "${ICON_INFO} ${MSG_DETECT_TIMEZONE:-Détection du fuseau horaire...}"
    if [ -z "${TIMEZONES:-}" ]; then
        local tzfile=""
        if command -v timedatectl >/dev/null 2>&1; then
            TIMEZONES=$(timedatectl show -p Timezone --value 2>/dev/null || true)
        fi
        if [ -z "${TIMEZONES:-}" ] && [ -f /etc/timezone ]; then
            TIMEZONES=$(head -n 1 /etc/timezone 2>/dev/null || true)
        fi
        if [ -z "${TIMEZONES:-}" ]; then
            if [ -L /etc/localtime ] || [ -f /etc/localtime ]; then
                tzfile=$(readlink -f /etc/localtime 2>/dev/null || true)
                if [[ "$tzfile" == *"/usr/share/zoneinfo/"* ]]; then
                    TIMEZONES="${tzfile#*/usr/share/zoneinfo/}"
                fi
            fi
        fi
        if [ -z "${TIMEZONES:-}" ] && [ -f /etc/sysconfig/clock ]; then
            TIMEZONES=$(awk -F= '/^ZONE/ {gsub(/"/,"",$2); print $2}' /etc/sysconfig/clock 2>/dev/null || true)
        fi
        TIMEZONES="${TIMEZONE:-UTC}"
        export TIMEZONES
        info "${ICON_OK} ${MSG_GET_TIMEZONE_DETECTED} ${TIMEZONES}"
    fi
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Configuration de la base de données MariaDB
function mariadb_configure() {
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    # Détecter la commande MySQL/MariaDB
    info "${ICON_INFO} ${MSG_MARIADB_CONFIGURE_BDD_CONFIG}"
    MYSQL_CMD=$(command -v mysql || command -v mariadb || echo mysql)
    if [ -z "${MYSQL_CMD}" ]; then
        error "${ICON_ERROR} ${MSG_MARIADB_CONFIGURE_COMMAND_NOT_FOUND}"
        return 1
    fi
    get_timezone
    debug "${ICON_DEBUG} Utilisation de la commande : ${MYSQL_CMD}" # Pour le débogage
    debug "${ICON_DEBUG} Configuration de la base de données MariaDB/MySQL" # Pour le débogage
    debug "${ICON_DEBUG} Connexion à l'hôte de la base de données : ${DB_HOST}" # Pour le débogage
    debug "${ICON_DEBUG} Modification du mot de passe de l'utilisateur root de la base de données : ${SQLROOTPWD}" # Pour le débogage
    debug "${ICON_DEBUG} Création de la base de données : ${DB_NAME}" # Pour le débogage
    debug "${ICON_DEBUG} Création de l'utilisateur de la base de données : ${DB_USER} avec mot de passe ${SQLGLPIPWD}" # Pour le débogage
    debug "${ICON_DEBUG} Attribution des privilèges à l'utilisateur de la base de données" # Pour le débogage
    debug "${ICON_DEBUG} Configuration du fuseau horaire de la base de données : ${TIMEZONES}" # Pour le débogage
    local _sql_root
    _sql_root=$(
    cat <<-SQL
ALTER USER 'root'@'localhost' IDENTIFIED BY '${SQLROOTPWD}';
DELETE FROM mysql.user WHERE User='';
DELETE FROM mysql.user WHERE User='root' AND Host!='localhost';
DROP DATABASE IF EXISTS test;
DELETE FROM mysql.db WHERE Db='test' OR Db LIKE 'test_%';
GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION;
CREATE DATABASE IF NOT EXISTS ${DB_NAME};
CREATE USER IF NOT EXISTS '${DB_USER}'@'localhost' IDENTIFIED BY '${SQLGLPIPWD}';
GRANT ALL PRIVILEGES ON ${DB_NAME}.* TO '${DB_USER}'@'localhost';
SQL
)
    # --- Application des commandes SQL ---
    if PAGER=cat MYSQL_PWD="${SQLROOTPWD}" "${MYSQL_CMD}" -u root --batch --silent -e "${_sql_root}" mysql; then
        info "${ICON_INFO} ${MSG_MARIADB_CONFIGURE_SQL_CMD_OK}"
    else
        warn "${ICON_WARN} ${MSG_MARIADB_CONFIGURE_SQL_CMD_ERROR}"
        return 1
    fi
    # --- Vérification et import des fuseaux horaires (si nécessaire) ---
    local TIMEZONE_TABLE_COUNT
    TIMEZONE_TABLE_COUNT=$(
        MYSQL_PWD="${SQLROOTPWD}" "${MYSQL_CMD}" -u root --silent \
            -e "SELECT COUNT(*) FROM mysql.time_zone_name WHERE name = '${TIMEZONES}';" mysql 2>/dev/null
    )
    if [ "${TIMEZONE_TABLE_COUNT}" -eq 0 ]; then
        info "${ICON_INFO} ${MSG_MARIADB_CONFIGURE_TIMEZONE_IMPORT}"
        # --- Construction sécurisée du script SQL ---
        local _sql_root
        _sql_root=$(
        cat <<-SQL
-- Configuration du fuseau horaire
SET GLOBAL time_zone = '${TIMEZONES}';
SET time_zone = '${TIMEZONES}';
-- Droits sur les tables timezone
GRANT SELECT ON mysql.time_zone_transition TO '${DB_USER}'@'localhost';
GRANT SELECT ON mysql.time_zone_transition_type TO '${DB_USER}'@'localhost';
GRANT SELECT ON mysql.time_zone TO '${DB_USER}'@'localhost';
GRANT SELECT ON mysql.time_zone_name TO '${DB_USER}'@'localhost';
FLUSH PRIVILEGES;
SQL
)
        # --- Application des commandes SQL ---
        if PAGER=cat MYSQL_PWD="${SQLROOTPWD}" "${MYSQL_CMD}" -u root --batch --silent -e "${_sql_root}" mysql; then
            info "${ICON_INFO} ${MSG_MARIADB_CONFIGURE_SQL_CMD_OK}"
        else
            warn "${ICON_WARN} ${MSG_MARIADB_CONFIGURE_SQL_CMD_ERROR}"
            return 1
        fi
    else
        info "${ICON_INFO} ${MSG_MARIADB_CONFIGURE_TIMEZONE_ALREADY_LOADED}"
    fi
    # --- Import des informations de fuseaux horaires ---
    #info "${ICON_INFO} ${MSG_MARIADB_CONFIGURE_TIMEZONE_IMPORT}"
    #if mysql_tzinfo_to_sql /usr/share/zoneinfo 2>/dev/null | PAGER=cat MYSQL_PWD="${SQLROOTPWD}" "${MYSQL_CMD}" -u root mysql; then
    #    info "${ICON_INFO} ${MSG_MARIADB_CONFIGURE_TIMEZONE_IMPORT_OK}"
    #else
    #    warn "${ICON_WARN} ${MSG_INSTALL_CONFIG_TIMEZONE_ERROR}"
    #    return 1
    #fi
    # --- Redémarrage du service ---
    if systemctl is-active --quiet mariadb; then
        info "${ICON_RUN} ${MSG_MARIADB_CONFIGURE_SERVICE_RESTART}"
        if systemctl restart mariadb >>"${DEBUGFILE}" 2>>"${ERRORFILE}"; then
            info "${ICON_OK} ${MSG_MARIADB_CONFIGURE_SERVICE_RESTART_OK}"
        else
            warn "${ICON_WARN} ${MSG_MARIADB_CONFIGURE_SERVICE_RESTART_FAILED}"
        fi
    else
        warn "${ICON_WARN} ${MSG_MARIADB_CONFIGURE_SERVICES_START}"
        if systemctl start mariadb >>"${DEBUGFILE}" 2>>"${ERRORFILE}"; then
            info "${ICON_OK} ${MSG_MARIADB_CONFIGURE_SERVICES_START_OK}"
        else
            error "${ICON_ERR} ${MSG_MARIADB_CONFIGURE_SERVICES_START_FAILED}"
            return 1
        fi
    fi
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Téléchargement et décompression de GLPI
function download_untar_glpi(){
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    info "${ICON_INFO} ${MSG_DOWNLOAD_UNTAR_GLPI_START}"
    # Téléchargement de GLPI
    tmp_file="$(mktemp /tmp/glpi_XXX.tar.gz)"
    debug "${ICON_DEBUG} ${MSG_DOWNLOAD_UNTAR_GLPI_DOWNLOAD} ${DOWNLOADLINK} ${MSG_DOWNLOAD_UNTAR_GLPI_DOWNLOAD_TOWARDS} ${tmp_file}"
    if wget -q -O "$tmp_file" "${DOWNLOADLINK}" 1>> "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
        info "${ICON_INFO} ${MSG_DOWNLOAD_UNTAR_GLPI_DOWNLOAD_COMPLETED}"
    else
        warn "${ICON_WARN} ${MSG_DOWNLOAD_UNTAR_GLPI_FAILED}" 1>> "${ERRORFILE}"
        rm -f "$tmp_file"
        return 1
    fi
    if [ -d "$REP_GLPI" ]; then
        mkdir -p "$REP_GLPI"
        info "${ICON_INFO} ${MSG_DOWNLOAD_UNTAR_GLPI_DIR_CREATE} ${REP_GLPI}"
    else
        warn "${ICON_WARN} ${MSG_DOWNLOAD_UNTAR_GLPI_DIR_CREATE_FAILED}"
        rm -f "$tmp_file"
        return 1
    fi
    # Extraire l'archive dans le répertoire d'installation
    if tar xzf "$tmp_file" --strip-components=1 -C "$REP_GLPI"; then
        info "${ICON_INFO} ${MSG_DOWNLOAD_UNTAR_GLPI_EXTRACT_OK} ${REP_GLPI}"
        
    else
        warn "${ICON_WARN} ${MSG_DOWNLOAD_UNTAR_GLPI_EXTRACT_FAILED}"
        rm -f "$tmp_file"
        return 1
    fi
    rm -f "$tmp_file"
    sleep 5 # Pause pour s'assurer que les fichiers sont bien écrits
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Mise en place des réglage pour GLPI
function setup_glpi(){
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    info "${ICON_INFO} ${MSG_SETUP_GLPI_START}"
    source_os_release
    local CMD=(
    php "${REP_GLPI}/bin/console" db:install
    --db-host localhost
    --db-port=3306
    --db-name="${DB_NAME}"
    --db-user="${DB_USER}"
    --db-password="${SQLGLPIPWD}"
    --default-language="${LANGUAGE}"
    --force
    --no-telemetry
    --quiet
    --no-interaction
    )
    info "${ICON_INFO} ${MSG_SETUP_GLPI_DIR_LOGS}${DB_NAME}"
    mkdir -p /var/log/"${DB_NAME}" || 
    {
        warn "${ICON_WARN} ${MSG_SETUP_GLPI_DIR_LOGS_FAILED}${DB_NAME}."
        return 1
    }
    info "${ICON_INFO} ${MSG_SETUP_GLPI_DIR_CONFIG}"
    mkdir -p /etc/"${DB_NAME}"/config || 
    {
        warn "${ICON_WARN} ${MSG_SETUP_GLPI_DIR_CONFIG_FAILED}"
        return 1
    }
    info "${ICON_INFO} ${MSG_SETUP_GLPI_DIR_FILES}"
    mkdir -p "/var/lib/${DB_NAME}/files" || 
    {
        warn "${ICON_WARN} ${MSG_SETUP_GLPI_DIR_FILES_FAILED}${DB_NAME}."
        return 1
    }
    info "${ICON_INFO} ${MSG_SETUP_GLPI_MOVE_FILES}"
    mv -f "${REP_GLPI}"/files /var/lib/"${DB_NAME}"/files ||
    {
        warn "${ICON_WARN} ${MSG_SETUP_GLPI_MOVE_FILES_FAILED}"
        return 1
    }
    info "${ICON_INFO} ${MSG_SETUP_GLPI_CREATE_LOCAL_DEFINE}"
    if sudo tee /etc/"${DB_NAME}"/config/local_define.php >/dev/null <<EOF
<?php
    define('GLPI_VAR_DIR', '/var/lib/${DB_NAME}/files');
    define('GLPI_LOG_DIR', '/var/log/${DB_NAME}');
EOF
    then
        info "${ICON_INFO} ${MSG_SETUP_GLPI_CREATE_LOCAL_DEFINE_OK}"
    else
        warn "${ICON_WARN} ${MSG_SETUP_GLPI_CREATE_LOCAL_DEFINE_FAILED}"
        return 1
    fi
    info "${ICON_INFO} ${MSG_SETUP_GLPI_CREATE_DOWNSTREAM}"
    if sudo tee "${REP_GLPI}"/inc/downstream.php >/dev/null <<EOF
<?php
    define('GLPI_CONFIG_DIR', '/etc/${DB_NAME}/config');
    if (file_exists(GLPI_CONFIG_DIR . '/local_define.php')) {
        require_once GLPI_CONFIG_DIR . '/local_define.php';
    }
EOF
    then
        info "${ICON_INFO} ${MSG_SETUP_GLPI_CREATE_DOWNSTREAM_OK}"
    else
        warn "${ICON_WARN} ${MSG_SETUP_GLPI_CREATE_DOWNSTREAM_FAILED}"
        return 1
    fi
    info "${ICON_INFO} ${MSG_SETUP_GLPI_RIGHTS_MODIFY}"
    if rights_glpi "${REP_GLPI}"; then
        info "${ICON_INFO} ${MSG_SETUP_GLPI_RIGHTS_MODIFY_OK}"
    else
        warn "${ICON_WARN} ${MSG_SETUP_GLPI_RIGHTS_MODIFY_FAILED}"
        return 1
    fi
    info "${ICON_INFO} ${MSG_SETUP_GLPI_WEB_SERVER_CONFIG} ${REP_GLPI}"
    if check_install_user "${REP_GLPI}"; then
        info "${ICON_INFO} ${MSG_SETUP_GLPI_WEB_USER_DETECTED} ${WEB_USER}"
        if [[ "${WEB_USER}" == "www-data" ]]; then
            network_info
            debug "${ICON_DEBUG} ${MSG_SETUP_GLPI_WEB_SERVER_CONFIG_APACHE} ${WEB_USER}" # Pour le débogage
            # Configuration d'Apache pour GLPI
            info "${ICON_INFO} ${MSG_SETUP_GLPI_WEB_SERVER_CONFIG_VIRTUAL_HOST}"
            if tee /etc/apache2/sites-available/glpi.conf <<EOF > /dev/null
<VirtualHost *:80>
    ServerName ${IPADRESS}
    DocumentRoot ${REP_GLPI}/public
    <Directory ${REP_GLPI}/public>
        Require all granted
        RewriteEngine On
        RewriteCond %{HTTP:Authorization} ^(.+)$
        RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
        RewriteCond %{REQUEST_FILENAME} !-f
        RewriteRule ^(.*)$ index.php [QSA,L]
    </Directory>
    ErrorLog /var/log/glpi/error.log
    CustomLog /var/log/glpi/access.log combined
</VirtualHost>
EOF
            then
                echo "${ICON_OK} ${MSG_SETUP_GLPI_WEB_SERVER_CONFIG_VIRTUAL_HOST_OK}"
            else
                erreur "${MSG_ERROR} ${MSG_SETUP_GLPI_WEB_SERVER_CONFIG_VIRTUAL_HOST_FAILED}"
                return 1
            fi
            phpversion=$(php -v | grep -i '(cli)' | awk '{print $2}' | cut -d. -f1,2)
            sed -i 's/^\(;\?\)\(session.cookie_httponly\).*/\2 =on/' /etc/php/"$phpversion"/apache2/php.ini
            # Disable Apache Web Server Signature
            echo "ServerSignature Off" >> /etc/apache2/apache2.conf
            echo "ServerTokens Prod" >> /etc/apache2/apache2.conf
            # Activation du module rewrite d'apache
            if ! a2enmod rewrite | tee -a "${DEBUGFILE}"; then
                warn "${ICON_WARN} ${MSG_SETUP_GLPI_PHP_REWRITE_FAILED}"
                return 1
            fi
            # Déactiver le site par défaut
            if ! a2dissite 000-default.conf | tee -a "${DEBUGFILE}"; then
                warn "${ICON_WARN} ${MSG_SETUP_GLPI_APACHE_DEFAULT_SITE_DISABLED_FAILED}"
                return 1
            fi
            # Activer le site GLPI
            if ! a2ensite glpi.conf | tee -a "${DEBUGFILE}"; then
                warn "${ICON_WARN} ${MSG_SETUP_GLPI_APACHE_DEFAULT_SITE_ENABLED_FAILED}"
                return 1
            fi
            # Recharger la configuration d'Apache
            if ! systemctl reload apache2 | tee -a "${DEBUGFILE}"; then
                warn "${ICON_WARN} ${MSG_SETUP_GLPI_APACHE_RELOAD_FAILED}"
                return 1
            fi
            # Installation de GLPI en ligne de commande
            debug "${ICON_DEBUG} $(date '+%Y-%m-%d %H:%M:%S') - [INFO] Exécution : sudo -u ${WEB_USER} php ${CMD[*]}"
            # Exécuter la commande en tant que "${WEB_USER}". Utiliser sudo tee pour écrire vers les fichiers protégés.
            if sudo -u "${WEB_USER}" "${CMD[@]}" | tee -a "${DEBUGFILE}" 2>>"${ERRORFILE}"; then
                info "${ICON_INFO} ${MSG_SETUP_GLPI_COMPLETED}"
            else
                warn "${ICON_WARN} ${MSG_SETUP_GLPI_INSTALLATION_FAILED}"
                return 1
            fi
            # Change permissions
            if ! rights_glpi "${REP_GLPI}"; then
                warn "${ICON_WARN} ${MSG_SETUP_GLPI_RIGHTS_MODIFY_FAILED}"
                return 1
            fi
            manage_service "apache2" "Apache2" || return 1
        fi
    elif [[ "${WEB_USER}" == "nginx" ]]; then
        network_info
        info "${ICON_INFO} ${MSG_SETUP_GLPI_WEB_SERVER_CONFIG_NGINX} ${WEB_USER}"
        # Configuration de Nginx pour GLPI
        info "${ICON_INFO} ${MSG_SETUP_GLPI_WEB_SERVER_CONFIG_NGINX_VIRTUAL_HOST}"
        sudo tee /etc/nginx/conf.d/glpi.conf << EOF
server {
listen 80;
server_name ${IPADRESS};
root ${REP_GLPI}public;
location / {
    try_files \$uri /index.php\$is_args\$args;
}
location ~ ^/index\.php$ {
    # the following line needs to be adapted, as it changes depending on OS distributions and PHP versions
    fastcgi_pass unix:/var/run/php-fpm/www.sock;
    fastcgi_split_path_info ^(.+\.php)(/.*)$;
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;
}
}
EOF
        info "${ICON_INFO} ${MSG_SETUP_GLPI_CREATE_LOGROTATE}"
        # Configuration de logrotate pour GLPI
        sudo tee /etc/logrotate.d/glpi << EOF
# Rotate GLPI logs daily, only if not empty
# Save 14 days old logs under compressed mode
/var/lib/glpi/files/_log/*.log {
su nginx nginx
daily
rotate 14
compress
notifempty
missingok
create 644 nginx nginx
}
EOF
        chmod 0644 /etc/logrotate.d/glpi
        chown root:root /etc/logrotate.d/glpi
        chcon system_u:object_r:etc_t:s0 /etc/logrotate.d/glpi
        sed -i 's/^\(;\?\)\(session.cookie_httponly\).*/\2 = on/' /etc/php.ini
        info "${ICON_INFO} ${MSG_SETUP_GLPI_CREATE_LOGROTATE_OK}"
        # Change permissions
        if rights_glpi "${REP_GLPI}"; then
            info "${ICON_INFO} ${MSG_SETUP_GLPI_RIGHTS_MODIFY}"
        else
            warn "${ICON_WARN} ${MSG_SETUP_GLPI_RIGHTS_MODIFY_FAILED}"
            return 1
        fi
        # Recharger la configuration de Nginx
        if ! systemctl reload nginx php-fpm; then
            warn "${ICON_WARN} ${MSG_SETUP_GLPI_WEB_SERVER_CONFIG_NGINX_RELOAD_FAILED}"
            return 1
        fi
        # Installation de GLPI en ligne de commande
        if sudo -u "${WEB_USER}" "${CMD[@]}" 1>>"${DEBUGFILE}" 2>>"${ERRORFILE}"; then
            info "${ICON_INFO} ${MSG_SETUP_GLPI_COMPLETED}"
        else
            warn "${ICON_WARN} ${MSG_SETUP_GLPI_INSTALLATION_FAILED}"
            return 1
        fi
        # Configuration de la tâche Cron
        info "${ICON_INFO} ${MSG_SETUP_GLPI_CRON_CONFIG}"
        echo "*/2 * * * * ${WEB_USER} /usr/bin/php ""${REP_GLPI}""front/cron.php &>/dev/null" >> /etc/cron.d/glpi
    fi
    sleep 5
    info "${ICON_INFO} ${MSG_SETUP_GLPI_REMOVE_INSTALL_FILE}"
    if rm -Rf "${REP_GLPI}install/install.php"; then
        info "${ICON_INFO} ${MSG_SETUP_GLPI_REMOVE_INSTALL_FILE_OK}"
    else
        warn "${ICON_WARN} ${MSG_SETUP_GLPI_REMOVE_INSTALL_FILE_FAILED}"
        return 1
    fi
    sleep 2
    info "${ICON_INFO} ${MSG_SETUP_GLPI_COMPLETED}"
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Mise à jour des mot de passe des utilisateurs de GLPI
function maj_user_glpi(){
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    info "${ICON_INFO}  ${MSG_MAJ_USER_GLPI_START}"
    # Ensure we have a mysql client command; fallback to detecting it if not set
    network_info
    get_timezone
    local MYSQL_CMD
    MYSQL_CMD=$(command -v mysql  || command -v mariadb || echo mysql)
    # Verify mysql client exists
    if ! command -v "${MYSQL_CMD}"; then
        warn "${MSG_MARIADB_CONFIGURE_COMMAND_NOT_FOUND} ${MYSQL_CMD}"
        return 1
    fi
    # --- Vérification des variables critiques ---
    if [ -z "${DB_NAME:-}" ] || [ -z "${DB_USER:-}" ] || [ -z "${SQLGLPIPWD:-}" ] || [ -z "${IPADRESS:-}" ]; then
        error "${ICON_ERROR} ${MSG_MAJ_USER_GLPI_MISSING_VARS}"
        return 1
    fi
    if [ -z "${ADMINGLPIPWD:-}" ] || [ -z "${POSTGLPIPWD:-}" ] || [ -z "${TECHGLPIPWD:-}" ] || [ -z "${NORMGLPIPWD:-}" ]; then
        error "${ICON_ERROR} ${MSG_MAJ_USER_GLPI_MISSING_PASSWORDS}"
        return 1
    fi
    # Construire la requête SQL et exécuter via -e
    local _sql_user
    debug "${ICON_DEBUG} Préparation des commandes SQL pour mettre à jour les mots de passe des utilisateurs GLPI." # Pour le débogage
    debug "${ICON_DEBUG} Base de données: ${DB_NAME}, Utilisateur: ${DB_USER}, Mot de passe SQL: ${SQLGLPIPWD}" # Pour le débogage
    debug "${ICON_DEBUG} Nouveaux mots de passe des utilisateurs GLPI:" # Pour le débogage
    debug "${ICON_DEBUG}   - glpi: ${ADMINGLPIPWD}" # Pour le débogage
    debug "${ICON_DEBUG}   - post-only: ${POSTGLPIPWD}" # Pour le débogage
    debug "${ICON_DEBUG}   - tech: ${TECHGLPIPWD}" # Pour le débogage
    debug "${ICON_DEBUG}   - normal: ${NORMGLPIPWD}" # Pour le débogage
    debug "${ICON_DEBUG} Construction des commandes SQL..." # Pour le débogage
    # --- Construction du SQL ---
    local _sql_user
    _sql_user=$(
        cat <<SQL
USE ${DB_NAME};
UPDATE glpi_users SET password = MD5('${ADMINGLPIPWD}') WHERE name = 'glpi';
UPDATE glpi_users SET password = MD5('${POSTGLPIPWD}') WHERE name = 'post-only';
UPDATE glpi_users SET password = MD5('${TECHGLPIPWD}') WHERE name = 'tech';
UPDATE glpi_users SET password = MD5('${NORMGLPIPWD}') WHERE name = 'normal';
UPDATE glpi_configs SET value = '${TIMEZONE}' WHERE context = 'core' AND name = 'timezone';
UPDATE glpi_configs SET value = '${LANGUAGE}' WHERE context = 'core' AND name = 'language';
UPDATE glpi_configs SET value = '${IPADRESS}' WHERE context = 'core' AND name = 'url_base';
SQL
    )
    # --- Exécution SQL ---
    if ! PAGER=cat MYSQL_PWD="${SQLGLPIPWD}" "${MYSQL_CMD}" -u "${DB_USER}" --batch --silent -e "${_sql_user}" 2>/dev/null; then
        error "${ICON_ERROR} ${MSG_ERROR_TASK:-Erreur} : échec de la mise à jour des utilisateurs GLPI."
        return 1
    fi
    info "${ICON_INFO}  ${MSG_MAJ_USER_GLPI_OK}"
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
function source_os_release(){
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    if [[ -f /etc/os-release ]]; then
        # shellcheck disable=SC1091
        . /etc/os-release
    fi
    if [[ -f /etc/lsb-release ]]; then
        # shellcheck disable=SC1091
        . /etc/lsb-release
    fi
    if [[ -z "${ID:-}" ]]; then
        ID=$(uname -s | tr '[:upper:]' '[:lower:]')
    fi
    if [[ -z "${VERSION_ID:-}" ]]; then
        VERSION_ID=$(uname -r)
    fi
    if [ -z "${ID:-}" ] || [ -z "${VERSION_ID:-}" ]; then
        warn "${ICON_WARN} ${MSG_SOURCE_OS_RELEASE_MISSING_VARS}"
        return 1
    fi
    export ID VERSION_ID
    info "${ICON_INFO} ${MSG_SOURCE_OS_RELEASE_INFO} ${ID} ${VERSION_ID}"
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
function rights_glpi(){
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    REP_GLPI="${1:-/var/www/html/glpi}"
    # Changer les droits des répertoires et fichiers
    info "${ICON_INFO}  ${MSG_SETUP_GLPI_RIGHTS_MODIFY}"
    find "${REP_GLPI}" -type d -exec chmod 755 {} \; 1> >(tee -a "${DEBUGFILE}") 2> >(tee -a "${ERRORFILE}" >&2)
    find "${REP_GLPI}" -type f -exec chmod 644 {} \; 1> >(tee -a "${DEBUGFILE}") 2> >(tee -a "${ERRORFILE}" >&2)
    # Changer le propriétaire des répertoires
    if check_distro ; then
        sudo chown -Rc "${WEB_USER}":"${WEB_USER}" /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}"
    fi
    # SELinux configuration
    if [[ "${WEB_USER}" == "nginx" ]]; then
        if command -v semanage; then
            setsebool -P httpd_can_network_connect on
            setsebool -P httpd_can_network_connect_db on
            setsebool -P httpd_can_sendmail on
            for p in "${REP_GLPI}" /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}/marketplace"; do
                semanage fcontext -a -t httpd_sys_rw_content_t "${p}(/.*)?"
            done
            restorecon -R "${REP_GLPI}" /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}/marketplace"
        else
            error "${ICON_ERROR} $(date '+%F %T'): WARN: semanage non disponible — SELinux non configuré"
        fi
    fi
    info "${ICON_INFO}  ${MSG_SETUP_GLPI_RIGHTS_MODIFY_OK}"
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Ecriture du fichier pour sauvegarder les mot de passe du serveur GLPI
function write_credentials(){
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    info "${ICON_INFO}  ${MSG_WRITE_CREDENTIALS_START}"
    FICHIER_MSG+="${DB_NAME}.txt"
    if [[ "${LANGUAGE}" == "fr_FR" ]]; then
        cat > "$FICHIER_MSG" << EOF
<==========================> Détails de l'installation de GLPI <=================================>
 GLPI Version: ${VERSION_SELECT}
 Répertoire d'installation de GLPI: ${REP_GLPI}

 Les comptes utilisateurs par défaut sont :
 UTILISATEUR   -  MOT DE PASSE       -       ACCES
  glpi         -  ${ADMINGLPIPWD}     -  compte admin
  post-only    -  ${POSTGLPIPWD}     -  compte post-only
  tech         -  ${TECHGLPIPWD}     -  compte tech
  normal       -  ${NORMGLPIPWD}     -  compte normal

 Vous pouvez accéder à la page web de GLPI à partir d'une adresse IP ou d'un nom d'hôte :
 http://${DB_HOST}

 ==> Base de données:
 Hôte de la base de données: ${DB_HOST}
 Port de la base de données: 3306
 Nom de la base de données GLPI: ${DB_NAME}
 Mot de passe root: ${SQLROOTPWD}
 Mot de passe ${DB_USER}: ${SQLGLPIPWD}

 Fichier de sauvegarde enregistré dans ${FICHIER_MSG}
 <===============================================================================================>

 Si vous rencontrez un probléme avec ce script, veuillez le signaler sur GitHub : https://github.com/PapyPoc/glpi_install/issues
EOF
	else
		cat > "$FICHIER_MSG" << EOF
<=============================> GLPI installation details <=====================================>
 GLPI version: ${VERSION_SELECT}
 GLPI installation directory: ${REP_GLPI}

 The default user accounts are:
    USER         -    PASSWORD        -       ACCESS
  glpi           -  ${ADMINGLPIPWD}      -  admin account
  post-only      -  ${POSTGLPIPWD}      -  post-only account
  tech           -  ${TECHGLPIPWD}      -  tech account
  normal         -  ${NORMGLPIPWD}      -  normal account

 You can access the GLPI web page from the following address :
 http://${DB_HOST}

 ==> Database:
 Database host: ${DB_HOST}
 Database port: 3306
 GLPI database name: ${DB_NAME}
 Root password: ${SQLROOTPWD}
 ${DB_USER} password: ${SQLGLPIPWD}

 Backup file saved to ${FICHIER_MSG}
 <===============================================================================================>

 If you encounter a problem with this script, please report it on GitHub : https://github.com/PapyPoc/glpi_install/issues
EOF
	fi
    info "${ICON_INFO}  ${MSG_WRITE_CREDENTIALS_END}"
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
}
# Afficher le résultat final
function display_result() {
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    info "${ICON_INFO}  ${MSG_DISPLAY_RESULT_START}"
    MESSAGE=""
	if [[ -f "${FICHIER_MSG}" ]]; then
        while IFS= read -r ligne; do
            MESSAGE+="${ligne}\n"
        done < "${FICHIER_MSG}"
        dialog --backtitle "${MSG_DISPLAY_RESULT_TITLE}" --title "${MSG_DISPLAY_RESULT_TITRE_OK}" --msgbox "${MESSAGE}" 0 0
    else
        dialog --backtitle "${MSG_DISPLAY_RESULT_TITLE}" --title "${MSG_DISPLAY_RESULT_TITRE_NONOK}" --msgbox "${ICON_KO}\n\n${MSG_ERROR_FICHIER_MSG}" 0 0
    fi
    info "${ICON_INFO}  ${MSG_DISPLAY_RESULT_END}"
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Activé ou déactivé le mode maintenance (1 ou 0)
function maintenance(){ 
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    check_install_user "${REP_GLPI}"
    if [ "$1" == "1" ]; then
        info "${ICON_INFO}  ${MSG_MAINTENANCE_ON}"
        sudo -u "${WEB_USER}" php "${REP_GLPI}"bin/console glpi:maintenance:enable 1> >(tee -a "${DEBUGFILE}") 2> >(tee -a "${ERRORFILE}" >&2)
    elif [ "$1" == "0" ]; then
        info "${ICON_INFO}  ${MSG_MAINTENANCE_OFF}"
        sudo -u "${WEB_USER}" php "${REP_GLPI}"bin/console glpi:maintenance:disable 1> >(tee -a "${DEBUGFILE}") 2> >(tee -a "${ERRORFILE}" >&2)
    fi
	sleep 2;
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Sauvegarde de la base de donnée et des fichiers de GLPI
function backup_glpi() {
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    info "${ICON_INFO} ${MSG_BACKUP_GLPI_START}"
    # Récupération du nom de la base de données dans le fichier config de GLPI suivant le répertoire de GLPI
    REP_GLPI=$(find /etc -maxdepth 1 -type f -name "glpi.conf" 2>/dev/null | head -n 1)
    # Lecture des informations MySQL
    local DB_NAME PASSWORD
    DB_NAME=$(sed -n 's/.*\(Nom de la base de données GLPI\|GLPI database name\): \([^ ]*\).*/\2/p' "${INVOKING_HOME}/sauve_mdp.txt")
    PASSWORD=$(sed -n 's/.*\(Mot de passe root\|Root password\): \([^ ]*\).*/\2/p' "${INVOKING_HOME}/sauve_mdp.txt")
    if [ -z "${DB_NAME}" ] || [ -z "${PASSWORD}" ]; then
    warn "${MSG_BACKUP_GLPI_READ_SAUVE_FAILED}"
        return 1
    fi
    # Détermination de l’outil de dump
    local MYSQLDUMP_CMD
    MYSQLDUMP_CMD=$(command -v mysqldump 2>/dev/null || command -v mariadb-dump 2>/dev/null || echo mysqldump)
    # Répertoires de sauvegarde
    REP_BACKUP="${INVOKING_HOME}/backup_glpi_$(date +"%Y-%m-%d")"
    BDD_BACKUP="bdd_glpi_$(date +"%Y-%m-%d_%H-%M-%S").sql"
    if ! mkdir -p "${REP_BACKUP}"; then
        warn "${ICON_WARN} ${MSG_BACKUP_GLPI_DIR_FAILED}"
        return 1
    fi
    # --- Export de la BDD ---
    info "${ICON_INFO} ${MSG_BACKUP_GLPI_DUMP_DB}"
    # shellcheck disable=SC2261
    if ${MYSQLDUMP_CMD} -u root -p"${PASSWORD}" --databases "${DB_NAME}" \
            > "${REP_BACKUP}/${BDD_BACKUP}" \
            >>"${DEBUGFILE}" 2>>"${ERRORFILE}"; then
        if [[ -s "${REP_BACKUP}/${BDD_BACKUP}" ]]; then
            info "${ICON_OK} ${MSG_BACKUP_GLPI_DUMP_DB_OK}"
        else
            warn "${ICON_WARN} Fichier de sauvegarde vide : ${REP_BACKUP}/${BDD_BACKUP}"
            return 1
        fi
    else
        error "${ICON_ERR} ${MSG_BACKUP_GLPI_DUMP_DB_FAILED}"
        return 1
    fi
    # --- Sauvegarde des fichiers ---
    info "${ICON_INFO} ${MSG_BACKUP_GLPI_SITE_COPY}"
    for SRC in "/etc/glpi/config" "/var/lib/glpi/files" "${REP_GLPI}/plugins" "${REP_GLPI}/marketplace" "${REP_GLPI}/inc/downstream.php"; do
        if [ -e "${SRC}" ]; then
            info "${ICON_INFO} ${MSG_BACKUP_GLPI_SITE_COPY_REP}"
            cp -Rf "${SRC}" "${REP_BACKUP}/"
        else
            warn "${ICON_WARN} ${MSG_BACKUP_GLPI_SITE_SOURCE_MISSING} ${SRC}"
        fi
    done
    info "${ICON_INFO} ${MSG_BACKUP_GLPI_SITE_COPY_OK}"
    # --- Compression ---
    info "${ICON_INFO} ${MSG_BACKUP_GLPI_COMPRESS_BACKUP}"
    mkdir -p "${REP_BACKUP_COMPRESS}"
    local BACKUP_FILE
    BACKUP_FILE="${REP_BACKUP_COMPRESS}/glpi_$(date +"%Y-%m-%d")_${GLPI_CLI_VERSION}->${VERSION_SELECT}.tar.gz"
    if tar -czf "${BACKUP_FILE}" -C "${REP_BACKUP}" . 2>> "${ERRORFILE}"; then
        info "${ICON_INFO} ${MSG_BACKUP_GLPI_COMPRESS_BACKUP_OK} (${BACKUP_FILE})"
        # Vérifier que le fichier compressé n'est pas vide
        if [ ! -s "${BACKUP_FILE}" ]; then
            warn "${ICON_WARN} ${MSG_BACKUP_GLPI_EMPTY_COMPRESS_BACKUP}"
            return 1
        fi
        # Suppression sécurisée de l’ancien GLPI
        info "${ICON_INFO} ${MSG_BACKUP_GLPI_REMOVE_OLD_GLPI_DIR}"
        if [ -n "${REP_GLPI}" ] && [ -d "${REP_GLPI}" ]; then
            rm -rf "${REP_GLPI:?}/" >> "${DEBUGFILE}" 2>> "${ERRORFILE}"
            info "${ICON_INFO} Répertoire ${REP_GLPI} supprimé."
        else
            warn "${ICON_WARN} ${MSG_BACKUP_GLPI_REMOVE_OLD_GLPI_DIR_NOTFOUND} ${REP_GLPI}"
        fi
    else
    warn "${ICON_WARN} ${MSG_BACKUP_GLPI_COMPRESS_BACKUP_FAILED}"
        return 1
    fi
    info "${ICON_INFO} ${MSG_BACKUP_GLPI_OK}"
    sleep 2
    export REP_BACKUP REP_GLPI
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}
# Mise à jour de GLPI
function update_glpi() {
    debug "${ICON_DEBUG} ${MSG_DEBUG_START}"
    info "${ICON_INFO} ${MSG_UPDATE_GLPI_START}"
    # Restauration des fichiers de configuration et des plugins
    info "${ICON_INFO} ${MSG_UPDATE_GLPI_RESTORE_FILES}"
    for DIR in config files plugins marketplace; do
        SRC="${REP_BACKUP}/${DIR}"
        if [ -d "${SRC}" ]; then
            case "${DIR}" in
                config) DEST="/etc/glpi/config" ;;
                files) DEST="/var/lib/glpi/files" ;;
                plugins) DEST="${REP_GLPI}/plugins" ;;
                marketplace) DEST="${REP_GLPI}/marketplace" ;;
            esac
            mkdir -p "${DEST}"
            if compgen -G "${SRC}/*" > /dev/null; then
                if cp -Rf "${SRC}/"* "${DEST}/"; then
                    info "${ICON_INFO} ${MSG_UPDATE_GLPI_RESTORE_FILES_OK}"
                else
                    warn "${ICON_WARN} ${ICON_WARN} ${MSG_UPDATE_GLPI_RESTORE_FILES_ERROR} ${DIR}."
                fi
            else
                warn "${ICON_WARN} ${MSG_UPDATE_GLPI_RESTORE_FILES_EMPTY}"
            fi
        fi
    done
    # Restauration du fichier downstream.php
    REP_BACKUP=$(find "${INVOKING_HOME}" -maxdepth 1 -type d -name "backup_glpi_*")
    info "${ICON_INFO} ${MSG_UPDATE_GLPI_RESTORE_FILES_DOWNSTREAM}"
    if [ -f "${REP_BACKUP}/downstream.php" ]; then
        mkdir -p "${REP_GLPI}/inc" 1>> "${DEBUGFILE}" 2>> "${ERRORFILE}"
        if cp -Rf "${REP_BACKUP}/downstream.php" "${REP_GLPI}/inc/" 1>> "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
            info "${ICON_INFO} ${MSG_UPDATE_GLPI_RESTORE_FILES_DOWNSTREAM_OK}"
        else
            warn "${ICON_WARN} ${MSG_UPDATE_GLPI_RESTORE_FILES_DOWNSTREAM_ERROR}"
        fi
    fi
    # Suppression de la sauvegarde
    info "${ICON_INFO} ${MSG_UPDATE_GLPI_REMOVE_OLD_FILES}"
    if [ -d "${INVOKING_HOME}" ]; then
        if find "${INVOKING_HOME}" -maxdepth 1 -type d -name "backup_glpi_*" -exec rm -rf {} + >> "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
            info "${ICON_INFO} ${MSG_UPDATE_GLPI_REMOVE_OLD_FILES_OK}"
        else
            warn "${ICON_WARN} ${MSG_UPDATE_GLPI_REMOVE_OLD_FILES_FAILED}"
        fi
    fi
    # Mise à jour de la base GLPI
    info "${ICON_INFO} ${MSG_UPDATE_GLPI_UPDATE_DATABASE}"
    if check_install_user "${REP_GLPI}"; then
        rights_glpi "${REP_GLPI}"
        debug "${ICON_DEBUG} Repertoire GLPI pour la mise à jour de la base : ${REP_GLPI}"
        debug "${ICON_DEBUG} Utilisateur web pour la mise à jour de la base : ${WEB_USER}"
        local CMD
        CMD="${REP_GLPI}/bin/console db:update --force --no-telemetry --quiet --no-interaction"
        # shellcheck disable=SC2086
        if sudo -u "${WEB_USER}" php ${CMD} 1>> "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
            info "${ICON_INFO} ${MSG_UPDATE_GLPI_UPDATE_DATABASE_OK}"
            exec 3>&1
            dialog --title "${ICON_OK} ${MSG_UPDATE_GLPI_DIALOG_DATABASE}" --msgbox "${MSG_UPDATE_GLPI_UPDATE_DATABASE_OK}" 7 50
            exec 3>&-
        else
            warn "${ICON_WARN} ${MSG_UPDATE_GLPI_UPDATE_DATABASE_FAILED} (voir ${ERRORFILE})."
            exec 3>&1
            dialog --title "${ICON_KO} ${MSG_UPDATE_GLPI_DIALOG_DATABASE}" --msgbox "${MSG_UPDATE_GLPI_UPDATE_DATABASE_FAILED}" 7 50
            exec 3>&-
            return 1
        fi
    fi
    # Nettoyage final
    info "${ICON_INFO} ${MSG_UPDATE_GLPI_CLEAN}"
    if find "${REP_GLPI}/install/" -maxdepth 1 -type f -name "install.php" -exec sudo rm -f {} +  ; then
        info "${ICON_INFO} ${MSG_UPDATE_GLPI_CLEAN_OK}"
    else
        warn "${ICON_WARN} ${MSG_UPDATE_GLPI_CLEAN_FAILED}"
        exit 1
    fi
    info "${ICON_INFO} ${MSG_UPDATE_GLPI_OK}"
    debug "${ICON_DEBUG} ${MSG_DEBUG_END}"
}