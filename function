#!/usr/bin/env bash
#
# GLPI install script
# Author: PapyPoc
# Version: 1.8.0
# Function file
#
# set -Eeuo pipefail
# Ne pas continuer si le script est exécuté directement

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo -e "Ce fichier doit être sourcé, pas exécuté.\n">> "${ERRORFILE}"
    return 1
fi
# Affichage d'erreur en rouge
function error(){
    local msg="$1"
    export_display_env
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    echo -e "${ROUGE}${expanded}${NC}" # Couleur rouge
    printf '%s\n' "${expanded}" | tee -a "${ERRORFILE}" >/dev/null
}
# Affichage d'alerte en orange
function warn(){
    local msg="$1"
    export_display_env
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    # echo -e "${ORANGE}${expanded}${NC}" # Couleur orange # Affichage à l'écran désactivé
    printf '%s\n' "${expanded}" | tee -a "${ERRORFILE}" >/dev/null # Affichage dans le fichier d'alerte
}
# Affichage d'information en bleu
function info(){
    local msg="$1"
    export_display_env
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    # echo -e "${CYAN}${expanded}${NC}" # Couleur cyan # Affichage à l'écran désactivé
    printf '%s\n' "${expanded}" | tee -a "${INFOFILE}" >/dev/null # Affichage dans le fichier d'info
}
# Affichage debug en normal
function debug(){
    local msg="$1"
    export_display_env
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    # echo -e "${NC}${expanded}${NC}" # Couleur normale Affichage à l'écran désactivé
    printf '%s\n' "${expanded}" | tee -a "${DEBUGFILE}" >/dev/null # Affichage dans le fichier de debug
}
# Exporter une liste blanche de variables utilisées dans les fichiers de langue pour que envsubst puisse les remplacer
function export_display_env() {
    # Exporter un ensemble complet de variables (majuscules et minuscules)
    # pouvant être référencées comme espaces réservés dans les fichiers de langue.
    # Les valeurs par défaut sont vides si elles ne sont pas définies.
    local vars_maj=(
        ORIG_USER ADMIN_GROUP ID VERSION_ID ID NAME PRETTY_NAME MSG_NONOK NEW_VERSION REP_GLPI FICHIER_MSG
        ERRORFILE LOGFILE TASK_INDEX TASK_KEY LANGUAGE TIMEZONE IPADRESS INTERFACE DOWNLOADLINK
        DB_USER DB_NAME SQLROOTPWD SQLGLPIPWD ADMINGLPIPWD POSTGLPIPWD TECHGLPIPWD NORMGLPIPWD
        REP_BACKUP BDD_BACKUP REP_SCRIPT MYSQL_CMD MYSQLDUMP_CMD OUTPUT PHPVERSION
        DEBIAN_VERSIONS UBUNTU_VERSIONS ALMA_VERSIONS CENTOS_VERSIONS ROCKY_VERSIONS REDHAT_VERSIONS MSG_UPGRADE_DISTRO
        NEW_VERSION TAGS VERSION_SELECT
    )
    local vars_min=(
        orig_user admin_group id version_id id name pretty_name msg_nonok new_version rep_glpi fichier_msg
        errorfile logfile task_index task_key language timezone ipadress interface downloadlink
        db_user db_name sqlrootpwd sqlglpipwd adminglpipwd postglpipwd techglpipwd normglpipwd
        rep_backup bdd_backup rep_script mysql_cmd mysqldump_cmd output phpversion
        debian_versions ubuntu_versions alma_versions centos_versions rocky_versions redhat_versions msg_upgrade_distro
        new_version tags version_select
    )
    local v _val
    for v in "${vars_maj[@]}" "${vars_min[@]}"; do
        _val="${!v:-}"
        export "$v"="$_val"
    done
}
# Gestion des erreurs avec trap
function on_error() {
    local rc=$?
    local cmd=$BASH_COMMAND
    local line=${BASH_LINENO[0]}

    local message="Erreur détectée : '${cmd}' (code=$rc) à la ligne $line\n"
    message+="Pile d’appels :\n"

    for ((i=${#FUNCNAME[@]}-1; i>=0; i--)); do
        message+="  ↳ ${FUNCNAME[$i]}() depuis ${BASH_SOURCE[$i]}:${BASH_LINENO[$((i-1))]}\n"
    done

    message+="──────────────────────────────"

    dialog --backtitle "Erreur" \
           --title "Erreur détectée" \
           --msgbox "$message" 60 100 || true
    error "$message" 1>> "${ERRORFILE}"
    exit "$rc"
}
# Vérifie si la version est compatible
function compatible() {
    debug "$(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Depuis ${FUNCNAME[1]:-main}"
    local version="$1"
    local -n versions_array="$2"
    [[ ${versions_array[*]} =~ ${version} ]]
    debug "$(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Fin de ${FUNCNAME[1]:-main}"
}
# Vérifie si la distribution est prise en compte pour l'installation de GLPI
function check_distro(){
    debug "$(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Depuis ${FUNCNAME[1]:-main}"
    # Vérifie si le fichier os-release existe
    source_os_release
    # Vérifie si la distribution est basée sur Debian, Ubuntu, Alma Linux, Centos ou Rocky Linux
    if [[ "${ID}" =~ ^(debian|ubuntu|almalinux|centos|rocky|rhel)$ ]]; then
        if [[ "$ID" == "debian" || "$ID" == "ubuntu" ]]; then
            WEB_USER="www-data"
        else
            WEB_USER="nginx"
        fi
        if compatible "$VERSION_ID" DEBIAN_VERSIONS || compatible "$VERSION_ID" UBUNTU_VERSIONS || compatible "$VERSION_ID" ALMA_VERSIONS || compatible "$VERSION_ID" CENTOS_VERSIONS || compatible "$VERSION_ID" ROCKY_VERSIONS || compatible "$VERSION_ID" REDHAT_VERSIONS; then
            info "$MSG_DISTRO_OK"
            return 0
        else
            warn "$MSG_DISTRO_NONOK"
            warn "$MSG_FORCE_DISTRO"
            if [ -t 0 ]; then
                info "$MSG_FORCE_DISTRO_QUESTION"
                read -r RESPONSE
                case $RESPONSE in
                    O|o|Y|y)
                        info "$MSG_CONTINUING"
                        ;;
                    N|n)
                        info "$MSG_EXITING"
                        return 1
                        ;;
                    *)
                        warn "$MSG_INVALID_ANSWER"
                        return 1
                        ;;
                esac
            else
                warn "$MSG_SCRIPT_NON_INTERACTIVE_DISTRO"
                return 1
            fi
        fi
        export VERSION_ID ID
    else
        warn "$MSG_DISTRO_INVALID"
        return 1
    fi
    export VERSION_ID ID WEB_USER
    debug "$(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Depuis ${FUNCNAME[1]:-main}"
}
# Chargement du fichier de langue
function load_language() {
    debug "$(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Depuis ${FUNCNAME[1]:-main}"
    local syslang="${LC_ALL:-${LANG:-}}"
    if [[ $syslang =~ ^fr ]]; then
        LANG_FILE="$REP_SCRIPT/lang/fr_lang.ini"
        LANGUAGE="fr_FR"
    else
        LANG_FILE="$REP_SCRIPT/lang/en_lang.ini"
        LANGUAGE="en_US"
    fi
    if [[ -f $LANG_FILE ]]; then
        # Ensure environment variables used in messages are exported for envsubst
        export_display_env
    # Lire le fichier ligne par ligne, gérer CRLF, commentaires, sections
    # et valeurs entre guillemets
        while IFS= read -r line || [ -n "$line" ]; do
            # supprimer CR si présent (fichiers format Windows)
            line="${line%%$'\r'}"
            # skip empty lines and comments
            # supprimer les espaces de tête
            trimmed="${line#"${line%%[![:space:]]*}"}"
            if [ -z "$trimmed" ]; then
                continue
            fi
            case "$trimmed" in
                "#"* | ";"*)
                    continue
                    ;;
            esac
            # ignorer les entêtes de section
            [[ $line =~ ^[[:space:]]*\[.*\] ]] && continue
            if [[ $line =~ ^[[:space:]]*([^=[:space:]]+)[[:space:]]*=(.*)$ ]]; then
                local key="${BASH_REMATCH[1]}"
                local value="${BASH_REMATCH[2]}"
                # trim leading/trailing whitespace from value
                value="${value#"${value%%[![:space:]]*}"}"
                value="${value%"${value##*[![:space:]]}"}"
                # remove surrounding single or double quotes if present
                if [[ $value =~ ^\'(.*)\'$ ]]; then
                    value="${BASH_REMATCH[1]}"
                elif [[ $value =~ ^\"(.*)\"$ ]]; then
                    value="${BASH_REMATCH[1]}"
                fi
                # Développer les espaces réservés dans la valeur avec envsubst
                # (préféré) ou utiliser eval en secours
                local expanded_value
                if command -v envsubst >/dev/null 2>&1; then
                    # envsubst reads from the environment, so ensure variables are exported
                    expanded_value=$( ( set +u; printf '%s' "$value" | envsubst ) )
                else
                    # fallback : effectuer l'expansion de paramètres en toute sécurité
                    # (autoriser les variables non définies)
                    expanded_value=$( ( set +u; eval "printf '%s' \"$value\"" ) )
                fi
                # affecter en toute sécurité à une variable nommée par $key
                printf -v "$key" '%s' "$expanded_value"
            fi
        done < "$LANG_FILE"
        info "$MSG_LANG_LOADED ($LANGUAGE)"
    else
        warn "Language file not found: $LANG_FILE"
    fi
    debug "$(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Fin de ${FUNCNAME[1]:-main}"
}
function check_install_user(){
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    REP_GLPI="${1:-/var/www/html/glpi}"
    if ! WEB_USER=$(stat -c '%U' "${REP_GLPI}") >/dev/null 2>&1; then
        debug "Impossible de déterminer l'utilisateur web pour le répertoire ${REP_GLPI}."
        return 1
    fi
    debug "Utilisateur web détecté : ${WEB_USER}"
    export WEB_USER REP_GLPI
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Demander à l'utilisateur de choisir la version de GLPI (16 dernières), le répertoire d'installation, le nom de la base et l'utilisateur BDD via dialog
function prompt_install_options(){
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    # Recherche des installations GLPI existantes
    FIND_REP_GLPI=""
    glpi_dirs=()
    # Parcours des répertoires standards à explorer
    for path in ${PATHS_TO_CHECK}; do
        # Recherche des dossiers contenant "glpi" jusqu’à 3 niveaux de profondeur
        FOUND=$(find "${path}" -maxdepth 3 -type d -name "*glpi*" 2>/dev/null)
        # Si un ou plusieurs répertoires sont trouvés, on les ajoute au tableau
        if [[ -n "$FOUND" ]]; then
            # On lit chaque ligne de la sortie de find et on l’ajoute au tableau
            while IFS= read -r dir; do
                glpi_dirs+=("$dir")
            done <<< "$FOUND"
        fi
    done
    # Si au moins un répertoire GLPI trouvé, demander à l'utilisateur de choisir
    if [[ "${#glpi_dirs[@]}" -gt 0 ]]; then
        # Préparer les arguments pour dialog
        find_rep=()
        rep_map=()
        number=1
        first="ON"
        # Correction : boucle while → for (syntaxe correcte)
        for dir in "${glpi_dirs[@]}"; do
            find_rep+=("${number}" "${dir}" "${first}")
            rep_map+=("${dir}")
            first="OFF"
            ((number++))
        done
        # Vérification utilisateur/distro avant exécution
        if check_install_user "${REP_GLPI}"; then
            GLPI_CLI_VERSION=$(sudo -u "${WEB_USER}" php "${REP_GLPI}/bin/console" --no-ansi --version 2>/dev/null | awk '{print $3}' || true)
        fi
        # Récupération des versions GLPI disponibles sur GitHub
        tags=""
        # Récupère les tags au format X.Y.Z
        tags=$(curl -s "${API_URL}" | jq -r '.[].name' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | grep -v -E '(rc|beta|alpha)' | uniq | head -n 16) 
        # Filtrage : ne garder que les versions avant GLPI_CLI_VERSION (donc plus récentes) ---
        newer_tags=()
        for tag in ${tags}; do
            if [[ "${tag}" == "${GLPI_CLI_VERSION}" ]]; then
                break  # On s'arrête dès qu'on atteint la version installée
            fi
            newer_tags+=("${tag}")
        done
        # Préparation du menu de sélection de version GLPI
        tag=""; find_version=(); version_map=(); number=1; first="ON"
        for tag in "${newer_tags[@]}"; do
            find_version+=("${number}" "GLPI ${tag}" "${first}")
            version_map+=("${tag}")
            first="OFF"
            ((number++))
        done
        # Menu de sélection d’installation GLPI
        exec 3>&1
        FIND_REP_GLPI=$(dialog \
            --backtitle "$MSG_TITRE" \
            --title "${MSG_GLPI_SELECT_INSTALLED}" \
            --radiolist "${MSG_GLPI_SELECT_INSTALLED_CHOIX}" 20 70 8 \
            "${find_rep[@]}" \
            3>&1 1>&2 2>&3)
        rc=$?
        exec 3>&-
        # Convertir le numéro choisi en index du tableau (0-based)
        local index=""
        index=$((FIND_REP_GLPI - 1))
        # Récupérer le vrai chemin correspondant
        REP_GLPI="${rep_map[$index]}"
        if [[ $rc -ne 0 ]]; then
            warn "Sélection du répertoire d'installation GLPI annulée par l'utilisateur." | tee -a "${DEBUGFILE}"
            dialog --title "Annulation" --msgbox "Installation annulée par l'utilisateur." 7 50
            return 1
        fi
        # Sélecteur de version GLPI
        exec 3>&1
        VERSION_SELECT=$(dialog \
            --backtitle "$MSG_TITRE" \
            --title "${MSG_PARAM_VERSION}" \
            --radiolist "${MSG_PARAM_VERSION_CHOIX}" 23 50 8 \
            "${find_version[@]}" \
            3>&1 1>&2 2>&3)
        rc=$?
        exec 3>&-
        if [[ "${rc}" -ne 0 ]]; then
            warn "Sélection de la version annulée."
            return 1
        fi
        # Convertir le numéro choisi en index du tableau (0-based)
        local index=""
        index=$((VERSION_SELECT - 1))
        # Récupérer le vrai tag correspondant
        VERSION_SELECT="${version_map[$index]}"
        dialog --title "${MSG_INFO}" --msgbox "\n${MSG_GLPI_INSTALLED}${GLPI_CLI_VERSION}, dans le répertoire : ${REP_GLPI}\n\n${MSG_UPGRADE1}${GLPI_CLI_VERSION}${MSG_UPGRADE2}${VERSION_SELECT}" 10 100
        export DOWNLOADLINK="https://github.com/glpi-project/glpi/releases/download/${VERSION_SELECT}/glpi-${VERSION_SELECT}.tgz"
        export VERSION_SELECT REP_GLPI DOWNLOADLINK REP_BACKUP_COMPRESS INVOKING_HOME GLPI_CLI_VERSION
        # Lancement de la mise à jour
        run_sequence "update"
    else
        tags=""
        # Récupère les tags au format X.Y.Z
        tags=$(curl -s "${API_URL}" | jq -r '.[].name' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | grep -v -E '(rc|beta|alpha)' | uniq | head -n 16) 
        local args=() first=ON number=1 version_map=()
        while IFS= read -r tag; do
            args+=("${number}" "GLPI ${tag}" "${first}")
            version_map+=("${tag}")
            first=OFF
            number=$((number + 1))
        done <<< "${tags}"
        exec 3>&1
        VERSION_SELECT=$(dialog --backtitle "$MSG_TITRE" --title "${MSG_PARAM_VERSION}" \
        --radiolist "${MSG_PARAM_VERSION_CHOIX}" 23 50 8 "${args[@]}" 3>&1 1>&2 2>&3)
        local rc=$?
        exec 3>&-
        if [ "${rc}" -ne 0 ]; then
            warn "Sélection de la version annulée."
            return 1
        fi
        # VERSION_SELECT retourne le tag choisi (ici nous utilisons des tags numériques mapping -> version_map)
        if ! [[ "${VERSION_SELECT}" =~ ^[0-9]+$ ]]; then
            warn "Valeur de version invalide retournée : ${VERSION_SELECT}"
            return 1
        fi
        # Convertir le numéro choisi en index du tableau (0-based)
        local index=""
        index=$((VERSION_SELECT - 1))
        # Récupérer le vrai tag correspondant
        VERSION_SELECT="${version_map[$index]}"
        if [ $index -lt 0 ] || [ $index -ge ${#version_map[@]} ]; then
            warn "Index de version hors plage : ${index}"
            return 1
        fi
        WIDTH_REP=$(( ${#MSG_PARAM_REP} ))
        WIDTH_DB_HOST=$(( ${#MSG_PARAM_DB_HOST} ))
        WIDTH_DB_NAME=$(( ${#MSG_PARAM_DB_NAME} ))
        WIDTH_DB_USER=$(( ${#MSG_PARAM_DB_USER} ))
        WIDTH=$(( WIDTH_REP > WIDTH_DB_HOST ? WIDTH_REP : WIDTH_DB_HOST ))
        WIDTH=$(( WIDTH > WIDTH_DB_NAME ? WIDTH : WIDTH_DB_NAME ))
        WIDTH=$(( WIDTH > WIDTH_DB_USER ? WIDTH : WIDTH_DB_USER ))
        WIDTH=$(( WIDTH + 6 ))
        local _def_rep="" rep_glpi="" _def_db_host="" db_host="" _def_db_name="" db_name="" _def_db_user="" db_user=""
        if [ -n "${FIND_REP_GLPI}" ]; then
            _def_rep="${REP_GLPI:-${FIND_REP_GLPI}}"
        else
            _def_rep="${REP_GLPI:-/var/www/html/glpi/}"
        fi
        local _def_db_host="${DB_HOST:-localhost}" _def_db="${DB_NAME:-glpi}" _def_user="${DB_USER:-glpi_user}"
        while true; do
            exec 3>&1
            form=$(dialog --backtitle "$MSG_TITRE" --title "$MSG_PARAM_TITLE" \
                --form "${MSG_GLPI_SELECT_PARAM_1} ${VERSION_SELECT} ${MSG_GLPI_SELECT_PARAM_2}" 18 68 8 \
                "📁 ${MSG_PARAM_REP}"     1 2 "${_def_rep}" 1 ${WIDTH} 20 40 \
                "🗄️ ${MSG_PARAM_DB_HOST}" 3 2 "${_def_db_host}" 3 ${WIDTH} 20 20 \
                "💾 ${MSG_PARAM_DB_NAME}" 5 2 "${_def_db}" 5 ${WIDTH} 20 20 \
                "👤 ${MSG_PARAM_DB_USER}" 7 2 "${_def_user}" 7 ${WIDTH} 20 20 \
                2>&1 1>&3)
            rc=$?
            exec 3>&-
            # Transformer les lignes du formulaire en variables
            IFS=$'\n' read -r rep_glpi db_host db_name db_user <<< "$form"
            rep_glpi="${rep_glpi#"${rep_glpi%%[![:space:]]*}"}"; rep_glpi="${rep_glpi%"${rep_glpi##*[![:space:]]}"}"
            db_host="${db_host#"${db_host%%[![:space:]]*}"}"; db_host="${db_host%"${db_host##*[![:space:]]}"}"
            db_name="${db_name#"${db_name%%[![:space:]]*}"}"; db_name="${db_name%"${db_name##*[![:space:]]}"}"
            db_user="${db_user#"${db_user%%[![:space:]]*}"}"; db_user="${db_user%"${db_user##*[![:space:]]}"}"
            rep_glpi="${rep_glpi//[^A-Za-z0-9_\/.-]/_}"
            db_host="${db_host//[^A-Za-z0-9_\/.-]/_}"
            db_name="${db_name//[^A-Za-z0-9_]/_}"
            db_user="${db_user//[^A-Za-z0-9_]/_}"
            [ -z "$rep_glpi" ] && rep_glpi="$_def_rep"
            [ -z "$db_host" ] && db_host="$_def_db_host"
            [ -z "$db_name" ] && db_name="$_def_db"
            [ -z "$db_user" ] && db_user="$_def_user"
            if [[ ! "$db_name" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
                db_name="glpi_${db_name}"
            fi
            rep_glpi="${rep_glpi//\\//}"
            if [ -z "${rep_glpi}" ] || [[ "${rep_glpi}" != /* ]]; then
                rep_glpi="${_def_rep}"
            fi
            rep_glpi="$(printf '%s' "${rep_glpi}" | sed -E 's#/{2,}#/#g')"
            REP_GLPI="${rep_glpi%/}/"
            DB_HOST="$db_host"
            DB_NAME="$db_name"
            DB_USER="$db_user"
            # Si annulation ou ESC
            if [[ $rc -ne 0 ]]; then
                warn "Formulaire annulé par l’utilisateur."
                dialog --title "${MSG_INFO}" --msgbox "Installation annulée par l'utilisateur." 7 60
                exit 1
            fi
            # --- VALIDATIONS ---
            # Répertoire d’installation
            if ! validate_glpi_path "$REP_GLPI"; then
                continue
            fi
            # Hôte de la base de données
            if ! validate_db_host "$DB_HOST"; then
                continue
            fi
            # Nom de la base de données
            if ! validate_db_name "$DB_NAME"; then
                continue
            fi
            # Utilisateur de la base de données
            if ! validate_db_user "$DB_USER"; then
                continue
            fi
            # Si tout est valide
            break
        done
        # Assignation des valeurs finales
        local DOWNLOADLINK="https://github.com/glpi-project/glpi/releases/download/${VERSION_SELECT}/glpi-${VERSION_SELECT}.tgz"
        local DB_HOST="${DB_HOST}"
        local REP_GLPI="${REP_GLPI}"
        local DB_NAME="${DB_NAME}"
        local DB_USER="${DB_USER}"
        local INVOKING_HOME="${PWD}"
        local TIMEZONE="${TIMEZONE:-UTC}"
        local VERSION_SELECT="${VERSION_SELECT}"
        export DOWNLOADLINK DB_HOST REP_GLPI DB_NAME DB_USER INVOKING_HOME TIMEZONE
        # Lancement de l’installation
        run_sequence "install"
    fi
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Valide le répertoire d’installation de GLPI
function validate_glpi_path() {
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    local path="$1"
    local clean_path
    # Nettoyage
    clean_path="$(printf '%s' "$path" | tr -d '\r\n' | sed -E 's#/{2,}#/#g' \
        | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    # Vérification du format
    if ! [[ "$clean_path" =~ ^(/var/www|/srv|/opt|/usr/share)/[^[:space:]]*glpi[^[:space:]]*$ ]]; then
        dialog --msgbox "Répertoire d’installation invalide : ${clean_path}\n\nDoit commencer par /var/www/, /srv/, /opt/ ou /usr/share/\n   et contenir 'glpi' dans le nom d’un dossier." 12 70
        warn "Validation échouée : répertoire d’installation invalide (${clean_path})"
        return 1
    fi
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Valide le répertoire d’installation de GLPI
function validate_db_host() {
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    host=$1
    # 1️⃣ Nettoyage de base
    clean_host=$(printf '%s' "$host" \
        | tr -d '\r' \
        | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
    # 2️⃣ Cas simples
    case "$clean_host" in
        localhost|::1|\[::1\])
            return 0 ;;
    esac
    # 3️⃣ Vérif IPv4 (structure correcte)
    if printf '%s\n' "$clean_host" | grep -Eq '^([0-9]{1,3}\.){3}[0-9]{1,3}$'; then
        IFS=.
        set -- $clean_host
        for o in "$@"; do
            case $o in
                *[!0-9]*) dbhost_err "$clean_host"; return 1 ;;
            esac
            [ "$o" -ge 0 ] 2>/dev/null && [ "$o" -le 255 ] 2>/dev/null || {
                dbhost_err "$clean_host"; return 1;
            }
        done
        return 0
    fi
    # 4️⃣ Vérif nom de domaine (FQDN simple)
    if printf '%s\n' "$clean_host" | grep -Eq '^([A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?\.)+[A-Za-z]{2,}$'; then
        return 0
    fi
    # 5️⃣ Sinon invalide
    dbhost_err "$clean_host"
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Helper message d'erreur + log
function dbhost_err() {
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    v=$1
    dialog --msgbox "Hôte de base de données invalide : ${v}\n\nAutorisé : localhost, ::1/[::1], nom de domaine complet ou adresse IPv4." 10 70
    warn "Validation échouée : hôte DB invalide (${v})"
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Valide le nom de la base de données
function validate_db_name() {
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    local name="$1"
    local clean_name
    clean_name="$(printf '%s' "$name" | tr -d '\r\n' \
        | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    if [[ ! "$clean_name" =~ ^[A-Za-z_][A-Za-z0-9_]{0,63}$ ]]; then
        dialog --msgbox "Nom de base de données invalide : ${clean_name}\n\nDoit commencer par une lettre ou un underscore (_)\n   et contenir uniquement lettres, chiffres ou underscores (max 64 caractères)." 12 70
        warn "Validation échouée : nom de base invalide (${clean_name})"
        return 1
    fi
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Valide le nom d’utilisateur de la base de données
function validate_db_user() {
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    local user="$1"
    local clean_user
    clean_user="$(printf '%s' "$user" | tr -d '\r\n' \
        | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    if [[ "$clean_user" == "root" ]]; then
        dialog --msgbox "Nom d’utilisateur invalide : ${clean_user}\n\nL’utilisateur de la base de données ne peut pas être 'root'." 10 70
        warn "Validation échouée : utilisateur 'root' interdit"
        return 1
    fi
    if [[ ! "$clean_user" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
        dialog --msgbox "Nom d’utilisateur invalide : ${clean_user}\n\nDoit commencer par une lettre ou un underscore (_)\n   et contenir uniquement lettres, chiffres ou underscores." 10 70
        warn "Validation échouée : utilisateur invalide (${clean_user})"
        return 1
    fi
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Sequence principale d'installation et de mise à jour de GLPI
function run_sequence() {
    local mode="$1"
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    trap 'on_error' ERR
    declare -A tasks
    local task_order=()
    case "$mode" in
        install)
            tasks=(
                ["$MSG_T01"]="update_distro"
                ["$MSG_T02"]="install_packages"
                ["$MSG_T03"]="network_info"
                ["$MSG_T04"]="mariadb_configure"
                ["$MSG_T05"]="install_glpi"
                ["$MSG_T06"]="setup_glpi"
                ["$MSG_T07"]="maj_user_glpi"
                ["$MSG_T08"]="write_credentials"
            )
            task_order=("$MSG_T01" "$MSG_T02" "$MSG_T03" "$MSG_T04" "$MSG_T05" "$MSG_T06" "$MSG_T07" "$MSG_T08")
            ;;
        update)
            tasks=(
                ["$MSG_T20"]="maintenance 1"
                ["$MSG_T21"]="update_distro"
                ["$MSG_T22"]="backup_glpi"
                ["$MSG_T23"]="install_glpi"
                ["$MSG_T24"]="update_glpi"
                ["$MSG_T25"]="maintenance 0"
            )
            task_order=("$MSG_T20" "$MSG_T21" "$MSG_T22" "$MSG_T23" "$MSG_T24" "$MSG_T25")
            ;;
        *)
            warn "Mode inconnu : ${mode}"
            return 1
            ;;
    esac
    local total_tasks=${#task_order[@]}
    local task_index=0
    local progress=0
    local task_key=""
    local MSG_OK="✅"
    local MSG_NONOK="❌"
    (
        for task_key in "${task_order[@]}"; do
            task_index=$((task_index + 1))
            progress=$((task_index * 100 / total_tasks))
            echo "$progress"
            echo "XXX"
            echo "${task_index}/${total_tasks} - ${task_key} en cours..."
            echo "XXX"
            debug "$(date '+%F %T') [$$][DEBUG: Début de la tâche '${task_key}'] commande '${tasks[${task_key}]}'"
            if run_task "${task_key}" "${tasks[${task_key}]}" "${task_index}" "${total_tasks}"; then
                echo "$progress"
                echo "XXX"
                echo "${task_index}/${total_tasks} - ${task_key} ${MSG_OK}"
                echo "XXX"
                debug "$(date '+%F %T') [$$][DEBUG: Tâche '${task_key}' commande '${tasks[${task_key}]}' terminée avec succès.]"
                sleep 1
            else
                echo "100"
                echo "XXX"
                echo "${task_index}/${total_tasks} - ${task_key} ${MSG_NONOK}"
                echo "XXX"
                debug "$(date '+%F %T') [$$][DEBUG: Tâche '${task_key}' commande '${tasks[${task_key}]}' échouée.]"
                sleep 5
                return 1   # stoppe la boucle sur échec
            fi
            sleep 0.5
        done
    ) | dialog --clear --backtitle "$MSG_TITRE" --title "$MSG_TITRE_GAUGE" --gauge "" 8 120

    # Vérifie le code retour du sous-shell
    if [ "${PIPESTATUS[0]}" -ne 0 ]; then
        warn "Une tâche a échoué pendant l'exécution de ${mode}() commande '${tasks[${task_key}]}' ${MSG_NONOK}."
        debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Mode=${mode} (échec)"
        return 1
    fi

    info "Toutes les tâches du mode '${mode}' ont été exécutées avec succès."
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Exécuter une tâche et gérer les erreurs et les logs
function run_task() {
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    # Définir les variables de tâche
    local task_key="$1" task_cmd="$2" index="$3" total="$4"
    # Afficher les informations de la tâche
    info "Tâche: ${index}/${total} - ${task_key}"
    info "$MSG_COMMAND: $task_cmd"
    debug "$(date '+%F %T') [PID:$$][DEBUG:${FUNCNAME[0]:-main}] Début de la tâche ${task_key} - ${index}/${total} - ${task_cmd}"
    # --- Exécution de la commande ---
    local output exit_code
    output=$(eval "$task_cmd" 2>&1)
    exit_code=$?
    # --- Résultat ---
    if (( exit_code == 0 )); then
        debug "$output"
        debug "$(date '+%F %T') [PID:$$][DEBUG:${FUNCNAME[0]:-main}] Fin (succès) de la tâche ${task_key} - ${index}/${total} - ${task_cmd}"
    else
        warn "$(date '+%Y-%m-%d %H:%M:%S'): ERROR: ${task_cmd}"
        warn "$output"
        warn "$MSG_ERROR_TASK: ${task_key} (exit=${exit_code})"
        debug "$(date '+%F %T') [PID:$$][DEBUG:${FUNCNAME[0]:-main}] Fin (échec) de la tâche ${task_key} - ${index}/${total} - ${task_cmd}"
        return $exit_code
    fi
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    return 0
}
# Mise à jour de la distribution
function update_distro(){
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    if [[ "${ID}" =~ ^(debian|ubuntu)$ ]]; then
           info "$MSG_UPGRADE_DISTRO"
           timedatectl set-ntp true # Synchronise l'heure
           sleep 5
           apt-get update && apt-get upgrade -y >> "${UPDATEFILE}" 2>> "${ERRORFILE}"
    elif [[ "${ID}" =~ ^(almalinux|centos|rocky|rhel)$ ]]; then
           info "$MSG_UPGRADE_DISTRO"
           chronyc makestep # Synchronise l'heure
           sleep 5
           yum update -y && yum upgrade -y >> "${UPDATEFILE}" 2>> "${ERRORFILE}"
	fi
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Adresse IP de la machine
function network_info() {
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    # Détection de l’interface principale (hors loopback et interfaces virtuelles)
    INTERFACE=$(ip route get 1.1.1.1 2>/dev/null | awk '/dev/ {print $5; exit}')
    if [[ -z "$INTERFACE" ]]; then
        INTERFACE=$(ip -o link show | awk -F': ' '!/lo|docker|vir|veth/ {print $2; exit}')
    fi
    # Récupération de l’adresse IP associée
    IPADRESS=$(ip -4 addr show "$INTERFACE" 2>/dev/null | awk '/inet / {print $2}' | cut -d'/' -f1 | head -n1)
    # Vérification et export
    if [[ -n "$IPADRESS" ]]; then
        export IPADRESS
        info "$(date '+%F %T'): INFO: Interface détectée : ${INTERFACE}, IP : ${IPADRESS}"
    else
    warn "Impossible de déterminer l’adresse IP du serveur via l’interface ${INTERFACE:-inconnue}"
        IPADRESS="127.0.0.1"
        export IPADRESS
    fi
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Installation des éléments nécessaire
function install_packages(){
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    source_os_release
    if [[ "${ID:-}" =~ ^(debian|ubuntu)$ ]]; then
        sleep 1
        export DEBIAN_FRONTEND=noninteractive
        # update cache first
        if command -v apt-get update >> "${UPDATEFILE}" 2>> "${ERRORFILE}"; then
            echo "$(date '+%Y-%m-%d %H:%M:%S'): DEBUG: apt-get update"
            if ! apt-get upgrade -y >> "${UPDATEFILE}" 2>> "${ERRORFILE}"; then
                warn "apt-get upgrade failed"
                # continue, maybe cached; but log
            fi
        else
            error "apt-get not found, cannot install packages on Debian/Ubuntu branch"
            return 1
        fi
        info "$MSG_INSTALL_EXT_PHP"
        if ! sudo apt-get install -y php-{bcmath,mysql,mbstring,curl,gd,xml,intl,ldap,apcu,opcache,xmlrpc,zip,bz2} \
            | sudo tee -a "${UPDATEFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2)
        then
            error "$MSG_PHP_EXT_FAILED"
            return 1
        fi
        info "$MSG_INSTALL_SERVICE"
        if ! sudo apt-get install -y wget composer tar apache2 apache2-bin mariadb-server mariadb-client perl php \
            | sudo tee -a "${UPDATEFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2)
        then
            error "$MSG_LAMP_FAILED"
            return 1
        fi
        info "$MSG_ACTIVE_START_BDD"
        manage_service "mariadb" "MariaDB" || return 1
        info "$MSG_ACTIVE_START_WEB"
        manage_service "apache2" "Apache2" || return 1
    elif [[ "${ID:-}" =~ ^(almalinux|centos|rocky|rhel|fedora)$ ]]; then
        sleep 1
        dnf makecache --refresh
        if ! command -v dnf >/dev/null 2>&1; then
            error "dnf not found, cannot install packages on RHEL-like branch" | tee -a "${ERRORFILE}"
            return 1
        fi
        if ! dnf makecache --refresh \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2)
        then
            error "$MSG_EPEL_FAILED"
            # continue; attempt install may still work
        fi
        if ! dnf install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2)
        then
            error "$MSG_EPEL_FAILED"
            return 1
        fi
        if ! dnf module reset -y php nginx mariadb composer \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2)
        then
            error "$MSG_MODULES_RESET_FAILED"
            return 1
        fi
        if ! dnf module install -y php:8.2 \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2)
        then
            error "$MSG_PHP_INSTALL_FAILED"
            return 1
        fi
        if ! dnf module install -y nginx:1.24 \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2)
        then
            error "$MSG_NGINX_INSTALL_FAILED"
            return 1
        fi
        if ! dnf module install -y mariadb:10.11 \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2)
        then
            error "$MSG_MARIADB_INSTALL_FAILED"
            return 1
        fi
        info "$MSG_AUTO_UPDATES"
        if ! dnf install dnf-automatic -y \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2)
        then
            error "$MSG_DNF_AUTO_FAILED"
            return 1
        fi
        {
            sed -i 's/^\(;\?\)\(apply_updates =\).*/\2 yes/' /etc/dnf/automatic.conf
            sed -i 's/^\(;\?\)\(reboot =\).*/\2 when-needed/' /etc/dnf/automatic.conf
            sed -i 's/^\(;\?\)\(upgrade_type =\).*/\2 security/' /etc/dnf/automatic.conf
        }
        if ! mkdir /etc/systemd/system/dnf-automatic.timer.d \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2)
        then
            warn "$MSG_DNF_AUTO_DIR_FAILED"
            return 1
        fi
        sudo tee /etc/systemd/system/dnf-automatic.timer.d/override.conf << 'EOF'
[Unit]
Description=dnf-automatic timer
ConditionPathExists=!/run/ostree-booted
Wants=network-online.target

[Timer]
OnCalendar=*-*-* 6:00
RandomizedDelaySec=60m
Persistent=true
EOF
        if ! systemctl enable --now dnf-automatic.timer; then
            warn "$MSG_DNF_AUTO_ACTIVATE_FAILED"
            return 1
        fi
        info "$MSG_INSTALL_EXT_PHP"
        if ! dnf install -y php-{bcmath,mysql,mbstring,curl,gd,xml,intl,ldap,apcu,opcache,xmlrpc,zip,bz2}; then
            warn "$MSG_PHP_EXT_FAILED"
            return 1
        fi
        info "$MSG_INSTALL_SERVICE lamp..."
        if ! dnf install -y crontabs logrotate cronie tar nginx mariadb-server mariadb perl curl jq php epel-release; then
            warn "$MSG_LAMP_FAILED"
            return 1
        fi
        sed -i 's/^\(;\?\)\(user =\).*/\2 nginx/' /etc/php-fpm.d/www.conf
        sed -i 's/^\(;\?\)\(group =\).*/\2 nginx/' /etc/php-fpm.d/www.conf
        info "$MSG_ACTIVE_START_WEB MariaDB, d'ENGINE X et de PHP-FPM"
        if ! systemctl enable --now mariadb nginx php-fpm; then
            warn "$MSG_SERVICES_START_FAILED"
            return 1
        fi
        if ! firewall-cmd --permanent --zone=public --add-service=http || ! firewall-cmd --reload; then
            warn "$MSG_FIREWALL_FAILED"
            return 1
        fi
    fi
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
function manage_service() {
    local service="$1"
    local label="$2"

    info "Activation et démarrage du service ${label}..."
    {
        systemctl enable "${service}"
        systemctl restart "${service}"
    } >>"${DEBUGFILE}" 2>>"${ERRORFILE}" || {
        error "Échec lors de la gestion du service ${label}."
        return 1
    }
    info "Service ${label} activé et démarré avec succès."
}
function get_timezone() {
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    # Détection du fuseau horaire
    if [ -z "${TIMEZONE:-}" ]; then
        local tzfile=""
        if command -v timedatectl >/dev/null 2>&1; then
            TIMEZONE=$(timedatectl show -p Timezone --value 2>/dev/null || true)
        fi
        if [ -z "${TIMEZONE:-}" ] && [ -f /etc/timezone ]; then
            TIMEZONE=$(head -n 1 /etc/timezone 2>/dev/null || true)
        fi
        if [ -z "${TIMEZONE:-}" ]; then
            if [ -L /etc/localtime ] || [ -f /etc/localtime ]; then
                tzfile=$(readlink -f /etc/localtime 2>/dev/null || true)
                if [[ "$tzfile" == *"/usr/share/zoneinfo/"* ]]; then
                    TIMEZONE="${tzfile#*/usr/share/zoneinfo/}"
                fi
            fi
        fi
        if [ -z "${TIMEZONE:-}" ] && [ -f /etc/sysconfig/clock ]; then
            TIMEZONE=$(awk -F= '/^ZONE/ {gsub(/"/,"",$2); print $2}' /etc/sysconfig/clock 2>/dev/null || true)
        fi
        TIMEZONE="${TIMEZONE:-UTC}"
        export TIMEZONE
        info "Fuseau horaire détecté : ${TIMEZONE}"
    fi
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Configuration de la base de données MariaDB
function mariadb_configure() {
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    # Détecter la commande MySQL/MariaDB
    info "$MSG_BDD_CONFIG"
    MYSQL_CMD=$(command -v mysql || command -v mariadb || echo mysql)
    if [ -z "$MYSQL_CMD" ]; then 
        error "Commande MySQL/MariaDB introuvable"
        return 1
    fi
    get_timezone
    debug "Utilisation de la commande : ${MYSQL_CMD}" # Pour le débogage
    debug "Configuration de la base de données MariaDB/MySQL" # Pour le débogage
    debug "Connexion à l'hôte de la base de données : ${DB_HOST}" # Pour le débogage
    debug "Modification du mot de passe de l'utilisateur root de la base de données : ${SQLROOTPWD}" # Pour le débogage
    debug "Création de la base de données : ${DB_NAME}" # Pour le débogage
    debug "Création de l'utilisateur de la base de données : ${DB_USER} avec mot de passe ${SQLGLPIPWD}" # Pour le débogage
    debug "Attribution des privilèges à l'utilisateur de la base de données" # Pour le débogage
    # Construire la commande SQL et l'exécuter avec -e (évite les problèmes d'heredoc et de quoting)
    # --- Construction sécurisée du script SQL ---
    local _sql_root
    _sql_root=$(
        cat <<SQL
ALTER USER 'root'@'localhost' IDENTIFIED BY '${SQLROOTPWD}';
DELETE FROM mysql.user WHERE User='';
DELETE FROM mysql.user WHERE User='root' AND Host!='localhost';
DROP DATABASE IF EXISTS test;
DELETE FROM mysql.db WHERE Db='test' OR Db LIKE 'test_%';
GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION;
CREATE DATABASE IF NOT EXISTS \`${DB_NAME}\`;
CREATE USER IF NOT EXISTS '${DB_USER}'@'localhost' IDENTIFIED BY '${SQLGLPIPWD}';
GRANT ALL PRIVILEGES ON \`${DB_NAME}\`.* TO '${DB_USER}'@'localhost';
GRANT SELECT ON mysql.time_zone_name TO '${DB_USER}'@'localhost';
FLUSH PRIVILEGES;
SQL
    )
    # --- Application des commandes SQL ---
    if ! PAGER=cat MYSQL_PWD="${SQLROOTPWD}" "${MYSQL_CMD}" -u root --batch --silent -e "${_sql_root}" mysql; then
        warn "${MSG_ERROR_TASK:-Erreur}: configuration SQL initiale échouée."
        return 1
    fi

    # --- Import des informations de fuseaux horaires ---
    info "${MSG_TIMEZONE_CONFIG:-Import des fuseaux horaires dans MySQL...}"
    if ! mysql_tzinfo_to_sql /usr/share/zoneinfo 2>/dev/null | PAGER=cat MYSQL_PWD="${SQLROOTPWD}" "${MYSQL_CMD}" -u root mysql; then
        warn "${MSG_ERROR_TASK:-Erreur}: import du timezone échoué."
        return 1
    fi
    # --- Redémarrage du service ---
    if systemctl is-active --quiet mariadb; then
        systemctl restart mariadb || warn "Impossible de redémarrer le service MariaDB."
    else
        warn "MariaDB n'est pas actif, démarrage forcé..."
        systemctl start mariadb || warn "Échec du démarrage de MariaDB."
    fi
    sleep 3
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Téléchargement et décompression de GLPI
function install_glpi(){
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    info "$MSG_DOWNLOAD_INSTALL_GLPI"
    # Téléchargement de GLPI
    tmp_file="$(mktemp /tmp/glpi_XXX.tar.gz)"
    debug "Téléchargement de GLPI depuis ${DOWNLOADLINK} vers ${tmp_file}"
    if ! wget -q -O "$tmp_file" "${DOWNLOADLINK}" 1>> "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
        warn "$MSG_DOWNLOAD_FAILED" 1>> "${ERRORFILE}"
        rm -f "$tmp_file"
        return 1
    fi
    if [ ! -d "$REP_GLPI" ]; then
        mkdir -p "$REP_GLPI" || { warn "$MSG_CREATE_DIR_FAILED"; rm -f "$tmp_file"; return 1; }
    fi
    # Extraire l'archive dans le répertoire d'installation
    tar xzf "$tmp_file" --strip-components=1 -C "$REP_GLPI"
    rm -f "$tmp_file"
    sleep 5;
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Mise en place des réglage pour GLPI
function setup_glpi(){
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    source_os_release
    local CMD="${REP_GLPI}/bin/console db:install \
 --db-host localhost \
 --db-port=3306 \
 --db-name=${DB_NAME} \
 --db-user=${DB_USER} \
 --db-password=${SQLGLPIPWD} \
 --default-language=${LANGUAGE} \
 --force \
 --no-telemetry \
 --quiet \
 --no-interaction"
    info "$MSG_CONFIG_GLPI"
    mkdir -p /var/log/glpi 
    mkdir -p /etc/glpi/config 
    mkdir -p /var/lib/glpi/files 
    mv -f "${REP_GLPI}"/files /var/lib/glpi ||
    {
        warn "Échec du déplacement du répertoire files de GLPI."
        return 1
    }
    sudo tee /etc/glpi/config/local_define.php  <<'EOF'
<?php
    define('GLPI_VAR_DIR', '/var/lib/glpi/files');
    define('GLPI_LOG_DIR', '/var/log/glpi');
EOF
    sleep 1
    sudo tee "${REP_GLPI}"/inc/downstream.php  <<EOF
<?php
    define('GLPI_CONFIG_DIR', '/etc/glpi/config');
    if (file_exists(GLPI_CONFIG_DIR . '/local_define.php')) {
        require_once GLPI_CONFIG_DIR . '/local_define.php';
    }
EOF
    network_info
    if check_install_user "${REP_GLPI}"; then
        if [[ "${WEB_USER}" == "www-data" ]]; then
            # Configuration d'Apache pour GLPI
            sudo tee /etc/apache2/sites-available/glpi.conf  <<EOF
<VirtualHost *:80>
    ServerName ${IPADRESS}
    DocumentRoot ${REP_GLPI}/public
    <Directory ${REP_GLPI}/public>
        Require all granted
        RewriteEngine On
        RewriteCond %{HTTP:Authorization} ^(.+)$
        RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
        RewriteCond %{REQUEST_FILENAME} !-f
        RewriteRule ^(.*)$ index.php [QSA,L]
    </Directory>
    ErrorLog /var/log/glpi/error.log
    CustomLog /var/log/glpi/access.log combined
</VirtualHost>
EOF
            phpversion=$(php -v | grep -i '(cli)' | awk '{print $2}' | cut -d. -f1,2)
            sed -i 's/^\(;\?\)\(session.cookie_httponly\).*/\2 =on/' /etc/php/"$phpversion"/apache2/php.ini
            sleep 1
            # Disable Apache Web Server Signature
            echo "ServerSignature Off" >> /etc/apache2/apache2.conf
            echo "ServerTokens Prod" >> /etc/apache2/apache2.conf
            # Activation du module rewrite d'apache
            if ! a2enmod rewrite | tee -a "${DEBUGFILE}"; then
                warn "Échec de l'activation du module rewrite d'Apache."
                return 1
            fi
            # Déactiver le site par défaut
            if ! a2dissite 000-default.conf | tee -a "${DEBUGFILE}"; then
                warn "Échec de la désactivation du site par défaut d'Apache."
                return 1
            fi
            # Activer le site GLPI
            if ! a2ensite glpi.conf | tee -a "${DEBUGFILE}"; then
                warn "Échec de l'activation du site GLPI."
                return 1
            fi
            # Recharger la configuration d'Apache
            if ! systemctl reload apache2 | tee -a "${DEBUGFILE}"; then
                warn "Échec du rechargement d'Apache."
                return 1
            fi
            # Installation de GLPI en ligne de commande
            echo "$(date '+%Y-%m-%d %H:%M:%S') - [INFO] Exécution : sudo -u ${WEB_USER} php ${CMD}" || true
            # Exécuter la commande en tant que "${WEB_USER}". Utiliser sudo tee pour écrire vers les fichiers protégés.
            if eval sudo -u "${WEB_USER}" php "${CMD}"; then
                info "Installation GLPI terminée avec succès."
            else
                warn "Échec de l'installation GLPI via console."
                return 1
            fi
            # Change permissions
            if ! rights_glpi "${REP_GLPI}"; then
                warn "Échec de la modification des droits pour GLPI."
                return 1
            fi
            info "$MSG_ACTIVE_START_BDD"
            manage_service "apache2" "Apache2" || return 1
        elif [[ "${WEB_USER}" == "nginx" ]]; then
            network_info
            sudo tee /etc/nginx/conf.d/glpi.conf << EOF
server {
    listen 80;
    server_name ${IPADRESS};
    root ${REP_GLPI}public;
    location / {
        try_files \$uri /index.php\$is_args\$args;
    }
    location ~ ^/index\.php$ {
        # the following line needs to be adapted, as it changes depending on OS distributions and PHP versions
        fastcgi_pass unix:/var/run/php-fpm/www.sock;
        fastcgi_split_path_info ^(.+\.php)(/.*)$;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;
    }
}
EOF
            sudo tee /etc/logrotate.d/glpi << EOF
# Rotate GLPI logs daily, only if not empty
# Save 14 days old logs under compressed mode
/var/lib/glpi/files/_log/*.log {
    su nginx nginx
    daily
    rotate 14
    compress
    notifempty
    missingok
    create 644 nginx nginx
}
EOF
            chmod 0644 /etc/logrotate.d/glpi
            chown root:root /etc/logrotate.d/glpi
            chcon system_u:object_r:etc_t:s0 /etc/logrotate.d/glpi
            sed -i 's/^\(;\?\)\(session.cookie_httponly\).*/\2 = on/' /etc/php.ini
            # Change permissions
            if ! rights_glpi "${REP_GLPI}"; then
                warn "Échec de la modification des droits pour GLPI."
                return 1
            fi
            # Recharger la configuration de Nginx
            if ! systemctl reload nginx php-fpm; then
                warn "Échec du rechargement de Nginx ou PHP-FPM."
                return 1
            fi
            # Installation de GLPI en ligne de commande
            if eval sudo -u "${WEB_USER}" "${CMD}"; then
                info "Installation GLPI terminée avec succès."
            else
                warn "Échec de l'installation GLPI via console."
                return 1
            fi
            sleep 2
        fi
        # Configuration de la tâche Cron
        echo "*/2 * * * * ${WEB_USER} /usr/bin/php ""${REP_GLPI}""front/cron.php &>/dev/null" >> /etc/cron.d/glpi
    fi
    sleep 5
    if ! rm -Rf "${REP_GLPI}install/install.php"; then
        warn "Échec de la suppression du script d'installation de GLPI."
        return 1
    fi
    sleep 2
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Mise à jour des mot de passe des utilisateurs de GLPI
function maj_user_glpi(){
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    info "${MSG_CHANGE_MDP_GLPI}"
    # Ensure we have a mysql client command; fallback to detecting it if not set
    local MYSQL_CMD
    MYSQL_CMD=$(command -v mysql  || command -v mariadb || echo mysql)
    # Verify mysql client exists
    if ! command -v "${MYSQL_CMD}"; then
        warn "Client MySQL introuvable : ${MYSQL_CMD}"
        return 1
    fi
    # --- Vérification des variables critiques ---
    if [ -z "${DB_NAME:-}" ] || [ -z "${DB_USER:-}" ] || [ -z "${SQLGLPIPWD:-}" ]; then
        error "Variables manquantes : DB_NAME, DB_USER ou SQLGLPIPWD"
        return 1
    fi

    if [ -z "${ADMINGLPIPWD:-}" ] || [ -z "${POSTGLPIPWD:-}" ] || [ -z "${TECHGLPIPWD:-}" ] || [ -z "${NORMGLPIPWD:-}" ]; then
        error "Un ou plusieurs mots de passe GLPI ne sont pas définis"
        return 1
    fi
    # Construire la requête SQL et exécuter via -e
    local _sql_user
    debug "Préparation des commandes SQL pour mettre à jour les mots de passe des utilisateurs GLPI." # Pour le débogage
    debug "Utilisation de la commande MySQL: ${MYSQL_CMD}" # Pour le débogage
    debug "Base de données: ${DB_NAME}, Utilisateur: ${DB_USER}", "Mot de passe SQL: ${SQLGLPIPWD}" # Pour le débogage
    debug "Nouveaux mots de passe des utilisateurs GLPI:" # Pour le débogage
    debug "  - glpi: ${ADMINGLPIPWD}" # Pour le débogage
    debug "  - post-only: ${POSTGLPIPWD}" # Pour le débogage
    debug "  - tech: ${TECHGLPIPWD}" # Pour le débogage
    debug "  - normal: ${NORMGLPIPWD}" # Pour le débogage
    debug "Mots de passe des utilisateurs GLPI seront mis à jour." # Pour le débogage
    debug "Fuseau horaire: ${TIMEZONE}, Langue: ${LANGUAGE}" # Pour le débogage
    debug "Construction des commandes SQL..." # Pour le débogage
    # --- Construction du SQL ---
    local _sql_user
    _sql_user=$(
        cat <<SQL
USE \`${DB_NAME}\`;
UPDATE glpi_users SET password = MD5('${ADMINGLPIPWD}') WHERE name = 'glpi';
UPDATE glpi_users SET password = MD5('${POSTGLPIPWD}') WHERE name = 'post-only';
UPDATE glpi_users SET password = MD5('${TECHGLPIPWD}') WHERE name = 'tech';
UPDATE glpi_users SET password = MD5('${NORMGLPIPWD}') WHERE name = 'normal';
UPDATE glpi_configs SET value = '${TIMEZONE}' WHERE context = 'core' AND name = 'timezone';
UPDATE glpi_configs SET value = '${LANGUAGE}' WHERE context = 'core' AND name = 'language';
UPDATE glpi_configs SET value = '${IPADRESS}' WHERE context = 'core' AND name = 'url_base';
SQL
    )
    # --- Exécution SQL ---
    debug "Exécution des commandes SQL..."
    if ! PAGER=cat MYSQL_PWD="${SQLGLPIPWD}" "${MYSQL_CMD}" -u "${DB_USER}" --batch --silent -e "${_sql_user}" 2>/dev/null; then
        error "${MSG_ERROR_TASK:-Erreur} : échec de la mise à jour des utilisateurs GLPI."
        return 1
    fi
    info "Comptes GLPI mis à jour avec succès dans ${DB_NAME}."
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
function source_os_release(){
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    if [[ -f /etc/os-release ]]; then
        # shellcheck disable=SC1091
        . /etc/os-release
    fi
    if [[ -f /etc/lsb-release ]]; then
        # shellcheck disable=SC1091
        . /etc/lsb-release
    fi
    if [[ -z "${ID:-}" ]]; then
        ID=$(uname -s | tr '[:upper:]' '[:lower:]')
    fi
    if [[ -z "${VERSION_ID:-}" ]]; then
        VERSION_ID=$(uname -r)
    fi
    if [ -z "${ID:-}" ] || [ -z "${VERSION_ID:-}" ]; then
        warn "Variables ID ou VERSION_ID non définies après sourcing de /etc/os-release"
        return 1
    fi
    export ID VERSION_ID
    info "$(date '+%F %T'): INFO: OS détecté : ${ID} ${VERSION_ID}"
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
function rights_glpi(){
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    REP_GLPI="${1:-/var/www/html/glpi}"
    # Changer les droits des répertoires et fichiers
    info "$MSG_RIGHTS_GLPI"
    find "${REP_GLPI}" -type d -exec chmod 755 {} \; 1> >(tee -a "${DEBUGFILE}") 2> >(tee -a "${ERRORFILE}" >&2)
    find "${REP_GLPI}" -type f -exec chmod 644 {} \; 1> >(tee -a "${DEBUGFILE}") 2> >(tee -a "${ERRORFILE}" >&2)
    # Changer le propriétaire des répertoires
    if check_distro ; then
        sudo chown -Rc "${WEB_USER}":"${WEB_USER}" /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}"
    fi
    # SELinux configuration
    if [[ "${WEB_USER}" == "nginx" ]]; then
        if command -v semanage; then
            setsebool -P httpd_can_network_connect on
            setsebool -P httpd_can_network_connect_db on
            setsebool -P httpd_can_sendmail on
            for p in "${REP_GLPI}" /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}/marketplace"; do
                semanage fcontext -a -t httpd_sys_rw_content_t "${p}(/.*)?"
            done
            restorecon -R "${REP_GLPI}" /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}/marketplace"
        else
            error "$(date '+%F %T'): WARN: semanage non disponible — SELinux non configuré"
        fi
    fi
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Afficher le résultat final
function display_result() {
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    MESSAGE=""
	if [[ -f "${FICHIER_MSG}" ]]; then
        while IFS= read -r ligne; do
            MESSAGE+="${ligne}\n"
        done < "${FICHIER_MSG}"
        dialog --backtitle "${MSG_TITRE}" --title "${MSG_TITRE_OK}" --msgbox "${MESSAGE}" 0 0
    else
        while IFS= read -r ligne; do
            MESSAGE+="${ligne}\n"
        done < "${ERRORFILE}"
        dialog --backtitle "${MSG_TITRE}" --title "${MSG_TITRE_NONOK}" --msgbox "${MSG_NONOK}\n\n${MSG_ERROR_FICHIER_MSG}" 0 0
        exit 1
    fi
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Ecriture du fichier pour sauvegarder les mot de passe du serveur GLPI
function write_credentials(){
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    if [[ "${LANGUAGE}" == "fr_FR" ]]; then
        cat > "$FICHIER_MSG" << EOF
<==========================> Détails de l'installation de GLPI <=================================>
 GLPI Version: ${VERSION_SELECT}
 Répertoire d'installation de GLPI: ${REP_GLPI}

 Les comptes utilisateurs par défaut sont :
 UTILISATEUR   -  MOT DE PASSE       -       ACCES
  glpi         -  ${ADMINGLPIPWD}     -  compte admin
  post-only    -  ${POSTGLPIPWD}     -  compte post-only
  tech         -  ${TECHGLPIPWD}     -  compte tech
  normal       -  ${NORMGLPIPWD}     -  compte normal

 Vous pouvez accéder à la page web de GLPI à partir d'une adresse IP ou d'un nom d'hôte :
 http://${DB_HOST}

 ==> Base de données:
 Hôte de la base de données: ${DB_HOST}
 Port de la base de données: 3306
 Nom de la base de données GLPI: ${DB_NAME}
 Mot de passe root: ${SQLROOTPWD}
 Mot de passe ${DB_USER}: ${SQLGLPIPWD}

 Fichier de sauvegarde enregistré dans ${FICHIER_MSG}
 <===============================================================================================>

 Si vous rencontrez un probléme avec ce script, veuillez le signaler sur GitHub : https://github.com/PapyPoc/glpi_install/issues
EOF
	else
		cat > "$FICHIER_MSG" << EOF
<=============================> GLPI installation details <=====================================>
 GLPI version: ${VERSION_SELECT}
 GLPI installation directory: ${REP_GLPI}

 The default user accounts are:
    USER         -    PASSWORD        -       ACCESS
  glpi           -  ${ADMINGLPIPWD}      -  admin account
  post-only      -  ${POSTGLPIPWD}      -  post-only account
  tech           -  ${TECHGLPIPWD}      -  tech account
  normal         -  ${NORMGLPIPWD}      -  normal account

 You can access the GLPI web page from the following address :
 http://${DB_HOST}

 ==> Database:
 Database host: ${DB_HOST}
 Database port: 3306
 GLPI database name: ${DB_NAME}
 Root password: ${SQLROOTPWD}
 ${DB_USER} password: ${SQLGLPIPWD}

 Backup file saved to ${FICHIER_MSG}
 <===============================================================================================>

 If you encounter a problem with this script, please report it on GitHub : https://github.com/PapyPoc/glpi_install/issues
EOF
	fi
        debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Activé ou déactivé le mode maintenance (1 ou 0)
function maintenance(){ 
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    check_install_user "${REP_GLPI}"
    if [ "$1" == "1" ]; then
        info "${MSG_ACTIVE_SERVICE}"
        sudo -u "${WEB_USER}" php "${REP_GLPI}"bin/console glpi:maintenance:enable
    elif [ "$1" == "0" ]; then
        info "${MSG_DEACTIVE_SERVICE}"
        sudo -u "${WEB_USER}" php "${REP_GLPI}"bin/console glpi:maintenance:disable 1> >(tee -a "${DEBUGFILE}") 2> >(tee -a "${ERRORFILE}" >&2)   
    fi
	sleep 2;
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Sauvegarde de la base de donnée et des fichiers de GLPI
function backup_glpi() {
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    info "=== Démarrage de la sauvegarde GLPI ==="
    # Lecture des informations MySQL
    local DB_NAME PASSWORD
    DB_NAME=$(sed -n 's/.*\(Nom de la base de données GLPI\|GLPI database name\): \([^ ]*\).*/\2/p' "${INVOKING_HOME}/sauve_mdp.txt")
    PASSWORD=$(sed -n 's/.*\(Mot de passe root\|Root password\): \([^ ]*\).*/\2/p' "${INVOKING_HOME}/sauve_mdp.txt")
    if [ -z "${DB_NAME}" ] || [ -z "${PASSWORD}" ]; then
    warn "Impossible de lire le nom de base ou le mot de passe depuis sauve_mdp.txt"
        return 1
    fi
    # Détermination de l’outil de dump
    local MYSQLDUMP_CMD
    MYSQLDUMP_CMD=$(command -v mysqldump 2>/dev/null || command -v mariadb-dump 2>/dev/null || echo mysqldump)
    # Répertoires de sauvegarde
    REP_BACKUP="${INVOKING_HOME}/backup_glpi_$(date +"%Y-%m-%d")"
    BDD_BACKUP="bdd_glpi_$(date +"%Y-%m-%d_%H-%M-%S").sql"
    if ! mkdir -p "${REP_BACKUP}"; then
        warn "Échec de la création du répertoire de sauvegarde : ${REP_BACKUP}"
        return 1
    fi
    # --- Sauvegarde BDD ---
    info "${MSG_MYSQL_DUMP}"
    if eval "${MYSQLDUMP_CMD} -u root -p\"${PASSWORD}\" --databases \"${DB_NAME}\" > \"${REP_BACKUP}/${BDD_BACKUP}\""; then
        info "${MSG_DUMP_SUCCESS}"
    else
    warn "Échec de la sauvegarde de la base ${DB_NAME}"
        return 1
    fi
    # --- Sauvegarde des fichiers ---
    info "${MSG_SITE_COPY}"
    for SRC in "/etc/glpi/config" "/var/lib/glpi/files" "${REP_GLPI}/plugins" "${REP_GLPI}/marketplace" "${REP_GLPI}/inc/downstream.php"; do
        if [ -e "${SRC}" ]; then
            cp -Rf "${SRC}" "${REP_BACKUP}/"
        else
            warn "Source manquante : ${SRC}"
        fi
    done
    info "${MSG_SITE_COPY_OK}"
    # --- Compression ---
    info "${MSG_COMPRESS_BACKUP}"
    mkdir -p "${REP_BACKUP_COMPRESS}"
    local BACKUP_FILE
    BACKUP_FILE="${REP_BACKUP_COMPRESS}/glpi_$(date +"%Y-%m-%d")_${GLPI_CLI_VERSION}->${VERSION_SELECT}.tar.gz"
    if tar -czf "${BACKUP_FILE}" -C "${REP_BACKUP}" . 2>> "${ERRORFILE}"; then
        info "${MSG_COMPRESS_BACKUP_OK} (${BACKUP_FILE})"
        # Vérifier que le fichier compressé n'est pas vide
        if [ ! -s "${BACKUP_FILE}" ]; then
            warn "Fichier de sauvegarde vide, suppression annulée."
            return 1
        fi
        # Suppression sécurisée de l’ancien GLPI
        info "${MSG_REMOVE_OLD_GLPI_DIR}"
        if [ -n "${REP_GLPI}" ] && [ -d "${REP_GLPI}" ]; then
            rm -rf "${REP_GLPI:?}/" >> "${DEBUGFILE}" 2>> "${ERRORFILE}"
            info "Répertoire ${REP_GLPI} supprimé."
        else
            warn "Répertoire GLPI introuvable : ${REP_GLPI}"
        fi
    else
    warn "${MSG_COMPRESS_BACKUP_FAILED}"
        return 1
    fi
    info "=== Sauvegarde GLPI terminée avec succès ==="
    sleep 2
    export REP_BACKUP REP_GLPI
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Mise à jour de GLPI
function update_glpi() {
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    info "=== Début de la mise à jour GLPI ==="
    # Restauration des fichiers de configuration et des plugins
    info "${MSG_RESTORE_FILES}"
    for DIR in config files plugins marketplace; do
        SRC="${REP_BACKUP}/${DIR}"
        if [ -d "${SRC}" ]; then
            case "${DIR}" in
                config) DEST="/etc/glpi/config" ;;
                files) DEST="/var/lib/glpi/files" ;;
                plugins) DEST="${REP_GLPI}/plugins" ;;
                marketplace) DEST="${REP_GLPI}/marketplace" ;;
            esac
            mkdir -p "${DEST}"
            if compgen -G "${SRC}/*" > /dev/null; then
                if cp -Rf "${SRC}/"* "${DEST}/"; then
                    info "Restauration de ${DIR} vers ${DEST} terminée."
                else
                    warn "Erreur lors de la copie de ${DIR}."
                fi
            else
                warn "Répertoire ${SRC} vide, rien à copier."
            fi
        fi
    done
    # Restauration du fichier downstream.php
    REP_BACKUP=$(find "${INVOKING_HOME}" -maxdepth 1 -type d -name "backup_glpi_*")
    info "Restauration du fichier ${REP_BACKUP}/downstream.php si présent."
    info "Vérification de l'existence de ${REP_BACKUP}/downstream.php"
    if [ -f "${REP_BACKUP}/downstream.php" ]; then
        mkdir -p "${REP_GLPI}/inc" 1>> "${DEBUGFILE}" 2>> "${ERRORFILE}"
        if cp -Rf "${REP_BACKUP}/downstream.php" "${REP_GLPI}/inc/" 1>> "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
            info "Fichier downstream.php restauré."
        else
            warn "Erreur lors de la restauration de downstream.php."
        fi
    fi
    # Suppression de la sauvegarde
    info "${MSG_REMOVE_OLD_FILES}"
    if [ -d "${INVOKING_HOME}" ]; then
        if find "${INVOKING_HOME}" -maxdepth 1 -type d -name "backup_glpi_*" -exec rm -rf {} + >> "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
            info "Répertoire ${REP_BACKUP} supprimé avec succès."
        else
            warn "Répertoire ${REP_BACKUP} introuvable."
        fi
    fi
    # Mise à jour de la base GLPI
    info "${MSG_UPDATE_GLPI_DATABASE}"
    debug "Repertoire GLPI pour la mise à jour de la base : ${REP_GLPI}"
    rights_glpi "${REP_GLPI}"
    if check_install_user "${REP_GLPI}"; then
        debug "Repertoire GLPI pour la mise à jour de la base : ${REP_GLPI}"
        debug "Utilisateur web pour la mise à jour de la base : ${WEB_USER}"
        local CMD="${REP_GLPI}/bin/console db:update --force --no-telemetry --quiet --no-interaction"
        # shellcheck disable=SC2086
        if sudo -u "${WEB_USER}" php ${CMD} 1>> "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
            exec 3>&1
            dialog --title "${MSG_TITRE_OK}" --msgbox "Mise à jour de la base GLPI réussie.\n\nProfitez de GLPI ${VERSION_SELECT} !" 7 50
            exec 3>&-
            info "Mise à jour de la base GLPI réussie."
        else
            warn "Échec de la mise à jour de la base GLPI (voir ${ERRORFILE})."
            exec 3>&1
            dialog --title "${MSG_DIALOG_ERROR_TITLE}" --msgbox "Erreur lors de la mise à jour de la base GLPI."
            exec 3>&-
            return 1
        fi
    fi
    # Nettoyage final
    info "${MSG_UPDATE_CLEAN}"
    if find "${REP_GLPI}/install/" -maxdepth 1 -type f -name "install.php" -exec sudo rm -f {} +  ; then
        info "Fichier ${REP_GLPI}/install/install.php supprimé avec succès."
    else
        warn "Impossible de supprimer install.php dans ${REP_GLPI}/install/"
    fi
    info "=== Fin de la mise à jour GLPI ==="
    sleep 2
    debug "$(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}