#!/usr/bin/env bash
#
# GLPI install script
# Author: PapyPoc
# Version: 1.9.0
# Function file
#
# set -Eeuo pipefail
# Ne pas continuer si le script est exécuté directement

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo -e "Ce fichier doit être sourcé, pas exécuté.\n" >&2
    echo -e "This file must be sourced, not executed.\n" >&2
    exit 1
fi
# Affichage d'erreur en rouge
function error(){
    local msg="$1"
    export_display_env
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    #echo -e "${ROUGE}${expanded}${NC}" # Couleur rouge # Affichage à l'écran désactivé
    printf '%s\n' "${expanded}" | tee -a "${ERRORFILE}" >/dev/null
}
# Affichage d'alerte en orange
function warn(){
    local msg="$1"
    export_display_env
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    # echo -e "${ORANGE}${expanded}${NC}" # Couleur orange # Affichage à l'écran désactivé
    printf '%s\n' "${expanded}" | tee -a "${ERRORFILE}" >/dev/null # Affichage dans le fichier d'alerte
}
# Affichage d'information en bleu
function info(){
    local msg="$1"
    export_display_env
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    # echo -e "${CYAN}${expanded}${NC}" # Couleur cyan # Affichage à l'écran désactivé
    printf '%s\n' "${expanded}" | tee -a "${INFOFILE}" >/dev/null # Affichage dans le fichier d'info
}
# Affichage debug en normal
function debug(){
    local msg="$1"
    export_display_env
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    # echo -e "${NC}${expanded}${NC}" # Couleur normale Affichage à l'écran désactivé
    printf '%s\n' "${expanded}" | tee -a "${DEBUGFILE}" >/dev/null # Affichage dans le fichier de debug
}
# Exporter une liste blanche de variables utilisées dans les fichiers de langue pour que envsubst puisse les remplacer
function export_display_env() {
    # Exporter un ensemble complet de variables (majuscules et minuscules)
    # pouvant être référencées comme espaces réservés dans les fichiers de langue.
    # Les valeurs par défaut sont vides si elles ne sont pas définies.
    local vars_maj=(
        ORIG_USER ADMIN_GROUP ID VERSION_ID ID NAME PRETTY_NAME ICON_KO NEW_VERSION REP_GLPI FICHIER_MSG
        ERRORFILE LOGFILE TASK_INDEX TASK_KEY LANGUAGE TIMEZONE IPADRESS INTERFACE DOWNLOADLINK MODE
        DB_USER DB_NAME SQLROOTPWD SQLGLPIPWD ADMINGLPIPWD POSTGLPIPWD TECHGLPIPWD NORMGLPIPWD GLPI_CLI_VERSION
        REP_BACKUP BDD_BACKUP REP_SCRIPT MYSQL_CMD MYSQLDUMP_CMD OUTPUT PHPVERSION DISTRO_ID VERSION_ID
        DEBIAN_VERSIONS UBUNTU_VERSIONS ALMA_VERSIONS CENTOS_VERSIONS ROCKY_VERSIONS REDHAT_VERSIONS MSG_UPGRADE_DISTRO
        NEW_VERSION TAGS VERSION_SELECT TASK_CMD DISTRO_ID VERSION_ID WEB_USER LANG_FILE
        ICON_WARN ICON_INFO ICON_ERROR ICON_DEBUG MSG_ERROR_ON_ERROR_1 MSG_ERROR_ON_ERROR_2 MSG_ERROR_ON_ERROR_3
        MSG_ERROR_ON_ERROR_4 MSG_ERROR_ON_ERROR_5 MSG_ERROR_DIALOG_TITLE MSG_ERROR_DIALOG_ERROR MSG_CHECK_DISTRO_OK
        MSG_CHECK_DISTRO_NONOK MSG_CHECK_DISTRO_FORCE MSG_CHECK_DISTRO_FORCE_QUESTION MSG_CHECK_DISTRO_CONTINUING
        MSG_CHECK_DISTRO_EXITING MSG_CHECK_DISTRO_INVALID MSG_LANG_FILE MSG_LANG_NOT_FOUND MSG_DEBUG_START MSG_DEBUG_END
        INTERFACE INVOKING_HOME REP_BACKUP_COMPRESS API_URL PATHS_TO_CHECK MSG_SCRIPT_NON_INTERACTIVE_DISTRO
    )
    local vars_min=(
        orig_user admin_group id version_id id name pretty_name ICON_KO new_version rep_glpi fichier_msg
        errorfile logfile task_index task_key language timezone ipadress interface downloadlink mode
        db_user db_name sqlrootpwd sqlglpipwd adminglpipwd postglpipwd techglpipwd normglpipwd glpi_cli_version
        rep_backup bdd_backup rep_script mysql_cmd mysqldump_cmd output phpversion distro_id version_id
        debian_versions ubuntu_versions alma_versions centos_versions rocky_versions redhat_versions msg_upgrade_distro
        new_version tags version_select task_cmd distro_id version_id web_user lang_file
        icon_warn icon_info icon_error icon_debug msg_error_on_error_1 msg_error_on_error_2 msg_error_on_error_3
        msg_error_on_error_4 msg_error_on_error_5 msg_error_dialog_title msg_error_dialog_error msg_check_distro_ok
        msg_check_distro_nonok msg_check_distro_force msg_check_distro_force_question msg_check_distro_continuing
        msg_check_distro_exiting msg_check_distro_invalid msg_lang_file msg_lang_not_found msg_debug_start msg_debug_end
        interface invoking_home rep_backup_compress api_url paths_to_check msg_script_non_interactive_distro
    )
    local v _val
    for v in "${vars_maj[@]}" "${vars_min[@]}"; do
        _val="${!v:-}"
        export "$v"="$_val"
    done
}
# Gestion des erreurs avec trap
function on_error() {
    local rc=$?                               # Code de retour de la dernière commande
    local cmd="${BASH_COMMAND}"               # Commande qui a échoué
    local line="${BASH_LINENO[0]}"            # Ligne d’erreur
    local message=""
    message+="${MSG_ERROR_ON_ERROR_1}'${cmd}' (code=${rc})${MSG_ERROR_ON_ERROR_2}${line}\n"
    message+="${MSG_ERROR_ON_ERROR_3}\n"
    # Boucle sur la pile d’appels (stack trace)
    for (( i=${#FUNCNAME[@]}-1; i>=1; i-- )); do
        # i=0 correspond à on_error elle-même → on la saute
        message+="${MSG_ERROR_ON_ERROR_4}${FUNCNAME[$i]}()${MSG_ERROR_ON_ERROR_5}${BASH_SOURCE[$i]}:${BASH_LINENO[$((i-1))]}\n"
    done
    message+="──────────────────────────────"
    # Affichage dans dialog (protéger les retours ligne)
    dialog --backtitle "${MSG_ERROR_DIALOG_TITLE}" \
           --title "${MSG_ERROR_DIALOG_ERROR}" \
           --msgbox "$(echo -e "$message")" 20 100 || true

    # Log du message complet dans les fichiers d’erreur
    error "${ICON_ERROR} $(echo -e "$message")"
    exit "${rc}"
}
# Vérifie si la version est compatible
function compatible() {
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Depuis ${FUNCNAME[1]:-main}"
    local version="$1"
    local -n versions_array="$2"
    [[ ${versions_array[*]} =~ ${version} ]]
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Fin de ${FUNCNAME[1]:-main}"
}
# Vérifie si la distribution est prise en compte pour l'installation de GLPI
function check_distro(){
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Depuis ${FUNCNAME[1]:-main}"
    # Vérifie si le fichier os-release existe
    source_os_release
    # Vérifie si la distribution est basée sur Debian, Ubuntu, Alma Linux, Centos ou Rocky Linux
    if [[ "${ID}" =~ ^(debian|ubuntu|almalinux|centos|rocky|rhel)$ ]]; then
        if [[ "$ID" == "debian" || "$ID" == "ubuntu" ]]; then
            WEB_USER="www-data"
        else
            WEB_USER="nginx"
        fi
        if compatible "${VERSION_ID}" DEBIAN_VERSIONS || compatible "$VERSION_ID" UBUNTU_VERSIONS || compatible "$VERSION_ID" ALMA_VERSIONS || compatible "$VERSION_ID" CENTOS_VERSIONS || compatible "$VERSION_ID" ROCKY_VERSIONS || compatible "$VERSION_ID" REDHAT_VERSIONS; then
            info "${ICON_INFO} ${MSG_CHECK_DISTRO_OK}"
        else
            warn "${ICON_WARN} ${MSG_CHECK_DISTRO_NONOK}"
            warn "${ICON_WARN} ${MSG_CHECK_DISTRO_FORCE}"
            if [ -t 0 ]; then
                info "${ICON_INFO} ${MSG_CHECK_DISTRO_FORCE_QUESTION}"
                read -r RESPONSE
                case $RESPONSE in
                    O|o|Y|y)
                        info "${ICON_INFO} ${MSG_CHECK_DISTRO_CONTINUING}"
                        ;;
                    N|n)
                        info "${ICON_INFO} ${MSG_CHECK_DISTRO_EXITING}"
                        return 1
                        ;;
                    *)
                        warn "${ICON_WARN} ${MSG_CHECK_DISTRO_INVALID_ANSWER}"
                        return 1
                        ;;
                esac
            else
                warn "${ICON_WARN} ${MSG_SCRIPT_NON_INTERACTIVE_DISTRO}"
                return 1
            fi
        fi
        export VERSION_ID ID WEB_USER
    else
        warn "${ICON_WARN} ${MSG_CHECK_DISTRO_INVALID}"
        return 1
    fi
    export VERSION_ID ID WEB_USER
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Depuis ${FUNCNAME[1]:-main}"
}
# Chargement du fichier de langue
function load_language() {
    debug "DEBUG : $(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Depuis ${FUNCNAME[1]:-main}"
    local syslang="${LC_ALL:-${LANG:-}}"
    if [[ $syslang =~ ^fr ]]; then
        LANG_FILE="$REP_SCRIPT/lang/fr_lang.ini"
        LANGUAGE="fr_FR"
    else
        LANG_FILE="$REP_SCRIPT/lang/en_lang.ini"
        LANGUAGE="en_US"
    fi
    if [[ -f $LANG_FILE ]]; then
        # Ensure environment variables used in messages are exported for envsubst
        export_display_env
    # Lire le fichier ligne par ligne, gérer CRLF, commentaires, sections
    # et valeurs entre guillemets
        while IFS= read -r line || [ -n "$line" ]; do
            # supprimer CR si présent (fichiers format Windows)
            line="${line%%$'\r'}"
            # skip empty lines and comments
            # supprimer les espaces de tête
            trimmed="${line#"${line%%[![:space:]]*}"}"
            if [ -z "$trimmed" ]; then
                continue
            fi
            case "$trimmed" in
                "#"* | ";"*)
                    continue
                    ;;
            esac
            # ignorer les entêtes de section
            [[ $line =~ ^[[:space:]]*\[.*\] ]] && continue
            if [[ $line =~ ^[[:space:]]*([^=[:space:]]+)[[:space:]]*=(.*)$ ]]; then
                local key="${BASH_REMATCH[1]}"
                local value="${BASH_REMATCH[2]}"
                # trim leading/trailing whitespace from value
                value="${value#"${value%%[![:space:]]*}"}"
                value="${value%"${value##*[![:space:]]}"}"
                # remove surrounding single or double quotes if present
                if [[ $value =~ ^\'(.*)\'$ ]]; then
                    value="${BASH_REMATCH[1]}"
                elif [[ $value =~ ^\"(.*)\"$ ]]; then
                    value="${BASH_REMATCH[1]}"
                fi
                # Développer les espaces réservés dans la valeur avec envsubst
                # (préféré) ou utiliser eval en secours
                local expanded_value
                if command -v envsubst >/dev/null 2>&1; then
                    # envsubst reads from the environment, so ensure variables are exported
                    expanded_value=$( ( set +u; printf '%s' "$value" | envsubst ) )
                else
                    # fallback : effectuer l'expansion de paramètres en toute sécurité
                    # (autoriser les variables non définies)
                    expanded_value=$( ( set +u; eval "printf '%s' \"$value\"" ) )
                fi
                # affecter en toute sécurité à une variable nommée par $key
                printf -v "$key" '%s' "$expanded_value"
            fi
        done < "$LANG_FILE"
        info "${ICON_INFO} ${MSG_LANG_FILE}"
    else
        warn "${ICON_WARN} ($MSG_LANG_NOT_FOUND)"
    fi
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Fin de ${FUNCNAME[1]:-main}"
}
# Recherche si GLPI est déjà installé
function check_glpi_installed(){
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    FIND_REP_GLPI=$?
    glpi_dirs=()
    # Parcours des répertoires standards à explorer
    for path in ${PATHS_TO_CHECK}; do
        # Recherche des dossiers contenant "glpi" jusqu’à 3 niveaux de profondeur
        FOUND=$(find "${path}" -maxdepth 3 -type d -name "*glpi*" 2>/dev/null)
        # Si un ou plusieurs répertoires sont trouvés, on les ajoute au tableau
        if [[ -n "$FOUND" ]]; then
            # On lit chaque ligne de la sortie de find et on l’ajoute au tableau
            while IFS= read -r dir; do
                glpi_dirs+=("$dir")
            done <<< "$FOUND"
        fi
    done
    #echo "Répertoires GLPI trouvés : ${glpi_dirs[*]}"
    export glpi_dirs FIND_REP_GLPI
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Recherche si des sauvegardes existent
function check_backups_existed(){
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    BACKUP_FOUND="no"
    # Vérifie si le répertoire de sauvegarde existe
    if [[ -d "${REP_BACKUP}" ]]; then
        # Recherche des fichiers de sauvegarde dans le répertoire
        shopt -s nullglob
        backup_files=("${REP_BACKUP}"/*.tar.gz "${REP_BACKUP}"/*.zip)
        shopt -u nullglob
        if [[ ${#backup_files[@]} -gt 0 ]]; then
            BACKUP_FOUND="yes"
        fi
    fi
    export BACKUP_FOUND
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Vérifie l'utilisateur web pour le répertoire GLPI
function check_install_user(){
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    info "${MSG_CHECK_WEB_USER}"
    REP_GLPI="${1:-/var/www/html/glpi}"
    if ! WEB_USER=$(stat -c '%U' "${REP_GLPI}") >/dev/null 2>&1; then
        debug "${ICON_DEBUG} ${MSG_WEB_USER_NOT_FOUND} ${REP_GLPI}."
        return 1
    fi
    debug "${ICON_DEBUG} ${MSG_WEB_USER_FOUND} ${WEB_USER}"
    export WEB_USER REP_GLPI
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Choix entre installation ou mise à jour
function selection_menu(){
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    # Demander à l'utilisateur s'il souhaite installer ou mettre à jour GLPI
    SELECTED_MENU=$(dialog \
        --backtitle "$MSG_INSTALL_UPDATE_BACK_TITLE" \
        --title "${MSG_INSTALL_UPDATE_TITRE}" \
        --radiolist "${MSG_INSTALL_UPDATE_RADIOLIST}" 15 50 3 \
        1 "${MSG_INSTALL_UPDATE_INSTALL}" ON \
        2 "${MSG_INSTALL_UPDATE_UPDATE}" OFF \
        3 "${MSG_INSTALL_UPDATE_BACKUP}" OFF \
        4 "${MSG_INSTALL_UPDATE_BACKUP}" OFF \
        5 "${MSG_INSTALL_UPDATE_BACKUP}" OFF \
        "" "--------------------------------" OFF \
        7 "Sortir" OFF 2>&1 >/dev/tty)
    rc=$?
    export SELECTED_MENU
    if [[ $rc -ne 0 ]]; then
        error "${ICON_ERROR} ${MSG_INSTALL_UPGRADE_CANCELLED}"
        dialog --title "${MSG_DIALOG_TITLE_CANCEL}" --msgbox "${MSG_INSTALL_UPGRADE_CANCELLED}" 7 50
        return 1
    fi
    if [[ $rc == 7 ]]; then
        info "${ICON_INFO} ${MSG_INSTALL_UPGRADE_EXITING}"
        return 100
    fi
    prompt_install_options
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
#  Demander à l'utilisateur de choisir le répertoire d'installation,
# la version de GLPI à installer ou de lancer une installation complète via dialog.
function prompt_install_options(){
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    if [[ "${SELECTED_MENU}" == 1 ]]; then
        tags=""
        # Récupère les tags au format X.Y.Z
        tags=$(curl -s "${API_URL}" | jq -r '.[].name' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | grep -v -E '(rc|beta|alpha)' | sort -Vr | uniq | head -n 16)
        local args=() first=ON number=1 version_map=()
        while IFS= read -r tag; do
            args+=("${tag}" "" "${first}")
            first=OFF
        done <<< "${tags}"
        VERSION_SELECT=$(dialog --backtitle "$MSG_PROMPT_INSTALL_OPTIONS_BACKTITLE_INSTALL" --title "${MSG_PROMPT_INSTALL_OPTIONS_VERSION_TITLE_INSTALL}" \
        --radiolist "${MSG_PROMPT_INSTALL_OPTIONS_VERSION_RADIOLIST_INSTALL}" 23 50 8 "${args[@]}" 2>&1 >/dev/tty)
        local rc=$?
        if [ "${rc}" -ne 0 ]; then
            warn "${ICON_WARN} ${MSG_PROMPT_INSTALL_OPTIONS_ABORT_INSTALL}"
            return 1
        fi
        # Formulaire des options d'installation
        local form="" WIDTH=0
        WIDTH_REP=$(( ${#MSG_PROMPT_INSTALL_OPTIONS_PARAM_REP} ))
        WIDTH_DB_HOST=$(( ${#MSG_PROMPT_INSTALL_OPTIONS_PARAM_DB_HOST} ))
        WIDTH_DB_NAME=$(( ${#MSG_PROMPT_INSTALL_OPTIONS_PARAM_DB_NAME} ))
        WIDTH_DB_USER=$(( ${#MSG_PROMPT_INSTALL_OPTIONS_PARAM_DB_USER} ))
        WIDTH=$(( WIDTH_REP > WIDTH_DB_HOST ? WIDTH_REP : WIDTH_DB_HOST ))
        WIDTH=$(( WIDTH > WIDTH_DB_NAME ? WIDTH : WIDTH_DB_NAME ))
        WIDTH=$(( WIDTH > WIDTH_DB_USER ? WIDTH : WIDTH_DB_USER ))
        WIDTH=$(( WIDTH + 6 ))
        local _def_rep="" rep_glpi="" _def_db_host="" db_host="" _def_db_name="" db_name="" _def_db_user="" db_user=""
        local _def_rep="${REP_GLPI:-/var/www/html/glpi}" _def_db_host="${DB_HOST:-localhost}" _def_db="${DB_NAME:-glpi}" _def_user="${DB_USER:-glpi_user}"
        while true; do
            form=$(dialog --backtitle "$MSG_PROMPT_INSTALL_OPTIONS_BACKTITLE_INSTALL" --title "$MSG_PROMPT_INSTALL_OPTIONS_VERSION_TITLE_INSTALL" \
                --form "${MSG_PROMPT_INSTALL_OPTIONS_VERSION_TITLE_PARAM_1} ${VERSION_SELECT} ${MSG_PROMPT_INSTALL_OPTIONS_VERSION_TITLE_PARAM_2}" 18 68 8 \
                "📁 ${MSG_PROMPT_INSTALL_OPTIONS_PARAM_REP}"     1 2 "${_def_rep}"     1 ${WIDTH} 20 40 \
                "🖥️ ${MSG_PROMPT_INSTALL_OPTIONS_PARAM_DB_HOST}" 3 2 "${_def_db_host}" 3 ${WIDTH} 20 20 \
                "🗄️ ${MSG_PROMPT_INSTALL_OPTIONS_PARAM_DB_NAME}" 5 2 "${_def_db}"      5 ${WIDTH} 20 20 \
                "👤 ${MSG_PROMPT_INSTALL_OPTIONS_PARAM_DB_USER}" 7 2 "${_def_user}"    7 ${WIDTH} 20 20 \
                2>&1 >/dev/tty)
            rc=$?
            # Transformer les lignes du formulaire en variables
            IFS=$'\n' read -r rep_glpi db_host db_name db_user <<< "$form"
            rep_glpi="${rep_glpi#"${rep_glpi%%[![:space:]]*}"}"; rep_glpi="${rep_glpi%"${rep_glpi##*[![:space:]]}"}"
            db_host="${db_host#"${db_host%%[![:space:]]*}"}"; db_host="${db_host%"${db_host##*[![:space:]]}"}"
            db_name="${db_name#"${db_name%%[![:space:]]*}"}"; db_name="${db_name%"${db_name##*[![:space:]]}"}"
            db_user="${db_user#"${db_user%%[![:space:]]*}"}"; db_user="${db_user%"${db_user##*[![:space:]]}"}"
            rep_glpi="${rep_glpi//[^A-Za-z0-9_\/.-]/_}"
            db_host="${db_host//[^A-Za-z0-9_\/.-]/_}"
            db_name="${db_name//[^A-Za-z0-9_]/_}"
            db_user="${db_user//[^A-Za-z0-9_]/_}"
            [ -z "$rep_glpi" ] && rep_glpi="$_def_rep"
            [ -z "$db_host" ] && db_host="$_def_db_host"
            [ -z "$db_name" ] && db_name="$_def_db"
            [ -z "$db_user" ] && db_user="$_def_user"
            if [[ ! "$db_name" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
                db_name="glpi_${db_name}"
            fi
            rep_glpi="${rep_glpi//\\//}"
            if [ -z "${rep_glpi}" ] || [[ "${rep_glpi}" != /* ]]; then
                rep_glpi="${_def_rep}"
            fi
            rep_glpi="$(printf '%s' "${rep_glpi}" | sed -E 's#/{2,}#/#g')"
            REP_GLPI="${rep_glpi%/}/"
            DB_HOST="$db_host"
            DB_NAME="$db_name"
            DB_USER="$db_user"
            # Si annulation ou ESC
            if [[ $rc -ne 0 ]]; then
                warn "${ICON_WARN} ${MSG_PROMPT_INSTALL_OPTIONS_ABORT_INSTALL}"
                form=$(dialog --title "${MSG_PROMPT_INSTALL_OPTIONS_BACKTITLE_INSTALL}" --msgbox "${MSG_PROMPT_INSTALL_OPTIONS_ABORT_INSTALL}" 7 60 2>&1 >/dev/tty)
                exit 1
            fi
            # --- VALIDATIONS ---
            # Répertoire d’installation
            if ! validate_glpi_path "$REP_GLPI"; then
                continue
            fi
            # Hôte de la base de données
            if ! validate_db_host "$DB_HOST"; then
                continue
            fi
            # Nom de la base de données
            if ! validate_db_name "$DB_NAME"; then
                continue
            fi
            # Utilisateur de la base de données
            if ! validate_db_user "$DB_USER"; then
                continue
            fi
            # Si tout est valide
            break
        done
        # Assignation des valeurs finales
        local DOWNLOADLINK="https://github.com/glpi-project/glpi/releases/download/${VERSION_SELECT}/glpi-${VERSION_SELECT}.tgz"
        export DOWNLOADLINK DB_HOST REP_GLPI DB_NAME DB_USER INVOKING_HOME TIMEZONE VERSION_SELECT
        # Lancement de l’installation
        run_sequence "install"
    elif [[ "${SELECTED_MENU}" == 2 ]]; then
        check_glpi_installed
        # Si au moins un répertoire GLPI trouvé, demander à l'utilisateur de choisir
        if [[ "${#glpi_dirs[@]}" -gt 0 ]]; then
            # Préparer les arguments pour dialog
            find_rep=()
            rep_map=()
            number=1
            first="ON"
            # Correction : boucle while → for (syntaxe correcte)
            for dir in "${glpi_dirs[@]}"; do
                find_rep+=("${number}" "${dir}" "${first}")
                rep_map+=("${dir}")
                first="OFF"
                ((number++))
            done
            # Vérification utilisateur/distro avant exécution
            if check_install_user "${REP_GLPI}"; then
                GLPI_CLI_VERSION=$(sudo -u "${WEB_USER}" php "${REP_GLPI}/bin/console" --no-ansi --version 2>/dev/null | awk '{print $3}' || true)
            fi
            # Récupération des versions GLPI disponibles sur GitHub
            tags=""
            # Récupère les tags au format X.Y.Z
            tags=$(curl -s "${API_URL}" | jq -r '.[].name' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | grep -v -E '(rc|beta|alpha)' | sort -Vr | uniq | head -n 16)
            # Filtrage : ne garder que les versions avant GLPI_CLI_VERSION (donc plus récentes) ---
            newer_tags=()
            for tag in ${tags}; do
                if [[ "${tag}" == "${GLPI_CLI_VERSION}" ]]; then
                    break  # On s'arrête dès qu'on atteint la version installée
                fi
                newer_tags+=("${tag}")
            done
            # Préparation du menu de sélection de version GLPI
            tag=""; find_version=(); version_map=(); number=1; first="ON"
            for tag in "${newer_tags[@]}"; do
                find_version+=("" "GLPI ${tag}" "${first}")
                version_map+=("${tag}")
                first="OFF"
                ((number++))
            done
            # Menu de sélection d’installation GLPI
            FIND_REP_GLPI=$(dialog \
                --backtitle "$MSG_PROMPT_INSTALL_OPTIONS_BACKTITLE_UPDATE" \
                --title "${MSG_PROMPT_INSTALL_OPTIONS_DIR_TITLE_UPDATE}" \
                --radiolist "${MSG_PROMPT_INSTALL_OPTIONS_DIR_RADIOLIST_UPDATE}" 20 70 8 \
                "${find_rep[@]}"  2>&1 >/dev/tty)
            rc=$?
            # Convertir le numéro choisi en index du tableau (0-based)
            local index=""
            index=$((FIND_REP_GLPI - 1))
            # Récupérer le vrai chemin correspondant
            REP_GLPI="${rep_map[$index]}"
            if [[ $rc -ne 0 ]]; then
                warn "${ICON_WARN} Sélection du répertoire d'installation GLPI annulée par l'utilisateur." | tee -a "${DEBUGFILE}"
                form=$(dialog --title "Annulation" --msgbox "Installation annulée par l'utilisateur." 7 50 2>&1 >/dev/tty)
                return 1
            fi
            # Sélecteur de version GLPI
            VERSION_SELECT=$(dialog \
                --backtitle "$MSG_PROMPT_INSTALL_OPTIONS_BACKTITLE_UPDATE" \
                --title "${MSG_PROMPT_INSTALL_OPTIONS_VERSION_TITLE_UPDATE}" \
                --radiolist "${MSG_PROMPT_INSTALL_OPTIONS_VERSION_RADIOLIST_UPDATE}" 23 50 8 \
                "${find_version[@]}" 2>&1 >/dev/tty)
            rc=$?
            if [[ "${rc}" -ne 0 ]]; then
                warn "${ICON_WARN} Sélection de la version annulée."
                return 1
            fi
            # Convertir le numéro choisi en index du tableau (0-based)
            local index=""
            index=$((VERSION_SELECT - 1))
            # Récupérer le vrai tag correspondant
            VERSION_SELECT="${version_map[$index]}"
            form=$(dialog --title "${MSG_INFO}" --msgbox "${MSG_PROMPT_INSTALL_OPTIONS_VERSION_MSG_UPDATE}" 10 100 2>&1 >/dev/tty)
            export DOWNLOADLINK="https://github.com/glpi-project/glpi/releases/download/${VERSION_SELECT}/glpi-${VERSION_SELECT}.tgz"
            export VERSION_SELECT REP_GLPI DOWNLOADLINK REP_BACKUP_COMPRESS INVOKING_HOME GLPI_CLI_VERSION
            # Lancement de la mise à jour
            run_sequence "update"
        fi
    elif [[ "${SELECTED_MENU}" == 3 ]]; then
        check_glpi_installed
        # Si au moins un répertoire GLPI trouvé, demander à l'utilisateur de choisir
        if [[ "${#glpi_dirs[*]}" -gt 0 ]]; then
            # Préparer les arguments pour dialog
            find_rep=()
            rep_map=()
            number=1
            first="ON"
            for dir in "${glpi_dirs[@]}"; do
                find_rep+=("${number}" "${dir}" "${first}")
                rep_map+=("${dir}")
                first="OFF"
                ((number++))
            done
            # Sélecteur de répertoire GLPI pour sauvegarde
            FIND_REP_GLPI=$(dialog \
                --backtitle "$MSG_PROMPT_INSTALL_OPTIONS_BACKUP_BACKTITLE" \
                --title "${MSG_PROMPT_INSTALL_OPTIONS_BACKUP_TITLE}" \
                --radiolist "${MSG_PROMPT_INSTALL_OPTIONS_BACKUP_RADIOLIST}" 20 70 8 \
                "${find_rep[@]}" 2>&1 >/dev/tty)
            rc=$?
            # Convertir le numéro choisi en index du tableau (0-based)
            local index=""
            index=$((FIND_REP_GLPI - 1))
            # Récupérer le vrai chemin correspondant
            REP_GLPI="${rep_map[$index]}"
            if [[ $rc -ne 0 ]]; then
                warn "${ICON_WARN} Sélection du répertoire d'installation GLPI annulée par l'utilisateur."
                form=$(dialog --title "Annulation" --msgbox "Sauvegarde annulée par l'utilisateur." 7 50 2>&1 >/dev/tty)
                return 1
            fi
            export REP_GLPI INVOKING_HOME REP_BACKUP_COMPRESS
            # Lancement de la sauvegarde
            run_sequence "backup"
        fi
    elif [[ "${SELECTED_MENU}" == 4 ]]; then
        # Recherche dans le répertoire de sauvegardes
        check_backups_existed
        if [[ "${BACKUP_FOUND}" == "yes" ]]; then
            prompt_restore_options
        fi
    elif [[ "${SELECTED_MENU}" == 5 ]]; then
        # Recherche dans le répertoire de sauvegardes
        check_backups_existed
        # Si au moins un fichier de sauvegarde trouvé, demander à l'utilisateur de choisir
        if [[ "${#backup_files[@]}" -gt 0 ]]; then
            # Préparer les arguments pour dialog
            find_bck=()
            rep_map=()
            number=1
            first="ON"
            for dir in "${backup_files[@]}"; do
                find_bck+=("${number}" "${dir}" "${first}")
                rep_map+=("${dir}")
                first="OFF"
                ((number++))
            done
            # Sélecteur de répertoire GLPI pour restauration
            FIND_REP_GLPI=$(dialog \
                --backtitle "$MSG_PROMPT_INSTALL_OPTIONS_RESTORE_BACKTITLE" \
                --title "${MSG_PROMPT_INSTALL_OPTIONS_RESTORE_TITLE}" \
                --radiolist "${MSG_PROMPT_INSTALL_OPTIONS_RESTORE_RADIOLIST}" 20 70 8 \
                "${find_bck[@]}" 2>&1 >/dev/tty)
            rc=$?
            # Convertir le numéro choisi en index du tableau (0-based)
            local index=""
            index=$((FIND_REP_GLPI - 1))
            # Récupérer le vrai chemin correspondant
            REP_GLPI="${rep_map[$index]}"
            if [[ $rc -ne 0 ]]; then
                warn "${ICON_WARN} Sélection du répertoire d'installation GLPI annulée par l'utilisateur."
                form=$(dialog --title "Annulation" --msgbox "Restauration annulée par l'utilisateur." 7 50 2>&1 >/dev/tty)
                return 1
            fi
            export REP_GLPI INVOKING_HOME REP_BACKUP_COMPRESS
            # Lancement de la restauration
            run_sequence "restore"      
        fi
    else
        warn "${ICON_WARN} Option d'installation/mise à jour invalide."
        return 1
    fi
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Valide le répertoire d’installation de GLPI
function validate_glpi_path() {
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    local path="$1"
    local clean_path
    # Nettoyage
    clean_path="$(printf '%s' "$path" | tr -d '\r\n' | sed -E 's#/{2,}#/#g' \
        | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    # Vérification du format
    if ! [[ "$clean_path" =~ ^(/var/www|/srv|/opt|/usr/share)/[^[:space:]]*glpi[^[:space:]]*$ ]]; then
        dialog --title "${MSG_VALIDATE_GLPI_PATH_DIALOG_TITLE}" --msgbox "${MSG_VALIDATE_GLPI_PATH_DIALOG_FAILED_1} ${clean_path}${MSG_VALIDATE_GLPI_PATH_DIALOG_FAILED_2}" 12 70
        warn "${ICON_WARN} ${MSG_VALIDATE_GLPI_PATH_FAILED} (${clean_path})"
        return 1
    fi
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Valide le répertoire d’installation de GLPI
function validate_db_host() {
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    host=$1
    # Nettoyage de base
    clean_host=$(printf '%s' "$host" | tr -d '\r' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
    # Cas simples
    case "$clean_host" in
        localhost|::1|\[::1\])
            return 0 ;;
    esac
    # Vérif IPv4 (structure correcte)
    if printf '%s\n' "${clean_host}" | grep -Eq '^([0-9]{1,3}\.){3}[0-9]{1,3}$'; then
        IFS=.
        set -- "${clean_host}"
        for o in "$@"; do
            case $o in
                *[!0-9]*) dbhost_err "${clean_host}"; return 1 ;;
            esac
            [ "$o" -ge 0 ] 2>/dev/null && [ "$o" -le 255 ] 2>/dev/null || {
                dbhost_err "${clean_host}"; return 1;
            }
        done
        return 0
    fi
    # Vérif nom de domaine (FQDN simple)
    if printf '%s\n' "${clean_host}" | grep -Eq '^([A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?\.)+[A-Za-z]{2,}$'; then
        return 0
    fi
    # Sinon invalide
    dbhost_err "${clean_host}"
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Helper message d'erreur + log
function dbhost_err() {
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    v=$1
    dialog --title "${MSG_VALIDATE_DB_HOST_DIALOG_TITLE}" --msgbox "${MSG_VALIDATE_DB_HOST_DIALOG_FAILED_1} ${v}${MSG_VALIDATE_DB_HOST_DIALOG_FAILED_2}" 10 70
    warn "${ICON_WARN} ${MSG_VALIDATE_DB_HOST_FAILED} (${v})"
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Valide le nom de la base de données
function validate_db_name() {
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    local name="$1"
    local clean_name
    clean_name="$(printf '%s' "$name" | tr -d '\r\n' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    # Vérifier si la base de données est déjà utiliser dans les fichiers de sauvegarde
    if find "${INVOKING_HOME}" -name "${FICHIER_MSG}${clean_name}*" -print -quit | grep -q .; then
        dialog --title --msgbox "${MSG_VALIDATE_DB_NAME_DIALOG_FAILED_1} ${clean_name}${MSG_VALIDATE_DB_NAME_DIALOG_FAILED_2}" 12 70
        warn "${ICON_WARN} ${MSG_VALIDATE_DB_NAME_FAILED_1} (${clean_name})"
        return 1
    fi
    if [[ ! "$clean_name" =~ ^[A-Za-z_][A-Za-z0-9_]{0,63}$ ]]; then
        dialog --msgbox "${MSG_VALIDATE_DB_NAME_DIALOG_FAILED_3} ${clean_name}${MSG_VALIDATE_DB_NAME_DIALOG_FAILED_4}" 12 70
        warn "${ICON_WARN} ${MSG_VALIDATE_DB_NAME_FAILED_2} (${clean_name})"
        return 1
    fi
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Valide le nom d’utilisateur de la base de données
function validate_db_user() {
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    local user="$1"
    local clean_user
    clean_user="$(printf '%s' "$user" | tr -d '\r\n' \
        | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    if [[ "$clean_user" == "root" || ! "$clean_user" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
        dialog --msgbox "${ICON_WARN} ${MSG_VALIDATE_DB_USER_DIALOG_FAILED}" 12 70
        warn "${ICON_WARN} ${MSG_VALIDATE_DB_USER_FAILED} (${clean_user})"
        debug "${ICON_DEBUG} ${ICON_KO} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
        return 1
    fi
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Sequence principale d'installation et de mise à jour de GLPI
function run_sequence() {
    trap 'on_error' ERR
    local mode="$1"
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    declare -A tasks
    local task_order=()
    # --- Sélection du mode ---
    case "${mode}" in
        install)
            tasks=(
                ["${MSG_T01}"]="update_distro"
                ["${MSG_T02}"]="install_packages"
                ["${MSG_T03}"]="network_info"
                ["${MSG_T04}"]="mariadb_configure"
                ["${MSG_T05} ${VERSION_SELECT}"]="download_untar_glpi"
                ["${MSG_T06} ${VERSION_SELECT}"]="setup_glpi"
                ["${MSG_T07}"]="maj_user_glpi"
                ["${MSG_T08}"]="write_credentials"
            )
            task_order=(
                "${MSG_T01}" "${MSG_T02}" "${MSG_T03}" "${MSG_T04}" "${MSG_T05}" "${MSG_T06}" "${MSG_T07}" "${MSG_T08}"
            )
            ;;
        update)
            tasks=(
                ["${MSG_T20}"]="maintenance 1"
                ["${MSG_T21}"]="update_distro"
                ["${MSG_T22}"]="backup_glpi"
                ["${MSG_T23}"]="remove_old_glpi"
                ["${MSG_T24}"]="download_untar_glpi"
                ["${MSG_T25}"]="update_glpi"
                ["${MSG_T26}"]="maintenance 0"
            )
            task_order=(
                "${MSG_T20}" "${MSG_T21}" "${MSG_T22}" "${MSG_T23}" "${MSG_T24}" "${MSG_T25}"
            )
            ;;
        backup)
            tasks=(
                ["${MSG_T30}"]="backup_glpi"
            )
            task_order=(
                "${MSG_T30}"
            )
            ;;
        *)
            warn "${ICON_WARN} ${MSG_RUN_SEQUENCE_UNKNOWN_MODE}"
            return 1
            ;;
    esac
    # --- Initialisation ---
    local total_tasks=${#task_order[@]}
    local task_index=0
    (
    for task_key in "${task_order[@]}"; do
        ((task_index++))
        local progress=$((task_index * 100 / total_tasks))
        local task_cmd="${tasks[${task_key}]}"
        # --- Affichage dans la jauge ---
        echo "${progress}"
        echo "XXX"
        echo "${task_index}/${total_tasks} - ${task_key} ⏳"
        echo "XXX"
        debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG] ${ICON_OK} ${MSG_RUN_SEQUENCE_START} ${mode} - '${task_key}' → ${task_cmd}"
        # --- Exécution de la tâche ---
        if run_task "${task_key}" "${task_cmd}" "${task_index}" "${total_tasks}" >/dev/null 2>&1; then
            echo "${progress}"
            echo "XXX"
            echo "${task_index}/${total_tasks} - ${task_key} ${ICON_VALIDATE}"
            echo "XXX"
            debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG] ${ICON_VALIDATE} ${MSG_RUN_SEQUENCE_END} ${mode} - '${task_key}'."
            sleep 0.5  # légère pause visuelle
        else
            echo "100"
            echo "XXX"
            echo "${task_index}/${total_tasks} - ${task_key} ${ICON_KO}"
            echo "XXX"

            debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG] ${ICON_KO} ${MSG_RUN_SEQUENCE_END} ${mode} - '${task_key}'."
            sleep 3
            exit 1  # << plus sûr que return dans un sous-shell
        fi
    done
) | dialog --clear \
           --backtitle "${MSG_RUN_SEQUENCE_BACKTITLE}" \
           --title "${MSG_RUN_SEQUENCE_GAUGE_TITLE}" \
           --gauge "" 8 120 /dev/tty 2>&1
# --- Vérification du sous-shell ---
if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
    warn "${ICON_WARN} ${MSG_RUN_SEQUENCE_FAILED_MODE} (${mode})"
    debug "${ICON_DEBUG} ${ICON_KO} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appelée par ${FUNCNAME[1]:-main}"
    return 1
fi
    info "${ICON_INFO} ${MSG_RUN_SEQUENCE_END}"
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Exécute une tâche individuelle
function run_task() {
    trap 'on_error' ERR
    local task_key="$1" task_cmd="$2" index="$3" total="$4"
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    debug "${ICON_INFO} ${MSG_RUN_TASK_COMMAND} ${task_cmd}" ${task_key}/${total}
    # Exécution isolée
    local output exit_code
    output=$(eval "${task_cmd}" 2>&1)
    exit_code=$?
    if (( exit_code == 0 )); then
        debug "${ICON_DEBUG} ${task_key} - ✅ ${MSG_RUN_TASK_SUCCESS_END} - '${task_cmd}'"
        [[ -n "${output}" ]] && debug "↳ ${output}"
    else
        warn "${ICON_WARN} ${task_key} - ❌ ${MSG_RUN_TASK_FAILED_END} - '${task_cmd}' -> (exit=${exit_code})"
        [[ -n "${output}" ]] && warn "↳ ${output}"
        return ${exit_code}
    fi
    debug "${ICON_DEBUG} ${MSG_TASK_END} ${FUNCNAME[0]} → ${task_key}"
}
# Mise à jour de la distribution
function update_distro(){
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    if [[ "${ID}" =~ ^(debian|ubuntu)$ ]]; then
           info "${ICON_INFO} ${MSG_UPDATE_DISTRO_START}"
           timedatectl set-ntp true # Synchronise l'heure
           sleep 5
           apt-get update && apt-get upgrade -y >> "${UPDATEFILE}" 2>> "${ERRORFILE}"
    elif [[ "${ID}" =~ ^(almalinux|centos|rocky|rhel)$ ]]; then
           info "${ICON_INFO} ${MSG_UPDATE_DISTRO_START}"
           chronyc makestep # Synchronise l'heure
           sleep 5
           yum update -y && yum upgrade -y >> "${UPDATEFILE}" 2>> "${ERRORFILE}"
    else
        warn "${ICON_WARN} ${MSG_UPDATE_DISTRO_NOT_SUPPORTED}"
        exit 1
    fi
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Adresse IP de la machine
function network_info() {
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    # Détection de l’interface principale (hors loopback et interfaces virtuelles)
    INTERFACE=$(ip route get 1.1.1.1 2>/dev/null | awk '/dev/ {print $5; exit}')
    if [[ -z "${INTERFACE}" ]]; then
        INTERFACE=$(ip -o link show | awk -F': ' '!/lo|docker|vir|veth/ {print $2; exit}')
    fi
    # Récupération de l’adresse IP associée
    IPADRESS=$(ip -4 addr show "${INTERFACE}" 2>/dev/null | awk '/inet / {print $2}' | cut -d'/' -f1 | head -n1)
    # Vérification et export
    if [[ -n "${IPADRESS}" ]]; then
        # Adresse IP valide trouvée
        info "${ICON_INFO} ${MSG_NETWORK_INFO_INTERFACE} ${INTERFACE}, ${MSG_NETWORK_INFO_IP} : ${IPADRESS}"
        export IPADRESS
    else
        # Aucune adresse IP valide trouvée
        warn "${ICON_WARN} ${MSG_NETWORK_INFO_IP_NOT_FOUND}"
        IPADRESS="127.0.0.1"
        export IPADRESS
    fi
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Installation des éléments nécessaire
function install_packages(){
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    info "${ICON_INFO} ${MSG_INSTALL_PACKAGES_START}"
    source_os_release
    if [[ "${ID:-}" =~ ^(debian|ubuntu)$ ]]; then
        export DEBIAN_FRONTEND=noninteractive
        # update cache first
        debug "${ICON_DEBUG}: apt-get update"
        if command -v sudo apt-get update | sudo tee -a "${UPDATEFILE}" 2> >(sudo tee -a "${ERRORFILE}" >&2); then
            debug "${ICON_DEBUG}: apt-get upgrade -y"
            if ! sudo apt-get upgrade -y | sudo tee -a "${UPDATEFILE}" 2> >(sudo tee -a "${ERRORFILE}" >&2); then
                warn "${ICON_WARN} ${MSG_INSTALL_PACKAGES_UPGRADE_FAILED}"
            fi
        fi
        if ! sudo apt-get install -y php-{bcmath,mysql,mbstring,curl,gd,xml,intl,ldap,apcu,opcache,xmlrpc,zip,bz2} | sudo tee -a "${UPDATEFILE}" 2> >(sudo tee -a "${ERRORFILE}" >&2); then
            error "${ICON_ERROR} ${MSG_INSTALL_PHP_EXTENSIONS_FAILED}"
            return 1
        else
            info "${ICON_INFO} ${MSG_INSTALL_PHP_EXTENSIONS_COMPLETED}"
        fi
        if ! sudo apt-get install -y wget tar apache2 apache2-bin mariadb-server mariadb-client perl php | sudo tee -a "${UPDATEFILE}" 2> >(sudo tee -a "${ERRORFILE}" >&2); then
            error "${ICON_ERROR} ${MSG_INSTALL_SERVICES_FAILED}"
            return 1
        else
            info "${ICON_INFO} ${MSG_INSTALL_SERVICES_COMPLETED}"
        fi
        manage_service "mariadb" "MariaDB" || return 1
        manage_service "apache2" "Apache2" || return 1
    fi
    if [[ "${ID:-}" =~ ^(almalinux|centos|rocky|rhel|fedora)$ ]]; then
        sudo dnf makecache --refresh
        if ! command -v dnf >/dev/null 2>&1; then
            error "${ICON_ERROR} ${MSG_INSTALL_PACKAGES_DNF_NOT_FOUND}" | tee -a "${ERRORFILE}"
            return 1
        fi
        if sudo dnf makecache --refresh \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "${ICON_INFO} ${MSG_INSTALL_PACKAGES_DNF_CACHE_REFRESHED}"
        else
            error "${ICON_ERROR} ${MSG_INSTALL_PACKAGES_DNF_CACHE_REFRESHED_FAILED}"
        fi
        if sudo dnf install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "${ICON_OK} ${MSG_INSTALL_PACKAGES_EPEL}"
        else
            error "${ICON_ERR} ${MSG_INSTALL_PACKAGES_EPEL_FAILED}"
            return 1
        fi
        if sudo dnf module reset -y php nginx mariadb composer \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "${ICON_OK} ${MSG_INSTALL_PACKAGES_MODULES_RESET}"
        else
            error "${ICON_ERROR} ${MSG_INSTALL_PACKAGES_MODULES_RESET_FAILED}"
            return 1
        fi
        if sudo dnf module install -y php:8.2 \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "${ICON_OK} ${MSG_INSTALL_PACKAGES_PHP}"
        else
            error "${ICON_ERROR} ${MSG_INSTALL_PACKAGES_PHP_FAILED}"
            return 1
        fi
        if sudo dnf module install -y nginx:1.24 \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "${ICON_OK} ${MSG_INSTALL_PACKAGES_NGINX}"
        else
            error "${ICON_ERROR} ${MSG_INSTALL_PACKAGES_NGINX_FAILED}"
            return 1
        fi
        if sudo dnf module install -y mariadb:10.11 \
                | sudo tee -a "${DEBUGFILE}" \
                2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "${ICON_OK} ${MSG_INSTALL_PACKAGES_MARIADB}"
        else
            error "${ICON_ERROR} ${MSG_INSTALL_PACKAGES_MARIADB_FAILED}"
            return 1
        fi
        if sudo dnf install -y dnf-automatic \
                | sudo tee -a "${DEBUGFILE}" \
                2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "${ICON_OK} ${MSG_INSTALL_PACKAGES_AUTO_UPDATES}"
        else
            error "${ICON_ERROR} ${MSG_INSTALL_PACKAGES_AUTO_UPDATES_FAILED}"
            return 1
        fi
        sed -i 's/^\s*;\?\s*\(apply_updates\s*=\s*\).*/\1yes/' /etc/dnf/automatic.conf
        sed -i 's/^\s*;\?\s*\(reboot\s*=\s*\).*/\1when-needed/' /etc/dnf/automatic.conf
        sed -i 's/^\s*;\?\s*\(upgrade_type\s*=\s*\).*/\1security/' /etc/dnf/automatic.conf
        if sudo mkdir -p /etc/systemd/system/dnf-automatic.timer.d | sudo tee -a "${DEBUGFILE}" 2>>"${ERRORFILE}"; then
            info "${ICON_OK} ${MSG_INSTALL_PACKAGES_DNF_AUTO_DIR}"
        else
            warn "${ICON_WARN} ${MSG_INSTALL_PACKAGES_DNF_AUTO_DIR_FAILED}"
            return 1
        fi
        sudo tee /etc/systemd/system/dnf-automatic.timer.d/override.conf <<'EOF'
[Unit]
    Description=dnf-automatic timer
    ConditionPathExists=!/run/ostree-booted
    Wants=network-online.target

[Timer]
    OnCalendar=*-*-* 6:00
    RandomizedDelaySec=60m
    Persistent=true
EOF
        info "${ICON_OK} ${MSG_INSTALL_PACKAGES_DNF_AUTO_OVERRIDE}"
        if systemctl enable --now dnf-automatic.timer; then
            info "${ICON_INFO} ${MSG_INSTALL_PACKAGES_DNF_AUTO_ACTIVATED}"
        else
            warn "${ICON_WARN} ${MSG_INSTALL_PACKAGES_DNF_AUTO_ACTIVATED_FAILED}"
            return 1
        fi
        info "${ICON_INFO} ${MSG_INSTALL_PACKAGES_INSTALL_EXT_PHP}"
        if ! dnf install -y php-{bcmath,mysql,mbstring,curl,gd,xml,intl,ldap,apcu,opcache,xmlrpc,zip,bz2}; then
            warn "${ICON_WARN} ${MSG_INSTALL_PACKAGES_PHP_EXT_FAILED}"
            return 1
        fi
        info "${ICON_INFO} ${MSG_INSTALL_PACKAGES_INSTALL_SERVICE_LAMP}"
        if ! dnf install -y crontabs logrotate cronie tar nginx mariadb-server mariadb perl curl jq php epel-release; then
            warn "${ICON_WARN} ${MSG_INSTALL_PACKAGES_INSTALL_SERVICES_FAILED}"
            return 1
        fi
        sed -i 's/^\(;\?\)\(user =\).*/\2 nginx/' /etc/php-fpm.d/www.conf
        sed -i 's/^\(;\?\)\(group =\).*/\2 nginx/' /etc/php-fpm.d/www.conf
        if systemctl enable --now mariadb nginx php-fpm; then
            info "${ICON_INFO} ${MSG_INSTALL_PACKAGES_SERVICES_STARTED}"
        else
            warn "${ICON_WARN} ${MSG_INSTALL_PACKAGES_SERVICES_START_WEB_FAILED}"
            return 1
        fi
        if firewall-cmd --permanent --zone=public --add-service=http && firewall-cmd --reload; then
            info "${ICON_INFO} ${MSG_INSTALL_PACKAGES_FIREWALL_OK}"
        else
            warn "${ICON_WARN} ${MSG_INSTALL_PACKAGES_FIREWALL_FAILED}"
            return 1
        fi
    fi
    info "${ICON_INFO} ${MSG_INSTALL_PACKAGES_END}"
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
function manage_service() {
    local service="$1"
    local label="$2"
    info "${ICON_INFO} ${MSG_MANAGE_SERVICE_START} ${label}..."
    # Activer et redémarrer le service avec journalisation
    {
        systemctl enable "${service}"
        systemctl restart "${service}"
    } || {
        error "${ICON_ERROR} ${MSG_MANAGE_SERVICE_FAILED} ${label}."
        return 1
    }
    # Vérifier l'état du service
    if systemctl is-active --quiet "${service}"; then
        info "${ICON_OK} ${MSG_MANAGE_SERVICE_OK} ${label}."
    else
        warn "${ICON_WARN} ${MSG_MANAGE_SERVICE_INACTIVE} ${label}."
        # Forcer le redémarrage une seconde fois
        {
            systemctl restart "${service}"
        } || {
            error "${ICON_ERROR} ${MSG_MANAGE_SERVICE_INACTIVE_FAILED} ${label}."
            return 1
        }
        # Vérifier à nouveau l'état du service
        if systemctl is-active --quiet "${service}"; then
            info "${ICON_OK} ${MSG_MANAGE_SERVICE_INACTIVE_OK} ${label}."
        else
            error "${ICON_ERROR} ${MSG_MANAGE_SERVICE_STILL_INACTIVE} ${label}."
            return 1
        fi
    fi
}
# Détection du fuseau horaire système
function get_timezone() {
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Début de ${FUNCNAME[0]:-main}] Appelée par ${FUNCNAME[1]:-main}]"
    info "${ICON_INFO} ${MSG_DETECT_TIMEZONE:-Détection du fuseau horaire...}"
    # Si TIMEZONES n’est pas encore défini
    if [ -z "${TIMEZONES:-}" ]; then
        local tzfile=""
        if command -v timedatectl >/dev/null 2>&1; then # timedatectl (méthode la plus fiable)
            TIMEZONES=$(timedatectl show -p Timezone --value 2>/dev/null || true)
        fi
        if [ -z "${TIMEZONES:-}" ] && [ -f /etc/timezone ]; then # Fichier /etc/timezone (Debian/Ubuntu)
            TIMEZONES=$(head -n 1 /etc/timezone 2>/dev/null || true)
        fi
        if [ -z "${TIMEZONES:-}" ]; then # Lien symbolique /etc/localtime (méthode universelle)
            if [ -L /etc/localtime ] || [ -f /etc/localtime ]; then
                tzfile=$(readlink -f /etc/localtime 2>/dev/null || true)
                if [[ "$tzfile" == *"/usr/share/zoneinfo/"* ]]; then
                    TIMEZONES="${tzfile#*/usr/share/zoneinfo/}"
                fi
            fi
        fi
        if [ -z "${TIMEZONES:-}" ] && [ -f /etc/sysconfig/clock ]; then # /etc/sysconfig/clock (RHEL / CentOS)
            TIMEZONES=$(awk -F= '/^ZONE/ {gsub(/"/,"",$2); print $2}' /etc/sysconfig/clock 2>/dev/null || true)
        fi
        if [ -z "${TIMEZONES:-}" ]; then # Par défaut si rien trouvé
            TIMEZONES="UTC"
        fi
        TIMEZONES="$(echo "${TIMEZONES}" | xargs)"
        export TIMEZONES
        info "${ICON_OK} ${MSG_GET_TIMEZONE_DETECTED} ${TIMEZONES}"
    else
        info "${ICON_INFO} ${MSG_GET_TIMEZONE_ALREADY_SET} ${TIMEZONES}"
    fi
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appelée par ${FUNCNAME[1]:-main}]"
}
# Configuration de la base de données MariaDB
function mariadb_configure() {
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Début de ${FUNCNAME[0]:-main}] Appelée par ${FUNCNAME[1]:-main}]"
    trap 'on_error' ERR
    set -E -o pipefail
    info "${ICON_INFO} ${MSG_MARIADB_CONFIGURE_BDD_CONFIG}"
    MYSQL_CMD=$(command -v mysql || command -v mariadb || echo mysql)
    if [ -z "${MYSQL_CMD}" ]; then
        error "${ICON_ERROR} ${MSG_MARIADB_CONFIGURE_COMMAND_NOT_FOUND}"
        return 1
    fi
    get_timezone
    info "${ICON_DEBUG} Utilisation de la commande : ${MYSQL_CMD}"
    info "${ICON_DEBUG} Configuration de la base de données MariaDB/MySQL"
    info "${ICON_DEBUG} Mot de passe root : ${SQLROOTPWD}"
    info "${ICON_DEBUG} Connexion à l'hôte : ${DB_HOST}"
    info "${ICON_DEBUG} Création base : ${DB_NAME}"
    info "${ICON_DEBUG} Utilisateur : ${DB_USER}, Mdp : ${SQLGLPIPWD}"
    info "${ICON_DEBUG} timezone : ${TIMEZONES}"
    # --- Script SQL principal ---
    local _sql_root
    _sql_root=$(cat <<SQL
ALTER USER 'root'@'localhost' IDENTIFIED BY '${SQLROOTPWD}';
DELETE FROM mysql.user WHERE User='';
DELETE FROM mysql.user WHERE User='root' AND Host!='localhost';
DROP DATABASE IF EXISTS test;
DELETE FROM mysql.db WHERE Db='test' OR Db LIKE 'test_%';
GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION;
CREATE DATABASE IF NOT EXISTS ${DB_NAME};
CREATE USER IF NOT EXISTS '${DB_USER}'@'localhost' IDENTIFIED BY '${SQLGLPIPWD}';
GRANT ALL PRIVILEGES ON ${DB_NAME}.* TO '${DB_USER}'@'localhost';
FLUSH PRIVILEGES;
SQL
    )
    # --- Application du script SQL ---
    if echo "${_sql_root}" \
        | { sudo "${MYSQL_CMD}" -u root -p"${SQLROOTPWD}" --batch --silent 2>>"${ERRORFILE}" || \
            sudo "${MYSQL_CMD}" -u root --batch --silent 2>>"${ERRORFILE}"; } >> "${DEBUGFILE}"; then
        info "${ICON_OK} ${MSG_MARIADB_CONFIGURE_SQL_CMD_OK}"
    else
        warn "${ICON_WARN} ${MSG_MARIADB_CONFIGURE_SQL_CMD_ERROR}"
        return 1
    fi
    # --- Vérification des tables timezone ---
    local TIMEZONE_TABLE_COUNT
    TIMEZONE_TABLE_COUNT=$(
    echo "SELECT COUNT(*) FROM mysql.time_zone_name WHERE name = '${TIMEZONES}' LIMIT 1;" \
    | { 
        sudo "${MYSQL_CMD}" -u root -p"${SQLROOTPWD}" --batch --skip-column-names --silent 2>>"${ERRORFILE}" \
        || sudo "${MYSQL_CMD}" -u root --batch --skip-column-names --silent 2>>"${ERRORFILE}"
      } 2>>"${ERRORFILE}"
    )
    if [[ -z "${TIMEZONE_TABLE_COUNT}" || "${TIMEZONE_TABLE_COUNT}" -eq 0 ]]; then
        info "${ICON_INFO} ${MSG_MARIADB_CONFIGURE_TIMEZONE_IMPORT}"
        # shellcheck disable=SC2024
        sudo mysql_tzinfo_to_sql /usr/share/zoneinfo 2>>"${ERRORFILE}" \
        | {
            sudo "${MYSQL_CMD}" -u root -p"${SQLROOTPWD}" mysql >> "${DEBUGFILE}" 2>> "${ERRORFILE}" \
            || sudo "${MYSQL_CMD}" -u root mysql >> "${DEBUGFILE}" 2>> "${ERRORFILE}"
        }
    rc=${PIPESTATUS[1]}
    if [ "$rc" -eq 0 ]; then
        info "${ICON_OK} ${MSG_MARIADB_CONFIGURE_TIMEZONE_IMPORT_OK}"
    else
        warn "${ICON_WARN} ${MSG_MARIADB_CONFIGURE_TIMEZONE_IMPORT_ERROR}"
        return 1
    fi
        # --- Paramétrage du fuseau horaire ---
        local _sql_tz
        _sql_tz=$(cat <<SQL
SET GLOBAL time_zone = '${TIMEZONES}';
SET time_zone = '${TIMEZONES}';
GRANT SELECT ON mysql.time_zone_transition TO '${DB_USER}'@'localhost';
GRANT SELECT ON mysql.time_zone_transition_type TO '${DB_USER}'@'localhost';
GRANT SELECT ON mysql.time_zone TO '${DB_USER}'@'localhost';
GRANT SELECT ON mysql.time_zone_name TO '${DB_USER}'@'localhost';
FLUSH PRIVILEGES;
SQL
        )
        if echo "${_sql_root}" \
            | { sudo "${MYSQL_CMD}" -u root -p"${SQLROOTPWD}" --batch --silent 2>>"${ERRORFILE}" || \
                sudo "${MYSQL_CMD}" -u root --batch --silent 2>>"${ERRORFILE}"; } >> "${DEBUGFILE}"; then
            info "${ICON_OK} ${MSG_MARIADB_CONFIGURE_SQL_CMD_OK}"
        else
            warn "${ICON_WARN} ${MSG_MARIADB_CONFIGURE_SQL_CMD_ERROR}"
            return 1
        fi
    else
        info "${ICON_OK} ${MSG_MARIADB_CONFIGURE_TIMEZONE_ALREADY_LOADED}"
    fi
    # --- Redémarrage du service ---
    if systemctl is-active --quiet mariadb; then
        info "${ICON_RUN} ${MSG_MARIADB_CONFIGURE_SERVICE_RESTART}"
        if systemctl restart mariadb >>"${DEBUGFILE}" 2>>"${ERRORFILE}"; then
            info "${ICON_OK} ${MSG_MARIADB_CONFIGURE_SERVICE_RESTART_OK}"
        else
            warn "${ICON_WARN} ${MSG_MARIADB_CONFIGURE_SERVICE_RESTART_FAILED}"
        fi
    else
        warn "${ICON_WARN} ${MSG_MARIADB_CONFIGURE_SERVICES_START}"
        if systemctl start mariadb >>"${DEBUGFILE}" 2>>"${ERRORFILE}"; then
            info "${ICON_OK} ${MSG_MARIADB_CONFIGURE_SERVICES_START_OK}"
        else
            error "${ICON_ERR} ${MSG_MARIADB_CONFIGURE_SERVICES_START_FAILED}"
            return 1
        fi
    fi
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appelée par ${FUNCNAME[1]:-main}]"
}
# Téléchargement et décompression de GLPI
function download_untar_glpi(){
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    trap 'on_error' ERR
    set -Euo pipefail
    if [[ -z "${DOWNLOADLINK:-}" ]]; then
        warn "${ICON_WARN} ${MSG_DOWNLOAD_UNTAR_GLPI_DOWNLOAD_LINK_UNDEFINED}"
        return 1
    fi
    # Téléchargement de GLPI
    tmp_file="$(mktemp /tmp/glpi_XXX.tar.gz)"
    info "${ICON_DEBUG} ${MSG_DOWNLOAD_UNTAR_GLPI_DOWNLOAD} ${DOWNLOADLINK} ${MSG_DOWNLOAD_UNTAR_GLPI_DOWNLOAD_TOWARDS} ${tmp_file}"
    if wget -q -O "$tmp_file" "${DOWNLOADLINK}" >> "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
        info "${ICON_OK} ${MSG_DOWNLOAD_UNTAR_GLPI_DOWNLOAD_COMPLETED}"
    else
        warn "${ICON_WARN} ${MSG_DOWNLOAD_UNTAR_GLPI_FAILED}" 1>> "${ERRORFILE}"
        rm -f "$tmp_file"
        return 1
    fi
    # Vérification de l'intégrité du fichier téléchargé
    info "${ICON_INFO} ${MSG_DOWNLOAD_UNTAR_GLPI_HASH_CHECK}"
    EXPECTED_HASH=$(curl -s -H "User-Agent: glpi-installer" "${API_URL_SHA256}/${VERSION_SELECT}" \
    | grep '"digest":' \
    | sed -E 's/.*"sha256:([0-9a-f]+)".*/\1/' \
    | head -n 1)
    if ! [[ -n "$EXPECTED_HASH" ]]; then
        EXPECTED_HASH="poc"
    fi
    ACTUAL_HASH=$(sha256sum "$tmp_file" | awk '{print $1}')
    if [[ -n "$EXPECTED_HASH" ]]; then
        if ! [[ "$EXPECTED_HASH" != "$ACTUAL_HASH" ]]; then
            info "${ICON_VALIDATE} ${MSG_DOWNLOAD_UNTAR_GLPI_HASH_OK}"
        else
            info "${ICON_WARN} ${MSG_DOWNLOAD_UNTAR_GLPI_HASH_FAILED}"
        fi
    fi
    # Création du répertoire d'installation si nécessaire
    if mkdir -p "$REP_GLPI"; then
        info "${ICON_INFO} ${MSG_DOWNLOAD_UNTAR_GLPI_DIR_CREATE} ${REP_GLPI}"
    else
        warn "${ICON_WARN} ${MSG_DOWNLOAD_UNTAR_GLPI_DIR_CREATE_FAILED}"
        rm -f "$tmp_file"
        return 1
    fi
    # Extraction de l’archive GLPI
    if tar -xzf "$tmp_file" -C "$REP_GLPI" --strip-components=1; then
        info "${ICON_INFO} ${MSG_DOWNLOAD_UNTAR_GLPI_EXTRACT_OK} ${REP_GLPI}"
        rm -f "$tmp_file"
    else
        warn "${ICON_WARN} ${MSG_DOWNLOAD_UNTAR_GLPI_EXTRACT_FAILED}"
        rm -f "$tmp_file"
        return 1
    fi
    sync # S'assurer que toutes les écritures sont terminées
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Mise en place des réglage pour GLPI
function setup_glpi(){
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    info "${ICON_INFO} ${MSG_SETUP_GLPI_START}"
    trap 'on_error' ERR
    set -Euo pipefail
    source_os_release
    local CMD=(
    php "${REP_GLPI}bin/console" db:install
    --db-host "${DB_HOST}"
    --db-port=3306
    --db-name="${DB_NAME}"
    --db-user="${DB_USER}"
    --db-password="${SQLGLPIPWD}"
    --default-language="${LANGUAGE}"
    --force
    --no-telemetry
    --quiet
    --no-interaction
    )
    info "Hôte de la base de données : ${DB_HOST}"
    info "Nom de la base de données : ${DB_NAME}"
    info "Utilisateur de la base de données : ${DB_USER}"
    info "MDP : ${SQLGLPIPWD}"
    # Définition des répertoires
    FOLDER_LOGS="/var/log/${DB_NAME}"
    FOLDER_CONFIG="/etc/${DB_NAME}/config"
    FOLDER_FILES="/var/lib/${DB_NAME}/"
    # Définition des fichiers
    FILE_APACHE_CONF="/etc/apache2/sites-available/${DB_NAME}.conf"

    info "${ICON_INFO} ${MSG_SETUP_GLPI_DIR_LOGS}${DB_NAME}"
    mkdir -p "${FOLDER_LOGS}" || 
    {
        warn "${ICON_WARN} ${MSG_SETUP_GLPI_DIR_LOGS_FAILED}${DB_NAME}."
        return 1
    }
    info "${ICON_INFO} ${MSG_SETUP_GLPI_DIR_CONFIG}"
    mkdir -p "${FOLDER_CONFIG}" || 
    {
        warn "${ICON_WARN} ${MSG_SETUP_GLPI_DIR_CONFIG_FAILED}"
        return 1
    }
    info "${ICON_INFO} ${MSG_SETUP_GLPI_DIR_FILES}"
    mkdir -p "${FOLDER_FILES}" || 
    {
        warn "${ICON_WARN} ${MSG_SETUP_GLPI_DIR_FILES_FAILED}${DB_NAME}."
        return 1
    }
    info "${ICON_INFO} ${MSG_SETUP_GLPI_MOVE_FILES}"
    mv -f "${REP_GLPI}"files "${FOLDER_FILES}" ||
    {
        warn "${ICON_WARN} ${MSG_SETUP_GLPI_MOVE_FILES_FAILED}"
        return 1
    }
    info "${ICON_INFO} ${MSG_SETUP_GLPI_CREATE_LOCAL_DEFINE}"
    if sudo tee "${FOLDER_CONFIG}"/local_define.php >/dev/null <<EOF
<?php
    define('GLPI_VAR_DIR', '/var/lib/${DB_NAME}/files');
    define('GLPI_LOG_DIR', '/var/log/${DB_NAME}');
EOF
    then
        info "${ICON_INFO} ${MSG_SETUP_GLPI_CREATE_LOCAL_DEFINE_OK}"
    else
        warn "${ICON_WARN} ${MSG_SETUP_GLPI_CREATE_LOCAL_DEFINE_FAILED}"
        return 1
    fi
    info "${ICON_INFO} ${MSG_SETUP_GLPI_CREATE_DOWNSTREAM}"
    if sudo tee "${REP_GLPI}"/inc/downstream.php >/dev/null <<EOF
<?php
    define('GLPI_CONFIG_DIR', '${FOLDER_CONFIG}');
    if (file_exists(GLPI_CONFIG_DIR . '/local_define.php')) {
        require_once GLPI_CONFIG_DIR . '/local_define.php';
    }
EOF
    then
        info "${ICON_INFO} ${MSG_SETUP_GLPI_CREATE_DOWNSTREAM_OK}"
    else
        warn "${ICON_WARN} ${MSG_SETUP_GLPI_CREATE_DOWNSTREAM_FAILED}"
        return 1
    fi
    # Change permissions
    info "${ICON_INFO} ${MSG_SETUP_GLPI_RIGHTS_MODIFY}"
    if ! rights_glpi "${REP_GLPI}"; then
        warn "${ICON_WARN} ${MSG_SETUP_GLPI_RIGHTS_MODIFY_FAILED}"
        return 1
    fi
    sync # S'assurer que toutes les écritures sont terminées
    info "${ICON_INFO} ${MSG_SETUP_GLPI_WEB_SERVER_CONFIG} ${REP_GLPI}"
    if check_install_user "${REP_GLPI}"; then
        info "${ICON_INFO} ${MSG_SETUP_GLPI_WEB_USER_DETECTED} ${WEB_USER}"
        if [[ "${WEB_USER}" == "www-data" ]]; then
            network_info
            debug "${ICON_DEBUG} ${MSG_SETUP_GLPI_WEB_SERVER_CONFIG_APACHE} ${WEB_USER}" # Pour le débogage
            # Configuration d'Apache pour GLPI
            info "${ICON_INFO} ${MSG_SETUP_GLPI_WEB_SERVER_CONFIG_VIRTUAL_HOST}"
            if tee "${FILE_APACHE_CONF}" <<EOF > /dev/null
<VirtualHost *:80>
    ServerName ${IPADRESS}
    DocumentRoot ${REP_GLPI}public
    <Directory ${REP_GLPI}public>
        Require all granted
        RewriteEngine On
        RewriteCond %{HTTP:Authorization} ^(.+)$
        RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
        RewriteCond %{REQUEST_FILENAME} !-f
        RewriteRule ^(.*)$ index.php [QSA,L]
    </Directory>
    ErrorLog /var/log/glpi/error.log
    CustomLog /var/log/glpi/access.log combined
</VirtualHost>
EOF
            then
                echo "${ICON_OK} ${MSG_SETUP_GLPI_WEB_SERVER_CONFIG_VIRTUAL_HOST_OK}"
            else
                erreur "${MSG_ERROR} ${MSG_SETUP_GLPI_WEB_SERVER_CONFIG_VIRTUAL_HOST_FAILED}"
                return 1
            fi
            phpversion=$(php -v | grep -i '(cli)' | awk '{print $2}' | cut -d. -f1,2)
            sed -i 's/^\(;\?\)\(session.cookie_httponly\).*/\2 =on/' /etc/php/"$phpversion"/apache2/php.ini
            # Disable Apache Web Server Signature
            echo "ServerSignature Off" >> /etc/apache2/apache2.conf
            echo "ServerTokens Prod" >> /etc/apache2/apache2.conf
            # Activation du module rewrite d'apache
            if ! a2enmod rewrite | tee -a "${DEBUGFILE}"; then
                warn "${ICON_WARN} ${MSG_SETUP_GLPI_PHP_REWRITE_FAILED}"
                return 1
            fi
            # Déactiver le site par défaut
            if ! a2dissite 000-default.conf | tee -a "${DEBUGFILE}"; then
                warn "${ICON_WARN} ${MSG_SETUP_GLPI_APACHE_DEFAULT_SITE_DISABLED_FAILED}"
                return 1
            fi
            # Activer le site GLPI
            if ! a2ensite "${DB_NAME}".conf | tee -a "${DEBUGFILE}"; then
                warn "${ICON_WARN} ${MSG_SETUP_GLPI_APACHE_DEFAULT_SITE_ENABLED_FAILED}"
                return 1
            fi
            # Recharger la configuration d'Apache
            if ! systemctl reload apache2 | tee -a "${DEBUGFILE}"; then
                warn "${ICON_WARN} ${MSG_SETUP_GLPI_APACHE_RELOAD_FAILED}"
                return 1
            fi
            # Change permissions
            info "${ICON_INFO} ${MSG_SETUP_GLPI_RIGHTS_MODIFY}"
            if ! rights_glpi "${REP_GLPI}"; then
                warn "${ICON_WARN} ${MSG_SETUP_GLPI_RIGHTS_MODIFY_FAILED}"
                return 1
            fi
            sync # S'assurer que toutes les écritures sont terminées
            # Installation de GLPI en ligne de commande
            debug "${ICON_DEBUG} $(date '+%Y-%m-%d %H:%M:%S') - [INFO] Exécution : sudo -u ${WEB_USER} php ${CMD[*]}"
            # Exécuter la commande en tant que "${WEB_USER}". Utiliser sudo tee pour écrire vers les fichiers protégés.
            if sudo -u "${WEB_USER}" "${CMD[@]}" | sudo tee -a "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
                info "${ICON_OK} Installation GLPI réussie."
                sync # S'assurer que toutes les écritures sont terminées
            else
                warn "${ICON_WARN} Échec de l’installation GLPI."
                tail -n 10 "${ERRORFILE}" >&2  # affiche les dernières erreurs
                return 1
            fi
            manage_service "apache2" "Apache2" || return 1
        fi
    elif [[ "${WEB_USER}" == "nginx" ]]; then
        network_info
        info "${ICON_INFO} ${MSG_SETUP_GLPI_WEB_SERVER_CONFIG_NGINX} ${WEB_USER}"
        # Configuration de Nginx pour GLPI
        info "${ICON_INFO} ${MSG_SETUP_GLPI_WEB_SERVER_CONFIG_NGINX_VIRTUAL_HOST}"
        sudo tee "/etc/nginx/conf.d/glpi.conf" <<EOF > /dev/null
server {
    listen 80;
    server_name ${IPADRESS};
    root ${REP_GLPI}public;
    location / {
        try_files \$uri /index.php\$is_args\$args;
    }
    location ~ ^/index\.php$ {
        # the following line needs to be adapted, as it changes depending on OS distributions and PHP versions
        fastcgi_pass unix:/var/run/php-fpm/www.sock;
        fastcgi_split_path_info ^(.+\.php)(/.*)$;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;
    }
}
EOF
        info "${ICON_INFO} ${MSG_SETUP_GLPI_CREATE_LOGROTATE}"
        # Configuration de logrotate pour GLPI
        sudo tee "/etc/logrotate.d/glpi" <<EOF > /dev/null
/var/lib/glpi/files/_log/*.log {
    su nginx nginx
    daily
    rotate 14
    compress
    notifempty
    missingok
    create 644 nginx nginx
}
EOF
        chmod 0644 /etc/logrotate.d/glpi
        chown root:root /etc/logrotate.d/glpi
        chcon system_u:object_r:etc_t:s0 /etc/logrotate.d/glpi
        sed -i 's/^\(;\?\)\(session.cookie_httponly\).*/\2 = on/' /etc/php.ini
        info "${ICON_INFO} ${MSG_SETUP_GLPI_CREATE_LOGROTATE_OK}"
        # Change permissions
        if rights_glpi "${REP_GLPI}"; then
            info "${ICON_INFO} ${MSG_SETUP_GLPI_RIGHTS_MODIFY}"
        else
            warn "${ICON_WARN} ${MSG_SETUP_GLPI_RIGHTS_MODIFY_FAILED}"
            return 1
        fi
        # Recharger la configuration de Nginx
        if ! systemctl reload nginx php-fpm; then
            warn "${ICON_WARN} ${MSG_SETUP_GLPI_WEB_SERVER_CONFIG_NGINX_RELOAD_FAILED}"
            return 1
        fi
        # Installation de GLPI en ligne de commande
        if sudo -u "${WEB_USER}" "${CMD[@]}" 1>>"${DEBUGFILE}" 2>>"${ERRORFILE}"; then
            info "${ICON_INFO} ${MSG_SETUP_GLPI_COMPLETED}"
        else
            warn "${ICON_WARN} ${MSG_SETUP_GLPI_INSTALLATION_FAILED}"
            return 1
        fi
        # Configuration de la tâche Cron
        info "${ICON_INFO} ${MSG_SETUP_GLPI_CRON_CONFIG}"
        echo "*/2 * * * * ${WEB_USER} /usr/bin/php ${REP_GLPI}front/cron.php &>/dev/null" >> /etc/cron.d/glpi
    fi
    sync # S'assurer que toutes les écritures sont terminées
    info "${ICON_INFO} ${MSG_SETUP_GLPI_REMOVE_INSTALL_FILE}"
    if rm -Rf "${REP_GLPI}install/install.php"; then
        info "${ICON_INFO} ${MSG_SETUP_GLPI_REMOVE_INSTALL_FILE_OK}"
    else
        warn "${ICON_WARN} ${MSG_SETUP_GLPI_REMOVE_INSTALL_FILE_FAILED}"
        return 1
    fi
    sleep 2
    info "${ICON_INFO} ${MSG_SETUP_GLPI_COMPLETED}"
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Mise à jour des mot de passe des utilisateurs de GLPI
function maj_user_glpi(){
    trap 'on_error' ERR
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    info "${ICON_INFO}  ${MSG_MAJ_USER_GLPI_START}"
    # Ensure we have a mysql client command; fallback to detecting it if not set
    network_info
    get_timezone
    local MYSQL_CMD
    MYSQL_CMD=$(command -v mysql  || command -v mariadb || echo mysql)
    # Verify mysql client exists
    if ! command -v "${MYSQL_CMD}"; then
        warn "${MSG_MARIADB_CONFIGURE_COMMAND_NOT_FOUND} ${MYSQL_CMD}"
        return 1
    fi
    # --- Vérification des variables critiques ---
    if [ -z "${DB_NAME:-}" ] || [ -z "${DB_USER:-}" ] || [ -z "${SQLGLPIPWD:-}" ] || [ -z "${IPADRESS:-}" ]; then
        error "${ICON_ERROR} ${MSG_MAJ_USER_GLPI_MISSING_VARS}"
        return 1
    fi
    if [ -z "${ADMINGLPIPWD:-}" ] || [ -z "${POSTGLPIPWD:-}" ] || [ -z "${TECHGLPIPWD:-}" ] || [ -z "${NORMGLPIPWD:-}" ]; then
        error "${ICON_ERROR} ${MSG_MAJ_USER_GLPI_MISSING_PASSWORDS}"
        return 1
    fi
    # Construire la requête SQL et exécuter via -e
    local _sql_user
    debug "${ICON_DEBUG} Préparation des commandes SQL pour mettre à jour les mots de passe des utilisateurs GLPI." # Pour le débogage
    debug "${ICON_DEBUG} Base de données: ${DB_NAME}, Utilisateur: ${DB_USER}, Mot de passe SQL: ${SQLGLPIPWD}" # Pour le débogage
    debug "${ICON_DEBUG} Nouveaux mots de passe des utilisateurs GLPI:" # Pour le débogage
    debug "${ICON_DEBUG}   - glpi: ${ADMINGLPIPWD}" # Pour le débogage
    debug "${ICON_DEBUG}   - post-only: ${POSTGLPIPWD}" # Pour le débogage
    debug "${ICON_DEBUG}   - tech: ${TECHGLPIPWD}" # Pour le débogage
    debug "${ICON_DEBUG}   - normal: ${NORMGLPIPWD}" # Pour le débogage
    debug "${ICON_DEBUG} Construction des commandes SQL..." # Pour le débogage
    # --- Construction du SQL ---
    local _sql_user
    _sql_user=$(
        cat <<SQL
USE ${DB_NAME};
UPDATE glpi_users SET password = MD5('${ADMINGLPIPWD}') WHERE name = 'glpi';
UPDATE glpi_users SET password = MD5('${POSTGLPIPWD}') WHERE name = 'post-only';
UPDATE glpi_users SET password = MD5('${TECHGLPIPWD}') WHERE name = 'tech';
UPDATE glpi_users SET password = MD5('${NORMGLPIPWD}') WHERE name = 'normal';
UPDATE glpi_configs SET value = '${TIMEZONE}' WHERE context = 'core' AND name = 'timezone';
UPDATE glpi_configs SET value = '${LANGUAGE}' WHERE context = 'core' AND name = 'language';
UPDATE glpi_configs SET value = '${IPADRESS}' WHERE context = 'core' AND name = 'url_base';
SQL
    )
    # --- Exécution SQL ---
    if ! PAGER=cat MYSQL_PWD="${SQLGLPIPWD}" "${MYSQL_CMD}" -u "${DB_USER}" --batch --silent -e "${_sql_user}" 2>/dev/null; then
        error "${ICON_ERROR} ${MSG_ERROR_TASK:-Erreur} : échec de la mise à jour des utilisateurs GLPI."
        return 1
    fi
    info "${ICON_INFO}  ${MSG_MAJ_USER_GLPI_OK}"
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
function source_os_release(){
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    if [[ -f /etc/os-release ]]; then
        # shellcheck disable=SC1091
        . /etc/os-release
    fi
    if [[ -f /etc/lsb-release ]]; then
        # shellcheck disable=SC1091
        . /etc/lsb-release
    fi
    if [[ -z "${ID:-}" ]]; then
        ID=$(uname -s | tr '[:upper:]' '[:lower:]')
    fi
    if [[ -z "${VERSION_ID:-}" ]]; then
        VERSION_ID=$(uname -r)
    fi
    if [ -z "${ID:-}" ] || [ -z "${VERSION_ID:-}" ]; then
        warn "${ICON_WARN} ${MSG_SOURCE_OS_RELEASE_MISSING_VARS}"
        return 1
    fi
    export ID VERSION_ID
    info "${ICON_INFO} ${MSG_SOURCE_OS_RELEASE_INFO} ${ID} ${VERSION_ID}"
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
function rights_glpi(){
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    REP_GLPI="${1:-/var/www/html/glpi}"
    # Changer les droits des répertoires et fichiers
    info "${ICON_INFO}  ${MSG_SETUP_GLPI_RIGHTS_MODIFY}"
    find "${REP_GLPI}" -type d -exec chmod 755 {} \; 1> >(tee -a "${DEBUGFILE}") 2> >(tee -a "${ERRORFILE}" >&2)
    find "${REP_GLPI}" -type f -exec chmod 644 {} \; 1> >(tee -a "${DEBUGFILE}") 2> >(tee -a "${ERRORFILE}" >&2)
    # Changer le propriétaire des répertoires
    if check_distro ; then
        sudo chown -Rc "${WEB_USER}":"${WEB_USER}" /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}"
    fi
    # SELinux configuration
    if [[ "${WEB_USER}" == "nginx" ]]; then
        if command -v semanage; then
            setsebool -P httpd_can_network_connect on
            setsebool -P httpd_can_network_connect_db on
            setsebool -P httpd_can_sendmail on
            for p in "${REP_GLPI}" /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}marketplace"; do
                semanage fcontext -a -t httpd_sys_rw_content_t "${p}(/.*)?"
            done
            restorecon -R "${REP_GLPI}" /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}marketplace"
        else
            error "${ICON_ERROR} $(date '+%F %T'): WARN: semanage non disponible — SELinux non configuré"
        fi
    fi
    info "${ICON_INFO}  ${MSG_SETUP_GLPI_RIGHTS_MODIFY_OK}"
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Ecriture du fichier pour sauvegarder les mot de passe du serveur GLPI
function write_credentials(){
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    info "${ICON_INFO}  ${MSG_WRITE_CREDENTIALS_START}"
    local folder_save_credentials="" file_save=""
    folder_save_credentials="${INVOKING_HOME}/saved_credentials"
    mkdir -p "${folder_save_credentials}"
    # Nettoie le nom du fichier pour éviter les / ou espaces
    local safe_name
    safe_name="$(basename "${FICHIER_MSG}" .txt)_${DB_NAME}.txt"
    file_save="${folder_save_credentials}/${safe_name}"
    if [[ "${LANGUAGE}" == "fr_FR" ]]; then
        cat > "${file_save}" << EOF
<==========================> Détails de l'installation de GLPI <=================================>
 GLPI Version: ${VERSION_SELECT}
 Répertoire d'installation de GLPI: ${REP_GLPI}

 Les comptes utilisateurs par défaut sont :
 UTILISATEUR   -  MOT DE PASSE       -       ACCES
  glpi         -  ${ADMINGLPIPWD}     -  compte admin
  post-only    -  ${POSTGLPIPWD}     -  compte post-only
  tech         -  ${TECHGLPIPWD}     -  compte tech
  normal       -  ${NORMGLPIPWD}     -  compte normal

 Vous pouvez accéder à la page web de GLPI à partir d'une adresse IP ou d'un nom d'hôte :
 http://${DB_HOST}

 ==> Base de données:
 Hôte de la base de données: ${DB_HOST}
 Port de la base de données: 3306
 Nom de la base de données GLPI: ${DB_NAME}
 Mot de passe root: ${SQLROOTPWD}
 Mot de passe ${DB_USER}: ${SQLGLPIPWD}

 Fichier de sauvegarde enregistré dans ${FICHIER_MSG}
 <===============================================================================================>

 Si vous rencontrez un probléme avec ce script, veuillez le signaler sur GitHub : https://github.com/PapyPoc/glpi_install/issues
EOF
	else
		cat > "${file_save}" << EOF
<=============================> GLPI installation details <=====================================>
 GLPI version: ${VERSION_SELECT}
 GLPI installation directory: ${REP_GLPI}

 The default user accounts are:
    USER         -    PASSWORD        -       ACCESS
  glpi           -  ${ADMINGLPIPWD}      -  admin account
  post-only      -  ${POSTGLPIPWD}      -  post-only account
  tech           -  ${TECHGLPIPWD}      -  tech account
  normal         -  ${NORMGLPIPWD}      -  normal account

 You can access the GLPI web page from the following address :
 http://${DB_HOST}

 ==> Database:
 Database host: ${DB_HOST}
 Database port: 3306
 GLPI database name: ${DB_NAME}
 Root password: ${SQLROOTPWD}
 ${DB_USER} password: ${SQLGLPIPWD}

 Backup file saved to ${FICHIER_MSG}
 <===============================================================================================>

 If you encounter a problem with this script, please report it on GitHub : https://github.com/PapyPoc/glpi_install/issues
EOF
	fi
    info "${ICON_INFO} ${MSG_WRITE_CREDENTIALS_END}"
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Afficher le résultat final
function display_result() {
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    info "${ICON_INFO}  ${MSG_DISPLAY_RESULT_START}"
    local MESSAGE="" file_save=""
    file_save=$(find "${INVOKING_HOME}/saved_credentials" -type f -name "${FICHIER_MSG}${DB_NAME}*" | head -n 1)
	if [[ -f "${file_save}" ]]; then
        while IFS= read -r ligne; do
            MESSAGE+="${ligne}\n"
        done < "${file_save}"
        dialog --backtitle "${MSG_DISPLAY_RESULT_TITLE}" --title "${MSG_DISPLAY_RESULT_TITRE_OK}" --msgbox "${MESSAGE}" 0 0 >/dev/tty 2>&1
    else
        dialog --backtitle "${MSG_DISPLAY_RESULT_TITLE}" --title "${MSG_DISPLAY_RESULT_TITRE_NONOK}" --msgbox "${ICON_KO}\n\n${MSG_ERROR_FICHIER_MSG}" 0 0 >/dev/tty 2>&1
    fi
    info "${ICON_INFO}  ${MSG_DISPLAY_RESULT_END}"
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Activé ou déactivé le mode maintenance (1 ou 0)
function maintenance(){ 
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    check_install_user "${REP_GLPI}"
    if [ "$1" == "1" ]; then
        info "${ICON_INFO}  ${MSG_MAINTENANCE_ON}"
        sudo -u "${WEB_USER}" php "${REP_GLPI}"bin/console glpi:maintenance:enable 1> >(tee -a "${DEBUGFILE}") 2> >(tee -a "${ERRORFILE}" >&2)
    elif [ "$1" == "0" ]; then
        info "${ICON_INFO}  ${MSG_MAINTENANCE_OFF}"
        sudo -u "${WEB_USER}" php "${REP_GLPI}"bin/console glpi:maintenance:disable 1> >(tee -a "${DEBUGFILE}") 2> >(tee -a "${ERRORFILE}" >&2)
    fi
	sleep 2;
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
function get_glpi_db_info() {
    set -euo pipefail
    REP_GLPI="${1:-/var/www/html/glpi}"
    file_downstream="${REP_GLPI}/inc/downstream.php"
    #local GLPI_CONFIG_DIR file_conf_glpi _conf_tmp
    # Vérification du fichier principal
    if [[ ! -f "${file_downstream}" ]]; then
        echo "${ICON_WARN} Fichier downstream.php introuvable : ${file_downstream}" >&2
        return 1
    fi
    # Extraction du répertoire de configuration via PHP
    GLPI_CONFIG_DIR=$(php -r "require '${file_downstream}'; echo (defined('GLPI_CONFIG_DIR')?GLPI_CONFIG_DIR:'');")
    if [[ -z "${GLPI_CONFIG_DIR}" ]]; then
        echo "${ICON_WARN} Impossible de déterminer GLPI_CONFIG_DIR" >&2
        return 1
    fi
    file_conf_glpi="${GLPI_CONFIG_DIR}/config_db.php"
    if [[ ! -f "${file_conf_glpi}" ]]; then
        echo "${ICON_WARN} Fichier de configuration introuvable : ${file_conf_glpi}" >&2
        return 1
    fi
    # Création d’un fichier temporaire nettoyé des CRLF
    _conf_tmp=$(mktemp)
    tr -d '\r' < "${file_conf_glpi}" > "${_conf_tmp}"
    # Extraction des valeurs (tolérante aux espaces)
    local DB_HOST DB_USER DB_PASSWORD DB_NAME GLPI_VERSION
    DB_HOST=$(sed -n "s/.*public[[:space:]]\+\$dbhost[[:space:]]*=[[:space:]]*'\([^']*\)'.*/\1/p" "${_conf_tmp}")
    DB_USER=$(sed -n "s/.*public[[:space:]]\+\$dbuser[[:space:]]*=[[:space:]]*'\([^']*\)'.*/\1/p" "${_conf_tmp}")
    DB_PASSWORD=$(sed -n "s/.*public[[:space:]]\+\$dbpassword[[:space:]]*=[[:space:]]*'\([^']*\)'.*/\1/p" "${_conf_tmp}")
    DB_NAME=$(sed -n "s/.*public[[:space:]]\+\$dbdefault[[:space:]]*=[[:space:]]*'\([^']*\)'.*/\1/p" "${_conf_tmp}")
    rm -f "${_conf_tmp}"
    # Détection de version GLPI
    GLPI_VERSION=$(php -r "require '${file_downstream}'; echo (defined('GLPI_VERSION')?GLPI_VERSION:'inconnue');")
    # Vérification des résultats
    if [[ -z "${DB_NAME}" || -z "${DB_USER}" ]]; then
        warn "${ICON_WARN} Impossible d’extraire les infos de base de données depuis ${file_conf_glpi}" >&2
        return 1
    fi
    # Affichage
    info "${ICON_INFO} Informations GLPI détectées :"
    info "  ${ICON_PACKAGE} Version GLPI : ${GLPI_VERSION}"
    info "  ${ICON_DBHOST} Hôte DB      : ${DB_HOST}"
    info "  ${ICON_DBNAME} Base DB      : ${DB_NAME}"
    info "  ${ICON_DBUSER} Utilisateur  : ${DB_USER}"
    info "  ${ICON_DBPASS} Mot de passe : ${DB_PASSWORD:0:3}********"
    # Export optionnel des variables dans l’environnement appelant
    export GLPI_VERSION DB_HOST DB_NAME DB_USER DB_PASSWORD
}
# Sauvegarde de la base de donnée et des fichiers de GLPI
function backup_glpi() {
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    info "${ICON_INFO} ${MSG_BACKUP_GLPI_START}"
    # Récupération du nom de la base de données dans le fichier config de GLPI suivant le répertoire de GLPI
    info "${ICON_INFO} ${MSG_BACKUP_GLPI_READ_SAUVE}"
    get_glpi_db_info "${REP_GLPI}"
    # Détermination de l’outil de dump
    local MYSQLDUMP_CMD
    MYSQLDUMP_CMD=$(command -v mysqldump 2>/dev/null || command -v mariadb-dump 2>/dev/null || echo mysqldump)
    # Répertoires de sauvegarde
    REP_BACKUP="${INVOKING_HOME}/backup_glpi_$(date +"%Y-%m-%d")"
    BDD_BACKUP="bdd_glpi_$(date +"%Y-%m-%d_%H-%M-%S").sql"
    if ! mkdir -p "${REP_BACKUP}"; then
        warn "${ICON_WARN} ${MSG_BACKUP_GLPI_DIR_FAILED}"
        return 1
    fi
    # --- Export de la BDD ---
    info "${ICON_INFO} ${MSG_BACKUP_GLPI_DUMP_DB}"
    # shellcheck disable=SC2261
    if ${MYSQLDUMP_CMD} -u "${DB_USER}" -p"${DB_PASSWORD}" --databases "${DB_NAME}" \
            > "${REP_BACKUP}/${BDD_BACKUP}" \
            >>"${DEBUGFILE}" 2>>"${ERRORFILE}"; then
        if [[ -s "${REP_BACKUP}/${BDD_BACKUP}" ]]; then
            info "${ICON_OK} ${MSG_BACKUP_GLPI_DUMP_DB_OK}"
        else
            warn "${ICON_WARN} ${MSG_BACKUP_GLPI_DUMP_DB_EMPTY} ${REP_BACKUP}/${BDD_BACKUP}"
            return 1
        fi
    else
        error "${ICON_ERR} ${MSG_BACKUP_GLPI_DUMP_DB_FAILED}"
        return 1
    fi
    # --- Sauvegarde des fichiers ---
    info "${ICON_INFO} ${MSG_BACKUP_GLPI_SITE_COPY}"
    for SRC in "/etc/glpi/config" "/var/lib/glpi/files" "${REP_GLPI}/plugins" "${REP_GLPI}/marketplace" "${REP_GLPI}/inc/downstream.php"; do
        if [ -e "${SRC}" ]; then
            info "${ICON_INFO} ${MSG_BACKUP_GLPI_SITE_COPY_REP}"
            cp -Rf "${SRC}" "${REP_BACKUP}/"
        else
            warn "${ICON_WARN} ${MSG_BACKUP_GLPI_SITE_SOURCE_MISSING} ${SRC}"
        fi
    done
    info "${ICON_INFO} ${MSG_BACKUP_GLPI_SITE_COPY_OK}"
    # --- Compression ---
    info "${ICON_INFO} ${MSG_BACKUP_GLPI_COMPRESS_BACKUP}"
    mkdir -p "${REP_BACKUP_COMPRESS}"
    local BACKUP_FILE
    BACKUP_FILE="${REP_BACKUP_COMPRESS}/glpi_$(date +"%Y-%m-%d")_${GLPI_CLI_VERSION}->${VERSION_SELECT}.tar.gz"
    if tar -czf "${BACKUP_FILE}" -C "${REP_BACKUP}" . 2>> "${ERRORFILE}"; then
        info "${ICON_INFO} ${MSG_BACKUP_GLPI_COMPRESS_BACKUP_OK} (${BACKUP_FILE})"
        # Vérifier que le fichier compressé n'est pas vide
        if [ ! -s "${BACKUP_FILE}" ]; then
            warn "${ICON_WARN} ${MSG_BACKUP_GLPI_EMPTY_COMPRESS_BACKUP}"
            return 1
        fi
    else
        warn "${ICON_WARN} ${MSG_BACKUP_GLPI_COMPRESS_BACKUP_FAILED}"
        return 1
    fi
    info "${ICON_INFO} ${MSG_BACKUP_GLPI_OK}"
    sleep 2
    export REP_BACKUP REP_GLPI
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
function remove_old_glpi(){
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    # Suppression sécurisée de l’ancien GLPI
        info "${ICON_INFO} ${MSG_BACKUP_GLPI_REMOVE_OLD_GLPI_DIR}"
        if [ -n "${REP_GLPI}" ] && [ -d "${REP_GLPI}" ]; then
            rm -rf "${REP_GLPI:?}/" >> "${DEBUGFILE}" 2>> "${ERRORFILE}"
            info "${ICON_INFO} Répertoire ${REP_GLPI} supprimé."
        else
            warn "${ICON_WARN} ${MSG_BACKUP_GLPI_REMOVE_OLD_GLPI_DIR_NOTFOUND} ${REP_GLPI}"
        fi
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
# Mise à jour de GLPI
function update_glpi() {
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Debut de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    info "${ICON_INFO} ${MSG_UPDATE_GLPI_START}"
    # Restauration des fichiers de configuration et des plugins
    info "${ICON_INFO} ${MSG_UPDATE_GLPI_RESTORE_FILES}"
    for DIR in config files plugins marketplace; do
        SRC="${REP_BACKUP}/${DIR}"
        if [ -d "${SRC}" ]; then
            case "${DIR}" in
                config) DEST="/etc/glpi/config" ;;
                files) DEST="/var/lib/glpi/files" ;;
                plugins) DEST="${REP_GLPI}/plugins" ;;
                marketplace) DEST="${REP_GLPI}/marketplace" ;;
            esac
            mkdir -p "${DEST}"
            if compgen -G "${SRC}/*" > /dev/null; then
                if cp -Rf "${SRC}/"* "${DEST}/"; then
                    info "${ICON_INFO} ${MSG_UPDATE_GLPI_RESTORE_FILES_OK}"
                else
                    warn "${ICON_WARN} ${ICON_WARN} ${MSG_UPDATE_GLPI_RESTORE_FILES_ERROR} ${DIR}."
                fi
            else
                warn "${ICON_WARN} ${MSG_UPDATE_GLPI_RESTORE_FILES_EMPTY}"
            fi
        fi
    done
    # Restauration du fichier downstream.php
    REP_BACKUP=$(find "${INVOKING_HOME}" -maxdepth 1 -type d -name "backup_glpi_*")
    info "${ICON_INFO} ${MSG_UPDATE_GLPI_RESTORE_FILES_DOWNSTREAM}"
    if [ -f "${REP_BACKUP}/downstream.php" ]; then
        mkdir -p "${REP_GLPI}/inc" 1>> "${DEBUGFILE}" 2>> "${ERRORFILE}"
        if cp -Rf "${REP_BACKUP}/downstream.php" "${REP_GLPI}/inc/" 1>> "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
            info "${ICON_INFO} ${MSG_UPDATE_GLPI_RESTORE_FILES_DOWNSTREAM_OK}"
        else
            warn "${ICON_WARN} ${MSG_UPDATE_GLPI_RESTORE_FILES_DOWNSTREAM_ERROR}"
        fi
    fi
    # Suppression de la sauvegarde
    info "${ICON_INFO} ${MSG_UPDATE_GLPI_REMOVE_OLD_FILES}"
    if [ -d "${INVOKING_HOME}" ]; then
        if find "${INVOKING_HOME}" -maxdepth 1 -type d -name "backup_glpi_*" -exec rm -rf {} + >> "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
            info "${ICON_INFO} ${MSG_UPDATE_GLPI_REMOVE_OLD_FILES_OK}"
        else
            warn "${ICON_WARN} ${MSG_UPDATE_GLPI_REMOVE_OLD_FILES_FAILED}"
        fi
    fi
    # Mise à jour de la base GLPI
    info "${ICON_INFO} ${MSG_UPDATE_GLPI_UPDATE_DATABASE}"
    if check_install_user "${REP_GLPI}"; then
        rights_glpi "${REP_GLPI}"
        debug "${ICON_DEBUG} Repertoire GLPI pour la mise à jour de la base : ${REP_GLPI}"
        debug "${ICON_DEBUG} Utilisateur web pour la mise à jour de la base : ${WEB_USER}"
        local CMD
        CMD="${REP_GLPI}/bin/console db:update --force --no-telemetry --quiet --no-interaction"
        # shellcheck disable=SC2086
        if sudo -u "${WEB_USER}" php ${CMD} 1>> "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
            info "${ICON_INFO} ${MSG_UPDATE_GLPI_UPDATE_DATABASE_OK}"
            exec 3>&1
            dialog --title "${ICON_OK} ${MSG_UPDATE_GLPI_DIALOG_DATABASE}" --msgbox "${MSG_UPDATE_GLPI_UPDATE_DATABASE_OK}" 7 50
            exec 3>&-
        else
            warn "${ICON_WARN} ${MSG_UPDATE_GLPI_UPDATE_DATABASE_FAILED} (voir ${ERRORFILE})."
            exec 3>&1
            dialog --title "${ICON_KO} ${MSG_UPDATE_GLPI_DIALOG_DATABASE}" --msgbox "${MSG_UPDATE_GLPI_UPDATE_DATABASE_FAILED}" 7 50
            exec 3>&-
            return 1
        fi
    fi
    # Nettoyage final
    info "${ICON_INFO} ${MSG_UPDATE_GLPI_CLEAN}"
    if find "${REP_GLPI}/install/" -maxdepth 1 -type f -name "install.php" -exec sudo rm -f {} +  ; then
        info "${ICON_INFO} ${MSG_UPDATE_GLPI_CLEAN_OK}"
    else
        warn "${ICON_WARN} ${MSG_UPDATE_GLPI_CLEAN_FAILED}"
        exit 1
    fi
    info "${ICON_INFO} ${MSG_UPDATE_GLPI_OK}"
    debug "${ICON_DEBUG} $(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}