#!/usr/bin/env bash
#
# GLPI install script
# Author: PapyPoc
# Version: 2.0.0
# Function file
#
set -Eeuo pipefail
# Ne pas continuer si le script est ex√©cut√© directement
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo -e "Ce fichier doit √™tre sourc√©, pas ex√©cut√©.\n" >&2
    echo -e "This file must be sourced, not executed.\n" >&2
    exit 1
fi
# Affichage d'erreur en rouge
function error(){
    local msg="$1"
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    echo -e "‚ùó ${ROUGE}${expanded}${NC}" # Couleur rouge # Affichage √† l'√©cran d√©sactiv√©
    printf '%s\n' "${expanded}" | tee -a "${ERRORFILE}" >/dev/null
}
# Affichage d'alerte en orange
function warn(){
    local msg="$1"
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    echo -e "${ORANGE}${expanded}${NC}" # Couleur orange # Affichage √† l'√©cran d√©sactiv√©
    printf '%s\n' "${expanded}" | tee -a "${ERRORFILE}" >/dev/null # Affichage dans le fichier d'alerte
}
# Affichage d'information en bleu
function info(){
    local msg="$1"
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    echo -e "‚ÑπÔ∏è ${CYAN}${expanded}${NC}" # Couleur cyan # Affichage √† l'√©cran d√©sactiv√©
    printf '%s\n' "${expanded}" | tee -a "${INFOFILE}" >/dev/null # Affichage dans le fichier d'info
}
# Affichage debug en normal
function debug_start(){
    local msg
    msg="$(date '+%F %T') [$$][DEBUG: ${FUNCNAME[0]:-main}] Depuis ${FUNCNAME[1]:-main}"
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    #echo -e "üêû ${NC}${expanded}${NC}" # Couleur normale Affichage √† l'√©cran d√©sactiv√©
    printf '%s\n' "üêû ${expanded}" | tee -a "${DEBUGFILE}" >/dev/null # Affichage dans le fichier de debug
}
function debug_end(){
    local msg
    msg="$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
    local expanded
    if command -v envsubst >/dev/null 2>&1; then
        expanded=$( ( set +u; printf '%s' "$msg" | envsubst ) )
    else
        expanded=$( ( set +u; eval "printf '%s' \"$msg\"" ) )
    fi
    #echo -e "üêû ${NC}${expanded}${NC}" # Couleur normale Affichage √† l'√©cran d√©sactiv√©
    printf '%s\n' "üêû ${expanded}" | tee -a "${DEBUGFILE}" >/dev/null # Affichage dans le fichier de debug
}
function gt(){
    gettext "$@" || echo "$1 - Missing translation"  # Fallback si traduction absente
}
# Gestion des erreurs avec trap
function on_error() {
    local rc=$?                               # Code de retour de la derni√®re commande
    local cmd="${BASH_COMMAND}"               # Commande qui a √©chou√©
    local line="${BASH_LINENO[0]}"            # Ligne d‚Äôerreur
    local message=""
    local err_dial=""
    message+="$(gt "Erreur d√©tect√©e : '${cmd}' (code=${rc}) √† la ligne ${line}")\n"
    message+="$(gt "Pile d'appels :")\n"
    # Boucle sur la pile d‚Äôappels (stack trace)
    for (( i=${#FUNCNAME[@]}-1; i>=1; i-- )); do
        # i=0 correspond √† on_error elle-m√™me ‚Üí on la saute
        message+="$(gt "  ‚Ü≥ ")${FUNCNAME[$i]}() $(gt "depuis") ${BASH_SOURCE[$i]}:${BASH_LINENO[$((i-1))]}\n"
    done
    message+="‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    # Affichage dans dialog (prot√©ger les retours ligne)
    err_dial+=""
    err_dial=$(dialog --clear --backtitle "$(gt "Erreur critique")" --title "$(gt "Erreur d√©tect√©e")" \
           --msgbox "$(echo -e "$message")" 20 100 2>&1 >/dev/tty)
    # Log du message complet dans les fichiers d‚Äôerreur
    error "$(echo -e "$message")"
    exit "${rc}"
}
# V√©rifie si la version est compatible
function compatible() {
    debug_start
    local version="$1"
    local -n versions_array="$2"
    [[ ${versions_array[*]} =~ ${version} ]]
    debug_end
}
# V√©rifie si la distribution est prise en compte pour l'installation de GLPI
function check_distro(){
    debug_start
    # V√©rifie si le fichier os-release existe
    source_os_release
    # V√©rifie si la distribution est bas√©e sur Debian, Ubuntu, Alma Linux, Centos ou Rocky Linux
    if [[ "${ID}" =~ ^(debian|ubuntu|almalinux|centos|rocky|rhel)$ ]]; then
        if [[ "$ID" == "debian" || "$ID" == "ubuntu" ]]; then
            WEB_USER="www-data"
        else
            WEB_USER="nginx"
        fi
        if compatible "${VERSION_ID}" DEBIAN_VERSIONS || compatible "$VERSION_ID" UBUNTU_VERSIONS || compatible "$VERSION_ID" ALMA_VERSIONS || compatible "$VERSION_ID" CENTOS_VERSIONS || compatible "$VERSION_ID" ROCKY_VERSIONS || compatible "$VERSION_ID" REDHAT_VERSIONS; then
            info "$(gt "Distribution prise en charge")"
        else
            warn "$(gt "Distribution non prise en charge")"
            warn "$(gt "Souhaitez-vous forcer l'installation sur cette distribution ?")"
            if [ -t 0 ]; then
                info "$(gt "Forcer l'installation ? (O/N)")"
                read -r RESPONSE
                case $RESPONSE in
                    O|o|Y|y)
                        info "$(gt "Poursuite de l'installation...")"
                        ;;
                    N|n)
                        info "$(gt "Sortie...")"
                        return 1
                        ;;
                    *)
                        warn "$(gt "R√©ponse invalide")"
                        return 1
                        ;;
                esac
            else
                warn "$(gt "Abandon de l'installation en mode forc√©.")"
                return 1
            fi
        fi
        export VERSION_ID ID WEB_USER
    else
        warn "$(gt "Impossible de d√©terminer la distribution")"
        return 1
    fi
    export VERSION_ID ID WEB_USER
    debug_end
}
# Recherche si GLPI est d√©j√† install√©
function check_glpi_installed(){
    debug_start    
    FIND_REP_GLPI=$?
    glpi_dirs=()
    # Parcours des r√©pertoires standards √† explorer
    for path in ${PATHS_TO_CHECK}; do
        # Recherche des dossiers contenant "glpi" jusqu‚Äô√† 3 niveaux de profondeur
        FOUND=$(find "${path}" -maxdepth 3 -type d -name "*glpi*" 2>/dev/null)
        # Si un ou plusieurs r√©pertoires sont trouv√©s, on les ajoute au tableau
        if [[ -n "$FOUND" ]]; then
            # On lit chaque ligne de la sortie de find et on l‚Äôajoute au tableau
            while IFS= read -r dir; do
                glpi_dirs+=("$dir")
            done <<< "$FOUND"
        fi
    done
    #echo "R√©pertoires GLPI trouv√©s : ${glpi_dirs[*]}"
    export glpi_dirs FIND_REP_GLPI
    debug_end
}
# Recherche si des sauvegardes existent
function check_backups_existed(){
    debug_start    
    BACKUP_FOUND="no"
    # V√©rifie si le r√©pertoire de sauvegarde existe
    if [[ -d "${REP_BACKUP}" ]]; then
        # Recherche des fichiers de sauvegarde dans le r√©pertoire
        shopt -s nullglob
        backup_files=("${REP_BACKUP}"/*.tar.gz "${REP_BACKUP}"/*.zip)
        shopt -u nullglob
        if [[ ${#backup_files[@]} -gt 0 ]]; then
            BACKUP_FOUND="yes"
        fi
    fi
    export BACKUP_FOUND
    debug_end
}
# V√©rifie l'utilisateur web pour le r√©pertoire GLPI
function check_install_user(){
    debug_start
    info "${MSG_CHECK_WEB_USER}"
    REP_GLPI="${1:-/var/www/html/glpi}"
    if ! WEB_USER=$(stat -c '%U' "${REP_GLPI}") >/dev/null 2>&1; then
        debug "$(gt "Impossible de d√©terminer l'utilisateur web pour le r√©pertoire :") ${REP_GLPI}."
        return 1
    fi
    debug "$(gt "Utilisateur du service web trouv√© :") ${WEB_USER}"
    export WEB_USER REP_GLPI
    debug_end
}
# Choix entre installation ou mise √† jour
function selection_menu(){
    debug_start
    # Demander √† l'utilisateur s'il souhaite installer ou mettre √† jour GLPI
    SELECTED_MENU=$(dialog \
        --backtitle "$(gt "Utilitaire de GLPI")" \
        --title "$(gt "Options pour GLPI")" \
        --radiolist "$(gt "Choisissez une option :")" 15 50 3 \
        1 "$(gt "Installation de GLPI")" ON \
        2 "$(gt "Mise √† jour de GLPI")" OFF \
        3 "$(gt "Sauvegarde compl√®te de GLPI")" OFF \
        4 "$(gt "Restauration de GLPI")" OFF \
        5 "$(gt "Migration de GLPI")" OFF \
        "" "--------------------------------" OFF \
        7 "$(gt "Sortir")" OFF 2>&1 >/dev/tty)
    rc=$?
    export SELECTED_MENU
    if [[ $rc -ne 0 ]]; then
        error "$(gt "S√©lection annul√©e par l'utilisateur.")"
        dialog --clear --title "$(gt "Annulation")" --msgbox "$(gt "S√©lection annul√©e par l'utilisateur.")" 7 50
        return 1
    fi
    if [[ $rc == 7 ]]; then
        info "$(gt "Sortie demand√©e par l'utilisateur.")"
        return 100
    fi
    prompt_install_options
    debug_end
}
#  Demander √† l'utilisateur de choisir le r√©pertoire d'installation,
# la version de GLPI √† installer ou de lancer une installation compl√®te via dialog.
function prompt_install_options(){
    debug_start    
    if [[ "${SELECTED_MENU}" == 1 ]]; then # Installation de GLPI
        info "$(gt "Options d'installation de GLPI")"
        tags=""
        # R√©cup√®re les tags au format X.Y.Z
        tags=$(curl -s "${API_URL}" | jq -r '.[].name' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | grep -v -E '(rc|beta|alpha)' | sort -Vr | uniq | head -n 16)
        local args=() first=ON number=1 version_map=()
        while IFS= read -r tag; do
            args+=("${tag}" "" "${first}")
            first=OFF
        done <<< "${tags}"
        VERSION_SELECT=$(dialog --clear --backtitle "$(gt "Installation de GLPI")" --title "$(gt "Choix pour l'installation de GLPI")" \
        --radiolist "$(gt "Choisissez la version ?")" 23 50 8 "${args[@]}" 2>&1 >/dev/tty)
        local rc=$?
        if [ "${rc}" -ne 0 ]; then
            warn "$(gt "Arr√™t de l'installation par l'utilisateur.")"
            return 1
        fi
        # Formulaire des options d'installation
        local form="" WIDTH=0
        WIDTH_REP=$((${#$(gt "R√©pertoire d'installation")}))
        WIDTH_DB_HOST=$((${#$(gt "H√¥te de la Base de Donn√©es")}))
        WIDTH_DB_NAME=$((${#$(gt "Nom de la Base de Donn√©es")}))
        WIDTH_DB_USER=$((${#$(gt "Utilisateur de la Base de Donn√©es")}))
        WIDTH=$((WIDTH_REP > WIDTH_DB_HOST ? WIDTH_REP : WIDTH_DB_HOST))
        WIDTH=$((WIDTH > WIDTH_DB_NAME ? WIDTH : WIDTH_DB_NAME))
        WIDTH=$((WIDTH > WIDTH_DB_USER ? WIDTH : WIDTH_DB_USER))
        WIDTH=$((WIDTH + 6))
        local _def_rep="${REP_GLPI:-/var/www/html/glpi}" _def_db_host="${DB_HOST:-localhost}" _def_db="${DB_NAME:-glpi}" _def_user="${DB_USER:-glpi_user}"
        while true; do
            form=$(dialog --clear --backtitle "$(gt "Installation de GLPI")" --title "$(gt "Choix pour l'installation de GLPI")" \
                --form "$(gt "Param√®tres pour GLPI") ${VERSION_SELECT} $(gt "Modifiez et confirmez les valeurs ci-dessous")" 18 68 8 \
                "üìÅ $(gt "R√©pertoire d'installation")"         1 2 "${_def_rep}"     1 ${WIDTH} 20 40 \
                "üñ•Ô∏è $(gt "H√¥te de la Base de Donn√©es")"        3 2 "${_def_db_host}" 3 ${WIDTH} 20 20 \
                "üóÑÔ∏è $(gt "Nom de la Base de Donn√©es")"         5 2 "${_def_db}"      5 ${WIDTH} 20 20 \
                "üë§ $(gt "Utilisateur de la Base de Donn√©es")" 7 2 "${_def_user}"    7 ${WIDTH} 20 20 \
                2>&1 >/dev/tty)
            rc=$?
            # Transformer les lignes du formulaire en variables
            IFS=$'\n' read -r rep_glpi db_host db_name db_user <<< "$form"
            rep_glpi="${rep_glpi#"${rep_glpi%%[![:space:]]*}"}"; rep_glpi="${rep_glpi%"${rep_glpi##*[![:space:]]}"}"
            db_host="${db_host#"${db_host%%[![:space:]]*}"}"; db_host="${db_host%"${db_host##*[![:space:]]}"}"
            db_name="${db_name#"${db_name%%[![:space:]]*}"}"; db_name="${db_name%"${db_name##*[![:space:]]}"}"
            db_user="${db_user#"${db_user%%[![:space:]]*}"}"; db_user="${db_user%"${db_user##*[![:space:]]}"}"
            rep_glpi="${rep_glpi//[^A-Za-z0-9_\/.-]/_}"
            db_host="${db_host//[^A-Za-z0-9_\/.-]/_}"
            db_name="${db_name//[^A-Za-z0-9_]/_}"
            db_user="${db_user//[^A-Za-z0-9_]/_}"
            [ -z "$rep_glpi" ] && rep_glpi="$_def_rep"
            [ -z "$db_host" ] && db_host="$_def_db_host"
            [ -z "$db_name" ] && db_name="$_def_db"
            [ -z "$db_user" ] && db_user="$_def_user"
            if [[ ! "$db_name" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
                db_name="glpi_${db_name}"
            fi
            rep_glpi="${rep_glpi//\\//}"
            if [ -z "${rep_glpi}" ] || [[ "${rep_glpi}" != /* ]]; then
                rep_glpi="${_def_rep}"
            fi
            rep_glpi="$(printf '%s' "${rep_glpi}" | sed -E 's#/{2,}#/#g')"
            REP_GLPI="${rep_glpi%/}/"
            DB_HOST="$db_host"
            DB_NAME="$db_name"
            DB_USER="$db_user"
            # Si annulation ou ESC
            if [[ $rc -ne 0 ]]; then
                warn "$(gt "Arr√™t de l'installation par l'utilisateur.")"
                form=$(dialog --clear --title "$(gt "Installation de GLPI")" --msgbox "$(gt "S√©lection annul√©e par l'utilisateur.")" 7 60 2>&1 >/dev/tty)
                exit 1
            fi
            # --- VALIDATIONS ---
            # R√©pertoire d‚Äôinstallation
            if ! validate_glpi_path "$REP_GLPI"; then
                continue
            fi
            # H√¥te de la base de donn√©es
            if ! validate_db_host "$DB_HOST"; then
                continue
            fi
            # Nom de la base de donn√©es
            if ! validate_db_name "$DB_NAME"; then
                continue
            fi
            # Utilisateur de la base de donn√©es
            if ! validate_db_user "$DB_USER"; then
                continue
            fi
            # Si tout est valide
            break
        done
        # Assignation des valeurs finales
        local DOWNLOADLINK="https://github.com/glpi-project/glpi/releases/download/${VERSION_SELECT}/glpi-${VERSION_SELECT}.tgz"
        export DOWNLOADLINK DB_HOST REP_GLPI DB_NAME DB_USER INVOKING_HOME TIMEZONE VERSION_SELECT
        # Lancement de l‚Äôinstallation
        run_sequence "install"
    elif [[ "${SELECTED_MENU}" == 2 ]]; then # Mise √† jour de GLPI
        info "$(gt "Options de mise √† jour de GLPI")"
        check_glpi_installed
        # Si au moins un r√©pertoire GLPI trouv√©, demander √† l'utilisateur de choisir
        if [[ "${#glpi_dirs[@]}" -gt 0 ]]; then
            # Pr√©parer les arguments pour dialog
            find_rep=()
            rep_map=()
            number=1
            first="ON"
            # Correction : boucle while ‚Üí for (syntaxe correcte)
            for dir in "${glpi_dirs[@]}"; do
                find_rep+=("${number}" "${dir}" "${first}")
                rep_map+=("${dir}")
                first="OFF"
                ((number++))
            done
            # V√©rification utilisateur/distro avant ex√©cution
            if check_install_user "${REP_GLPI}"; then
                GLPI_CLI_VERSION=$(sudo -u "${WEB_USER}" php "${REP_GLPI}/bin/console" --no-ansi --version 2>/dev/null | awk '{print $3}' || true)
            fi
            # R√©cup√©ration des versions GLPI disponibles sur GitHub
            tags=""
            # R√©cup√®re les tags au format X.Y.Z
            tags=$(curl -s "${API_URL}" | jq -r '.[].name' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | grep -v -E '(rc|beta|alpha)' | sort -Vr | uniq | head -n 16)
            # Filtrage : ne garder que les versions avant GLPI_CLI_VERSION (donc plus r√©centes) ---
            newer_tags=()
            for tag in $tags; do
                [[ $tag == "$GLPI_CLI_VERSION" ]] && break
                newer_tags+=("$tag")
            done
            # Pr√©paration du menu de s√©lection de version GLPI
            tag=""; find_version=(); version_map=(); number=1; first="ON"
            for tag in "${newer_tags[@]}"; do
                find_version+=("" "GLPI ${tag}" "${first}")
                version_map+=("${tag}")
                first="OFF"
                ((number++))
            done
            # Menu de s√©lection d‚Äôinstallation GLPI
            FIND_REP_GLPI=$(dialog \
                --backtitle "$(gt "Mise √† jour de GLPI")" \
                --title "$(gt "S√©lection du r√©pertoire d'installation")" \
                --radiolist "$(gt "Veuillez s√©lectionner le r√©pertoire d'installation de GLPI :")" 20 70 8 \
                "${find_rep[@]}"  2>&1 >/dev/tty)
            rc=$?
            # Convertir le num√©ro choisi en index du tableau (0-based)
            local index=""
            index=$((FIND_REP_GLPI - 1))
            # R√©cup√©rer le vrai chemin correspondant
            REP_GLPI="${rep_map[$index]}"
            if [[ $rc -ne 0 ]]; then
                warn "$(gt "S√©lection annul√©e par l'utilisateur.")" | tee -a "${DEBUGFILE}"
                form=$(dialog --clear --title "$(gt "Annulation")" --msgbox "$(gt "Installation annul√©e par l'utilisateur.")" 7 50 2>&1 >/dev/tty)
                return 1
            fi
            # S√©lecteur de version GLPI
            VERSION_SELECT=$(dialog \
                --backtitle "$(gt "Mise √† jour de GLPI")" \
                --title "$(gt "S√©lection de la version")" \
                --radiolist "$(gt "Veuillez s√©lectionner la version de GLPI √† installer :")" 23 50 8 \
                "${find_version[@]}" 2>&1 >/dev/tty)
            rc=$?
            if [[ "${rc}" -ne 0 ]]; then
                warn "$(gt "S√©lection annul√©e par l'utilisateur.")"
                return 1
            fi
            # Convertir le num√©ro choisi en index du tableau (0-based)
            local index=""
            index=$((VERSION_SELECT - 1))
            # R√©cup√©rer le vrai tag correspondant
            VERSION_SELECT="${version_map[$index]}"
            form=$(dialog --clear --title "${MSG_INFO}" --msgbox "$(gt "Version install√©e :") ${VERSION_SELECT} $(gt ", dans le r√©pertoire :") ${REP_GLPI}" 10 100 2>&1 >/dev/tty)
            export DOWNLOADLINK="https://github.com/glpi-project/glpi/releases/download/${VERSION_SELECT}/glpi-${VERSION_SELECT}.tgz"
            export VERSION_SELECT REP_GLPI DOWNLOADLINK REP_BACKUP_COMPRESS INVOKING_HOME GLPI_CLI_VERSION
            # Lancement de la mise √† jour
            run_sequence "update"
        fi
    elif [[ "${SELECTED_MENU}" == 3 ]]; then # Sauvegarde compl√®te de GLPI
        info "$(gt "Options de sauvegarde de GLPI")"
        check_glpi_installed
        # Si au moins un r√©pertoire GLPI trouv√©, demander √† l'utilisateur de choisir
        if [[ "${#glpi_dirs[*]}" -gt 0 ]]; then
            # Pr√©parer les arguments pour dialog
            find_rep=()
            rep_map=()
            number=1
            first="ON"
            for dir in "${glpi_dirs[@]}"; do
                find_rep+=("${number}" "${dir}" "${first}")
                rep_map+=("${dir}")
                first="OFF"
                ((number++))
            done
            # S√©lecteur de r√©pertoire GLPI pour sauvegarde
            FIND_REP_GLPI=$(dialog \
                --backtitle "$(gt "Sauvegarde compl√®te de GLPI")" \
                --title "$(gt "S√©lection du r√©pertoire de sauvegarde")" \
                --radiolist "$(gt "Veuillez s√©lectionner le r√©pertoire de sauvegarde de GLPI :")" 20 70 8 \
                "${find_rep[@]}" 2>&1 >/dev/tty)
            rc=$?
            # Convertir le num√©ro choisi en index du tableau (0-based)
            local index=""
            index=$((FIND_REP_GLPI - 1))
            # R√©cup√©rer le vrai chemin correspondant
            REP_GLPI="${rep_map[$index]}"
            if [[ $rc -ne 0 ]]; then
                warn "$(gt "S√©lection annul√©e par l'utilisateur.")"
                form=$(dialog --clear --title "$(gt "Annulation")" --msgbox "$(gt "S√©lection annul√©e par l'utilisateur.")" 7 50 2>&1 >/dev/tty)
                return 1
            fi
            export REP_GLPI INVOKING_HOME REP_BACKUP_COMPRESS
            # Lancement de la sauvegarde
            run_sequence "backup"
        fi
    elif [[ "${SELECTED_MENU}" == 4 ]]; then # Restauration de GLPI
        info "$(gt "Options de restauration de GLPI")"
        # Recherche dans le r√©pertoire de sauvegardes
        check_backups_existed
        if [[ "${BACKUP_FOUND}" == true ]]; then
            prompt_restore_options
        fi
    elif [[ "${SELECTED_MENU}" == 5 ]]; then # Migration de GLPI
        info "$(gt "Options de migration de GLPI")"
        # Recherche dans le r√©pertoire de sauvegardes
        check_backups_existed
        # Si au moins un fichier de sauvegarde trouv√©, demander √† l'utilisateur de choisir
        if [[ "${#backup_files[@]}" -gt 0 ]]; then
            # Pr√©parer les arguments pour dialog
            find_bck=()
            rep_map=()
            number=1
            first="ON"
            for dir in "${backup_files[@]}"; do
                find_bck+=("${number}" "${dir}" "${first}")
                rep_map+=("${dir}")
                first="OFF"
                ((number++))
            done
            # S√©lecteur de r√©pertoire GLPI pour migration
            FIND_REP_GLPI=$(dialog \
                --backtitle "$(gt "Options de migration de GLPI")" \
                --title "$(gt "S√©lection du r√©pertoire de migration")" \
                --radiolist "$(gt "Veuillez s√©lectionner le r√©pertoire de migration de GLPI :")" 20 70 8 \
                "${find_bck[@]}" 2>&1 >/dev/tty)
            rc=$?
            # Convertir le num√©ro choisi en index du tableau (0-based)
            local index=""
            index=$((FIND_REP_GLPI - 1))
            # R√©cup√©rer le vrai chemin correspondant
            REP_GLPI="${rep_map[$index]}"
            if [[ $rc -ne 0 ]]; then
                warn "S√©lection annul√©e par l'utilisateur."
                form=$(dialog --title "Annulation" --msgbox "S√©lection annul√©e par l'utilisateur." 7 50 2>&1 >/dev/tty)
                return 1
            fi
            export REP_GLPI INVOKING_HOME REP_BACKUP_COMPRESS
            # Lancement de la restauration
            run_sequence "restore"      
        fi
    fi
    debug_end
}
# Valide le r√©pertoire d‚Äôinstallation de GLPI
function validate_glpi_path() {
    debug_start    
    local path="$1"
    local clean_path
    # Nettoyage
    clean_path="$(printf '%s' "$path" | tr -d '\r\n' | sed -E 's#/{2,}#/#g' \
        | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    # V√©rification du format
    if ! [[ "$clean_path" =~ ^(/var/www|/srv|/opt|/usr/share)/[^[:space:]]*glpi[^[:space:]]*$ ]]; then
        dialog --clear --title "$(gt "Validation du r√©pertoire d‚Äôinstallation de GLPI")" --msgbox "$(gt "R√©pertoire d‚Äôinstallation invalide :") ${clean_path}\n\n$(gt "Doit commencer par /var/www/, /srv/, /opt/ ou /usr/share/\net contenir 'glpi' dans le nom d‚Äôun dossier.")" 12 70
        warn "$(gt "Validation √©chou√©e : r√©pertoire d‚Äôinstallation invalide :") (${clean_path})"
        return 1
    fi
    debug_end
}
# Valide le r√©pertoire d‚Äôinstallation de GLPI
function validate_db_host() {
    debug_start    
    host=$1
    # Nettoyage de base
    clean_host=$(printf '%s' "$host" | tr -d '\r' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
    # Cas simples
    case "$clean_host" in
        localhost|::1|\[::1\])
            return 0 ;;
    esac
    # V√©rif IPv4 (structure correcte)
    if printf '%s\n' "${clean_host}" | grep -Eq '^([0-9]{1,3}\.){3}[0-9]{1,3}$'; then
        IFS=.
        set -- "${clean_host}"
        for o in "$@"; do
            case $o in
                *[!0-9]*) dbhost_err "${clean_host}"; return 1 ;;
            esac
            [ "$o" -ge 0 ] 2>/dev/null && [ "$o" -le 255 ] 2>/dev/null || {
                dbhost_err "${clean_host}"; return 1;
            }
        done
        return 0
    fi
    # V√©rif nom de domaine (FQDN simple)
    if printf '%s\n' "${clean_host}" | grep -Eq '^([A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?\.)+[A-Za-z]{2,}$'; then
        return 0
    fi
    # Sinon invalide
    dbhost_err "${clean_host}"
    debug_end
}
# Helper message d'erreur + log
function dbhost_err() {
    debug_start    
    v=$1
    dialog --clear --title "$(gt "Validation de l'h√¥te de la base de donn√©es")" --msgbox "$(gt "H√¥te de base de donn√©es invalide :") ${v}\n\n$(gt "Autoris√© : localhost, ::1/[::1], nom de domaine complet ou adresse IPv4.")" 10 70
    warn "${MSG_VALIDATE_DB_HOST_FAILED} (${v})"
    debug_end
    return 0
}
# Valide le nom de la base de donn√©es
function validate_db_name() {
    debug_start
    local name="$1"
    local clean_name
    clean_name="$(printf '%s' "$name" | tr -d '\r\n' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    # V√©rification du format du nom
    if [[ ! "$clean_name" =~ ^[A-Za-z_][A-Za-z0-9_]{0,63}$ ]]; then
        dialog --clear --title "$(gt "Validation du nom de la base de donn√©es")" \
               --msgbox "$(gt "Nom de base de donn√©es invalide :") ${clean_name}\n\n$(gt "Doit commencer par une lettre et ne contenir que des lettres, chiffres ou underscores (_).")" 12 70
        warn "$(gt "Nom de la base de donn√©es invalide :") (${clean_name})"
        debug_end
        return 1
    fi
    # V√©rifier si le nom est d√©j√† utilis√© dans les fichiers de sauvegarde
    local found_file
    found_file="$(find "${INVOKING_HOME}/saved_credentials" -type f -name "${FICHIER_MSG}${clean_name}*" -print -quit 2>/dev/null)"
    if [[ -n "$found_file" ]]; then
        local existing_name="${found_file##*${FICHIER_MSG}}"
        existing_name="${existing_name%%.*}"
        dialog --clear --title "$(gt "Validation du nom de la base de donn√©es")" \
               --msgbox "$(gt "Nom de base de donn√©es d√©j√† utilis√© :") ${existing_name}" 10 60
        warn "$(gt "Nom de base de donn√©es d√©j√† utilis√© :") ${existing_name}"
        debug_end
        return 1
    fi
    debug_end
    return 0
}
# Valide le nom d‚Äôutilisateur de la base de donn√©es
function validate_db_user() {
    debug_start    
    local user="$1"
    local clean_user
    clean_user="$(printf '%s' "${user}" | tr -d '\r\n' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    # V√©rification du format
    if [[ "${clean_user}" == "root" || ! "${clean_user}" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
        dialog --clear --title "$(gt "Validation de l'utilisateur de la base de donn√©es")" --msgbox "$(gt "Nom d‚Äôutilisateur invalide :") (${clean_user})" 12 70
        warn "$(gt "Nom d‚Äôutilisateur invalide :") (${clean_user})"
        debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
        return 1
    fi
    # v√©rification si mysql/mariadb est install√©
    #if command -v mysql >/dev/null 2>&1; then
        # r√©cupere le mot de passe root mysql/mariadb dans un fichier de sauvegarde .my.cnf
    #    local DB_ROOT_PASSWORD=""
        # recherche du fichier de sauvegarde sauve_mdp*
    #    if find "${INVOKING_HOME}/saved_credentials" -name "sauve_mdp*" -print -quit | grep -q .; then
    #        local SAUVE_MDP_FILE
    #        SAUVE_MDP_FILE=$(find "${INVOKING_HOME}" -name "sauve_mdp*" -print -quit)
    #        DB_ROOT_PASSWORD=$(grep -E '^password=' "${SAUVE_MDP_FILE}" | cut -d'=' -f2)
    #    fi
    #    if mysql -h "${DB_HOST}" -u root -p"${DB_ROOT_PASSWORD}" -e "SELECT User FROM mysql.user WHERE User='${clean_user}';" 2>/dev/null | grep -q "${clean_user}"; then
    #        dialog --clear --msgbox "${MSG_VALIDATE_DB_USER_DIALOG_FAILED_2} ${clean_user}${MSG_VALIDATE_DB_USER_DIALOG_FAILED_3}" 12 70
    #        warn "${MSG_VALIDATE_DB_USER_FAILED_2} (${clean_user})"
    #        return 1
    #    fi
    #fi
    debug_end
}
# Sequence principale d'installation et de mise √† jour de GLPI
function run_sequence() {
    debug_start
    trap 'on_error' ERR
    local mode="$1"
    declare -A tasks
    local task_order=()
    # --- S√©lection du mode ---
    case "${mode}" in
        install)
            tasks=(
                ["$(gt "Mise √† jour de la distribution")"]="update_distro"
                ["$(gt "Installation des paquets")"]="install_packages"
                ["$(gt "Informations r√©seau")"]="network_info"
                ["$(gt "Configuration de MariaDB")"]="mariadb_configure"
                ["$(gt "T√©l√©chargement et extraction de GLPI") ${VERSION_SELECT}"]="download_untar_glpi"
                ["$(gt "Configuration de GLPI") ${VERSION_SELECT}"]="setup_glpi"
                ["$(gt "Mise √† jour de l'utilisateur GLPI")"]="maj_user_glpi"
                ["$(gt "√âcriture des informations d'identification")"]="write_credentials"
            )
            task_order=(
                "$(gt "Mise √† jour de la distribution")" "$(gt "Installation des paquets")" "$(gt "Informations r√©seau")" "$(gt "Configuration de MariaDB")" "$(gt "T√©l√©chargement et extraction de GLPI") ${VERSION_SELECT}" "$(gt "Configuration de GLPI") ${VERSION_SELECT}" "$(gt "Mise √† jour de l'utilisateur GLPI")" "$(gt "√âcriture des informations d'identification")"
            )
            ;;
        update)
            tasks=(
                ["$(gt "Maintenance 1")"]="maintenance 1"
                ["$(gt "Mise √† jour de la distribution")"]="update_distro"
                ["$(gt "Sauvegarde de GLPI")"]="backup_glpi"
                ["$(gt "Suppression de l'ancienne version de GLPI")"]="remove_old_glpi"
                ["$(gt "T√©l√©chargement et extraction de GLPI") ${VERSION_SELECT}"]="download_untar_glpi"
                ["$(gt "Mise √† jour de GLPI")"]="update_glpi"
                ["$(gt "Maintenance 0")"]="maintenance 0"
            )
            task_order=(
                "$(gt "Maintenance 1")" "$(gt "Mise √† jour de la distribution")" "$(gt "Sauvegarde de GLPI")" "$(gt "Suppression de l'ancienne version de GLPI")" "$(gt "T√©l√©chargement et extraction de GLPI") ${VERSION_SELECT}" "$(gt "Mise √† jour de GLPI")" "$(gt "Maintenance 0")"
            )
            ;;
        backup)
            tasks=(
                ["$(gt "Sauvegarde compl√®te de GLPI")"]="backup_glpi_all"
            )
            task_order=(
                "$(gt "Sauvegarde compl√®te de GLPI")"
            )
            ;;
        restore)
            tasks=(
                ["$(gt "Restauration compl√®te de GLPI")"]="restore_glpi_all"
            )
            task_order=(
                "$(gt "Restauration compl√®te de GLPI")"
            )
            ;;
        migrate)
            tasks=(
                ["$(gt "Migration compl√®te de GLPI")"]="migrate_glpi_all"
            )
            task_order=(
                "$(gt "Migration compl√®te de GLPI")"
            )
            ;;
        *)
            warn "$(gt "Mode inconnu : ${mode} ‚Äî modes valides : install | update | backup | restore | migrate")"
            return 1
            ;;
    esac
    # --- Initialisation ---
    local total_tasks=${#task_order[@]}
    local task_index=0
    (
    for task_key in "${task_order[@]}"; do
        ((task_index++))
        local progress=$((task_index * 100 / total_tasks))
        local task_cmd="${tasks[${task_key}]}"
        # --- Affichage dans la jauge ---
        echo "${progress}"
        echo "XXX"
        echo "${task_index}/${total_tasks} - ${task_key} ‚è≥"
        echo "XXX"
        debug "$(date '+%F %T') [$$][DEBUG] $(gt "D√©but de la s√©quence :") ${mode} - '${task_key}' ‚Üí ${task_cmd}"
        # --- Ex√©cution de la t√¢che ---
        if run_task "${task_key}" "${task_cmd}" "${task_index}" "${total_tasks}" >/dev/null 2>&1; then
            echo "${progress}"
            echo "XXX"
            echo "${task_index}/${total_tasks} - ${task_key} ‚úîÔ∏è"
            echo "XXX"
            debug "$(date '+%F %T') [$$][DEBUG] ‚úîÔ∏è $(gt "Fin de la s√©quence :") ${mode} - '${task_key}'."
            sleep 0.5  # l√©g√®re pause visuelle
        else
            echo "100"
            echo "XXX"
            echo "${task_index}/${total_tasks} - ${task_key} ‚ùå"
            echo "XXX"
            debug "$(date '+%F %T') [$$][DEBUG] ‚ùå $(gt "Fin de la s√©quence :") ${mode} - '${task_key}'."
            sleep 3
            exit 1  # << plus s√ªr que return dans un sous-shell
        fi
    done
        ) | dialog --clear \
           --backtitle "$(gt "Installation de GLPI")" \
           --title "$(gt "Progression")" \
           --gauge "" 8 120 >/dev/tty 2>&1
    # --- V√©rification du sous-shell ---
    if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
        warn "$(gt "Une t√¢che a √©chou√© pendant l'ex√©cution du mode :") (${mode})"
        return 1
    fi
    info "$(gt "Toutes les t√¢ches du mode") (${mode}) $(gt "ont √©t√© ex√©cut√©es avec succ√®s.")"
    debug_end
}
# Ex√©cute une t√¢che individuelle
function run_task() {
    trap 'on_error' ERR
    local task_key="$1" task_cmd="$2" index="$3" total="$4"
    debug_start
    debug "$(gt "Commande") ${task_cmd} ${task_key}/${total}"
    # Ex√©cution isol√©e
    local output exit_code
    output=$(eval "${task_cmd}" 2>&1)
    exit_code=$?
    if (( exit_code == 0 )); then
        debug "${task_key} - $(gt "termin√©e avec succ√®s") - '${task_cmd}'"
        [[ -n "${output}" ]] && debug "‚Ü≥ ${output}"
    else
        warn "${task_key} - $(gt "√©chou√©e") - '${task_cmd}' -> (exit=${exit_code})"
        [[ -n "${output}" ]] && warn "‚Ü≥ ${output}"
        return ${exit_code}
    fi
    debug_end
}
# Mise √† jour de la distribution
function update_distro(){
    debug_start
    if [[ "${ID}" =~ ^(debian|ubuntu)$ ]]; then
           info "${MSG_UPDATE_DISTRO_START}"
           timedatectl set-ntp true # Synchronise l'heure
           sleep 5
           apt-get update && apt-get upgrade -y >> "${UPDATEFILE}" 2>> "${ERRORFILE}"
    elif [[ "${ID}" =~ ^(almalinux|centos|rocky|rhel)$ ]]; then
           info "${MSG_UPDATE_DISTRO_START}"
           chronyc makestep # Synchronise l'heure
           sleep 5
           yum update -y && yum upgrade -y >> "${UPDATEFILE}" 2>> "${ERRORFILE}"
    else
        warn "$(gt "Mise √† jour de la distribution non prise en charge")"
        exit 1
    fi
    debug_end
}
# Adresse IP de la machine
function network_info() {
    debug_start    
    # D√©tection de l‚Äôinterface principale (hors loopback et interfaces virtuelles)
    INTERFACE=$(ip route get 1.1.1.1 2>/dev/null | awk '/dev/ {print $5; exit}')
    if [[ -z "${INTERFACE}" ]]; then
        INTERFACE=$(ip -o link show | awk -F': ' '!/lo|docker|vir|veth/ {print $2; exit}')
    fi
    # R√©cup√©ration de l‚Äôadresse IP associ√©e
    IPADRESS=$(ip -4 addr show "${INTERFACE}" 2>/dev/null | awk '/inet / {print $2}' | cut -d'/' -f1 | head -n1)
    # V√©rification et export
    if [[ -n "${IPADRESS}" ]]; then
        # Adresse IP valide trouv√©e
        info "$(gt "Interface r√©seau d√©tect√©e :") ${INTERFACE}, $(gt "Adresse IP d√©tect√©e :") ${IPADRESS}"
        export IPADRESS
    else
        # Aucune adresse IP valide trouv√©e
        warn "$(gt "Impossible de d√©terminer l‚Äôadresse IP du serveur via l‚Äôinterface r√©seau principale.")"
        IPADRESS="127.0.0.1"
        export IPADRESS
    fi
    debug_end
}
# Installation des √©l√©ments n√©cessaire
function install_packages(){
    debug_start    
    info "$(gt "D√©but de l'installation des paquets n√©cessaires...")"
    source_os_release
    if [[ "${ID:-}" =~ ^(debian|ubuntu)$ ]]; then
        export DEBIAN_FRONTEND=noninteractive
        # update cache first
        if command -v sudo apt-get update | sudo tee -a "${UPDATEFILE}" 2> >(sudo tee -a "${ERRORFILE}" >&2); then
            debug "apt-get upgrade -y"
            if ! sudo apt-get upgrade -y | sudo tee -a "${UPDATEFILE}" 2> >(sudo tee -a "${ERRORFILE}" >&2); then
                warn "$(gt "√âchec de la mise √† jour des paquets.")"
            fi
        fi
        if ! sudo apt-get install -y php-{bcmath,mysql,mbstring,curl,gd,xml,intl,ldap,apcu,opcache,xmlrpc,zip,bz2} | sudo tee -a "${UPDATEFILE}" 2> >(sudo tee -a "${ERRORFILE}" >&2); then
            error "$(gt "√âchec de l'installation des extensions PHP requises.")"
            return 1
        else
            info "$(gt "Installation des extensions PHP requises termin√©e avec succ√®s.")"
        fi
        if ! sudo apt-get install -y wget tar apache2 apache2-bin mariadb-server mariadb-client perl php | sudo tee -a "${UPDATEFILE}" 2> >(sudo tee -a "${ERRORFILE}" >&2); then
            error "$(gt "√âchec de l'installation des services requis.")"
            return 1
        else
            info "$(gt "Installation des services requis termin√©e avec succ√®s.")"
        fi
        manage_service "mariadb" "MariaDB" || return 1
        manage_service "apache2" "Apache2" || return 1
    fi
    if [[ "${ID:-}" =~ ^(almalinux|centos|rocky|rhel|fedora)$ ]]; then
        sudo dnf makecache --refresh
        if ! command -v dnf >/dev/null 2>&1; then
            error "$(gt "dnf introuvable, impossible d'installer les paquets sur la branche RHEL-like.")" | tee -a "${ERRORFILE}"
            return 1
        fi
        if sudo dnf makecache --refresh | sudo tee -a "${DEBUGFILE}" 2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "$(gt "Cache DNF rafra√Æchi avec succ√®s.")"
        else
            error "$(gt "√âchec du rafra√Æchissement du cache DNF.")"
        fi
        if sudo dnf install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "$(gt "Installation du d√©p√¥t EPEL termin√©e avec succ√®s.")"
        else
            error "$(gt "√âchec de l'installation du d√©p√¥t EPEL.")"
            return 1
        fi
        if sudo dnf module reset -y php nginx mariadb composer \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "$(gt "R√©initialisation des modules DNF termin√©e avec succ√®s.")"
        else
            error "$(gt "√âchec de la r√©initialisation des modules DNF.")"
            return 1
        fi
        if sudo dnf module install -y php:8.2 \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "$(gt "Installation du module PHP termin√©e avec succ√®s.")"
        else
            error "$(gt "√âchec de l'installation du module PHP.")"
            return 1
        fi
        if sudo dnf module install -y nginx:1.24 \
            | sudo tee -a "${DEBUGFILE}" \
            2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "$(gt "Installation du module NGINX termin√©e avec succ√®s.")"
        else
            error "$(gt "√âchec de l'installation du module NGINX.")"
            return 1
        fi
        if sudo dnf module install -y mariadb:10.11 \
                | sudo tee -a "${DEBUGFILE}" \
                2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "$(gt "Installation du module MariaDB termin√©e avec succ√®s.")"
        else
            error "$(gt "√âchec de l'installation du module MariaDB.")"
            return 1
        fi
        if sudo dnf install -y dnf-automatic \
                | sudo tee -a "${DEBUGFILE}" \
                2> >(sudo tee -a "${ERRORFILE}" >&2); then
            info "$(gt "Installation de dnf-automatic termin√©e avec succ√®s.")"
        else
            error "$(gt "√âchec de l'installation de dnf-automatic.")"
            return 1
        fi
        sed -i 's/^\s*;\?\s*\(apply_updates\s*=\s*\).*/\1yes/' /etc/dnf/automatic.conf
        sed -i 's/^\s*;\?\s*\(reboot\s*=\s*\).*/\1when-needed/' /etc/dnf/automatic.conf
        sed -i 's/^\s*;\?\s*\(upgrade_type\s*=\s*\).*/\1security/' /etc/dnf/automatic.conf
        if sudo mkdir -p /etc/systemd/system/dnf-automatic.timer.d | sudo tee -a "${DEBUGFILE}" 2>>"${ERRORFILE}"; then
            info "$(gt "Cr√©ation du r√©pertoire d'override de dnf-automatic.timer r√©ussie.")"
        else
            warn "$(gt "√âchec de la cr√©ation du r√©pertoire d'override de dnf-automatic.timer.")"
            return 1
        fi
        sudo tee /etc/systemd/system/dnf-automatic.timer.d/override.conf <<'EOF'
[Unit]
    Description=dnf-automatic timer
    ConditionPathExists=!/run/ostree-booted
    Wants=network-online.target

[Timer]
    OnCalendar=*-*-* 6:00
    RandomizedDelaySec=60m
    Persistent=true
EOF
        info "$(gt "Fichier override.conf pour dnf-automatic cr√©√© avec succ√®s.")"
        if systemctl enable --now dnf-automatic.timer; then
            info "$(gt "Activation de dnf-automatic.timer termin√©e avec succ√®s.")"
        else
            warn "$(gt "√âchec de l'activation de dnf-automatic.timer.")"
            return 1
        fi
        if dnf install -y php-{bcmath,mysql,mbstring,curl,gd,xml,intl,ldap,apcu,opcache,xmlrpc,zip,bz2}; then
            info "$(gt "Installation des extensions PHP termin√©e avec succ√®s.")"
        else
            warn "$(gt "√âchec de l'installation des extensions PHP.")"
            return 1
        fi
        if dnf install -y crontabs logrotate cronie tar nginx mariadb-server mariadb perl curl jq php epel-release; then
            info "$(gt "Installation des paquets et services LAMP termin√©e avec succ√®s.")"
        else
            warn "$(gt "√âchec de l'installation des paquets et services LAMP.")"
            return 1
        fi
        sed -i 's/^\(;\?\)\(user =\).*/\2 nginx/' /etc/php-fpm.d/www.conf
        sed -i 's/^\(;\?\)\(group =\).*/\2 nginx/' /etc/php-fpm.d/www.conf
        if systemctl enable --now mariadb nginx php-fpm; then
            info "$(gt "Activation et d√©marrage des services MariaDB, NGINX et PHP-FPM termin√©s avec succ√®s.")"
        else
            warn "$(gt "√âchec de l'activation et du d√©marrage des services MariaDB, NGINX et PHP-FPM.")"
            return 1
        fi
        if firewall-cmd --permanent --zone=public --add-service=http && firewall-cmd --reload; then
            info "$(gt "Configuration du pare-feu pour HTTP termin√©e avec succ√®s.")"
        else
            warn "$(gt "√âchec de la configuration du pare-feu pour HTTP.")"
            return 1
        fi
    fi
    info "${MSG_INSTALL_PACKAGES_END}"
    debug_end
}
function manage_service() {
    debug_start
    local service="$1"
    local label="$2"
    info "$(gt "Activation et d√©marrage du service :") ${label}..."
    # Activer et red√©marrer le service avec journalisation
    {
        systemctl enable "${service}"
        systemctl restart "${service}"
    } || {
        error "$(gt "√âchec lors de la gestion du service :") ${label}."
        return 1
    }
    # V√©rifier l'√©tat du service
    if systemctl is-active --quiet "${service}"; then
        info "$(gt "Service g√©r√© avec succ√®s :") ${label}."
    else
        warn "$(gt "Le service n'est pas actif ‚Äî d√©marrage forc√©..")"
        # Forcer le red√©marrage une seconde fois
        {
            systemctl restart "${service}"
        } || {
            error "$(gt "√âchec du d√©marrage du service :") ${label}."
            return 1
        }
        # V√©rifier √† nouveau l'√©tat du service
        if systemctl is-active --quiet "${service}"; then
            info "$(gt "Service d√©marr√© avec succ√®s :") ${label}."
        else
            error "$(gt "Le service est toujours inactif apr√®s tentative de d√©marrage :") ${label}."
            return 1
        fi
    fi
    debug_end
}
# D√©tection du fuseau horaire syst√®me
function get_timezone() {
    debug_start
    info "${MSG_DETECT_TIMEZONE:-D√©tection du fuseau horaire...}"
    # Si TIMEZONES n‚Äôest pas encore d√©fini
    if [ -z "${TIMEZONES:-}" ]; then
        local tzfile=""
        if command -v timedatectl >/dev/null 2>&1; then # timedatectl (m√©thode la plus fiable)
            TIMEZONES=$(timedatectl show -p Timezone --value 2>/dev/null || true)
        fi
        if [ -z "${TIMEZONES:-}" ] && [ -f /etc/timezone ]; then # Fichier /etc/timezone (Debian/Ubuntu)
            TIMEZONES=$(head -n 1 /etc/timezone 2>/dev/null || true)
        fi
        if [ -z "${TIMEZONES:-}" ]; then # Lien symbolique /etc/localtime (m√©thode universelle)
            if [ -L /etc/localtime ] || [ -f /etc/localtime ]; then
                tzfile=$(readlink -f /etc/localtime 2>/dev/null || true)
                if [[ "$tzfile" == *"/usr/share/zoneinfo/"* ]]; then
                    TIMEZONES="${tzfile#*/usr/share/zoneinfo/}"
                fi
            fi
        fi
        if [ -z "${TIMEZONES:-}" ] && [ -f /etc/sysconfig/clock ]; then # /etc/sysconfig/clock (RHEL / CentOS)
            TIMEZONES=$(awk -F= '/^ZONE/ {gsub(/"/,"",$2); print $2}' /etc/sysconfig/clock 2>/dev/null || true)
        fi
        if [ -z "${TIMEZONES:-}" ]; then # Par d√©faut si rien trouv√©
            TIMEZONES="UTC"
        fi
        TIMEZONES="$(echo "${TIMEZONES}" | xargs)"
        export TIMEZONES
        info "$(gt "Fuseau horaire d√©tect√© :") ${TIMEZONES}"
    else
        info "$(gt "Fuseau horaire d√©j√† d√©fini :") ${TIMEZONES}"
    fi
    debug_end
}
# Configuration de la base de donn√©es MariaDB
function mariadb_configure() {
    debug_start
    trap 'on_error' ERR
    set -E -o pipefail
    info "$(gt "Configuration de la base de donn√©es")"
    # --- D√©tection de la commande MySQL ---
    MYSQL_CMD=$(command -v mysql || command -v mariadb || echo mysql)
    if [[ -z "${MYSQL_CMD}" ]]; then
        error "$(gt "Commande MySQL/MariaDB introuvable.")"
        return 1
    fi
    # --- D√©termination du fuseau horaire ---
    get_timezone
    TIMEZONES="${TIMEZONES:-Europe/Paris}"
    info "Utilisation de la commande : ${MYSQL_CMD}"
    info "Connexion √† l'h√¥te : ${DB_HOST}"
    info "Mot de passe root : ${SQLROOTPWD}"
    info "Cr√©ation base : ${DB_NAME}"
    info "Utilisateur : ${DB_USER}"
    info "Mdp utilisateur : ${SQLGLPIPWD}"
    info "Timezone : ${TIMEZONES}"
    # --- Script SQL principal ---
    local _sql_root
    _sql_root=$(cat <<SQL
ALTER USER 'root'@'localhost' IDENTIFIED BY '${SQLROOTPWD}';
DELETE FROM mysql.user WHERE User = '';
DELETE FROM mysql.user WHERE User = 'root' AND Host != 'localhost';
DROP DATABASE IF EXISTS test;
DELETE FROM mysql.db WHERE Db = 'test' OR Db LIKE 'test_%';
GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION;
FLUSH PRIVILEGES;
CREATE DATABASE IF NOT EXISTS \`${DB_NAME}\` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE USER IF NOT EXISTS '${DB_USER}'@'localhost' IDENTIFIED BY '${SQLGLPIPWD}';
GRANT ALL PRIVILEGES ON \`${DB_NAME}\`.* TO '${DB_USER}'@'localhost';
GRANT SELECT ON mysql.time_zone_name TO '${DB_USER}'@'localhost';
GRANT SELECT ON mysql.time_zone TO '${DB_USER}'@'localhost';
FLUSH PRIVILEGES;
SQL
    )
    # --- Application du script SQL ---
    if echo "${_sql_root}" \
        | { sudo "${MYSQL_CMD}" -u root -p"${SQLROOTPWD}" --batch --silent 2>>"${ERRORFILE}" || \
            sudo "${MYSQL_CMD}" -u root --batch --silent 2>>"${ERRORFILE}"; } >> "${DEBUGFILE}"; then
        info "$(gt "Configuration de la base de donn√©es termin√©e avec succ√®s.")"
    else
        warn "$(gt "Erreur SQL lors de l'installation")"
        return 1
    fi
    # --- V√©rification de la cr√©ation de base ---
    if ! sudo "${MYSQL_CMD}" -u root -p"${SQLROOTPWD}" -e "USE ${DB_NAME};" >/dev/null 2>&1; then
        error "$(gt "Impossible d'acc√©der √† la base :") ${DB_NAME}"
        return 1
    fi
    # --- V√©rification des tables timezone ---
    local TIMEZONE_TABLE_COUNT
    TIMEZONE_TABLE_COUNT=$(
        echo "SELECT COUNT(*) FROM mysql.time_zone_name WHERE name = '${TIMEZONES}' LIMIT 1;" \
        | {
            sudo "${MYSQL_CMD}" -u root -p"${SQLROOTPWD}" --batch --skip-column-names --silent 2>>"${ERRORFILE}" \
            || sudo "${MYSQL_CMD}" -u root --batch --skip-column-names --silent 2>>"${ERRORFILE}"
        } 2>>"${ERRORFILE}"
    )
    if [[ -z "${TIMEZONE_TABLE_COUNT}" || "${TIMEZONE_TABLE_COUNT}" -eq 0 ]]; then
        info "${MSG_MARIADB_CONFIGURE_TIMEZONE_IMPORT}"
        # --- V√©rification pr√©sence mysql_tzinfo_to_sql ---
        if ! command -v mysql_tzinfo_to_sql >/dev/null 2>&1; then
            warn "$(gt "La commande mysql_tzinfo_to_sql est introuvable, impossible d'importer les fuseaux horaires.")"
            return 1
        fi
        # --- Importation des fuseaux horaires ---
        local mysql_exec="sudo ${MYSQL_CMD:-mysql}"
        local rc=0
        if sudo mysql_tzinfo_to_sql /usr/share/zoneinfo 2>>"${ERRORFILE}" \
            | ${mysql_exec} -u root -p"${SQLROOTPWD}" mysql >>"${DEBUGFILE}" 2>>"${ERRORFILE}"; then
            rc=0
        elif sudo mysql_tzinfo_to_sql /usr/share/zoneinfo 2>>"${ERRORFILE}" \
            | ${mysql_exec} -u root mysql >>"${DEBUGFILE}" 2>>"${ERRORFILE}"; then
            rc=0
        else
            rc=$?
        fi
        debug "$(gt "Code retour de l'import des timezones :") ${rc}"

        if [[ "${rc}" -eq 0 ]]; then
            info "$(gt "Importation des fuseaux horaires termin√©e avec succ√®s.")"
        else
            warn "$(gt "Erreur: import du timezone √©chou√©.")"
            return 1
        fi
        # --- Param√©trage du fuseau horaire ---
        local _sql_tz
        _sql_tz=$(cat <<SQL
SET GLOBAL time_zone = '${TIMEZONES}';
SET time_zone = '${TIMEZONES}';
GRANT SELECT ON mysql.time_zone_transition TO '${DB_USER}'@'localhost';
GRANT SELECT ON mysql.time_zone_transition_type TO '${DB_USER}'@'localhost';
FLUSH PRIVILEGES;
SQL
        )
        if echo "${_sql_tz}" \
            | { sudo "${MYSQL_CMD}" -u root -p"${SQLROOTPWD}" --batch --silent 2>>"${ERRORFILE}" || \
                sudo "${MYSQL_CMD}" -u root --batch --silent 2>>"${ERRORFILE}"; } >> "${DEBUGFILE}"; then
            info "$(gt "Configuration du fuseau horaire dans MariaDB termin√©e avec succ√®s.")"
        else
            warn "$(gt "Erreur lors de la configuration du fuseau horaire dans MariaDB.")"
            return 1
        fi
    else
        info "$(gt "Les tables de fuseaux horaires existent d√©j√† dans MariaDB, pas d'import n√©cessaire.")"
    fi
    # --- Red√©marrage du service ---
    if systemctl is-active --quiet mariadb; then
        info "$(gt "Red√©marrage du service MariaDB...")"
        manage_service "mariadb" "MariaDB" || return 1
    fi
    debug_end
}
# T√©l√©chargement et d√©compression de GLPI
function download_untar_glpi(){
    debug_start    
    trap 'on_error' ERR
    set -Euo pipefail
    info "$(gt "T√©l√©chargement et extraction de GLPI") ${VERSION_SELECT} $(gt "dans le r√©pertoire") ${REP_GLPI}"
    "${REP_GLPI}"
    if [[ -z "${DOWNLOADLINK:-}" ]]; then
        warn "$(gt "Lien de t√©l√©chargement de GLPI non d√©fini.")"
        return 1
    fi
    # T√©l√©chargement de GLPI
    tmp_file="$(mktemp /tmp/glpi_XXX.tar.gz)"
    info "$(gt "T√©l√©chargement") ${DOWNLOADLINK} $(gt "dans le r√©pertoire") ${tmp_file}"
    if wget -q -O "$tmp_file" "${DOWNLOADLINK}" >> "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
        info "$(gt "T√©l√©chargement de GLPI termin√©s avec succ√®s.")"
    else
        warn "$(gt "√âchec du t√©l√©chargement de GLPI.")"
        rm -f "$tmp_file"
        return 1
    fi
    # V√©rification de l'int√©grit√© du fichier t√©l√©charg√©
    info "$(gt "V√©rification de l'int√©grit√© du fichier t√©l√©charg√©...")"
    EXPECTED_HASH=$(curl -s -H "User-Agent: glpi-installer" "${API_URL_SHA256}/${VERSION_SELECT}" \
    | grep '"digest":' \
    | sed -E 's/.*"sha256:([0-9a-f]+)".*/\1/' \
    | head -n 1)
    if ! [[ -n "$EXPECTED_HASH" ]]; then
        EXPECTED_HASH="poc"
    fi
    ACTUAL_HASH=$(sha256sum "$tmp_file" | awk '{print $1}')
    if [[ -n "$EXPECTED_HASH" ]]; then
        if ! [[ "$EXPECTED_HASH" != "$ACTUAL_HASH" ]]; then
            info "‚úîÔ∏è $(gt "V√©rification de l'int√©grit√© r√©ussie.")"
        else
            info "$(gt "√âchec de la v√©rification de l'int√©grit√© du fichier t√©l√©charg√©.")"
        fi
    fi
    # Cr√©ation du r√©pertoire d'installation si n√©cessaire
    if mkdir -p "$REP_GLPI"; then
        info "$(gt "R√©pertoire d'installation de GLPI cr√©√© :") ${REP_GLPI}"
    else
        warn "$(gt "√âchec de la cr√©ation du r√©pertoire d'installation de GLPI.")"
        rm -f "$tmp_file"
        return 1
    fi
    # Extraction de l‚Äôarchive GLPI
    if tar -xzf "$tmp_file" -C "$REP_GLPI" --strip-components=1; then
        info "$(gt "Extraction de GLPI termin√©e avec succ√®s.")"
        rm -f "$tmp_file"
    else
        warn "$(gt "√âchec de l'extraction de GLPI.")"
        rm -f "$tmp_file"
        return 1
    fi
    sync # S'assurer que toutes les √©critures sont termin√©es
    debug_end
}
# Mise en place des r√©glage pour GLPI
function setup_glpi(){
    debug_start
    trap 'on_error' ERR
    set -Euo pipefail
    info "$(gt "Mise en place des r√©glages pour GLPI...")"
    source_os_release
    local CMD=(
    php "${REP_GLPI}bin/console" db:install
    --db-host "${DB_HOST}"
    --db-port=3306
    --db-name="${DB_NAME}"
    --db-user="${DB_USER}"
    --db-password="${SQLGLPIPWD}"
    --default-language="${LANGUAGE}"
    --force
    --no-telemetry
    --quiet
    --no-interaction
    )
    info "H√¥te de la base de donn√©es : ${DB_HOST}"
    info "Nom de la base de donn√©es : ${DB_NAME}"
    info "Utilisateur de la base de donn√©es : ${DB_USER}"
    info "MDP : ${SQLGLPIPWD}"
    
    # D√©finition des fichiers
    FILE_APACHE_CONF="/etc/apache2/sites-available/${DB_NAME}.conf"
    
    info "$(gt "Cr√©ation du r√©pertoire des logs.")"
    declare -A GLPI_DIRS=(
    [LOGS]="/var/log/${DB_NAME}"
    [CONFIG]="/etc/${DB_NAME}/config"
    [FILES]="/var/lib/${DB_NAME}/files"
    )
    # Cr√©ation des r√©pertoires
    for key in "${!GLPI_DIRS[@]}"; do
        folder="${GLPI_DIRS[$key]}"
        msg_ok_var="$(gt "Cr√©ation du r√©pertoire") ${key}"
        msg_fail_var="$(gt "√âchec de cr√©er le r√©pertoire") ${key}"
        if mkdir -p "$folder"; then
            info "${!msg_ok_var}"
        else
            warn "${!msg_fail_var}${DB_NAME}."
            return 1
        fi
    done
    # D√©placement des fichiers GLPI
    info "$(gt "D√©placement du r√©pertoire des fichiers GLPI")"
    if mv -f "${REP_GLPI}files/*" "${GLPI_DIRS[FILES]}/" 2>/dev/null; then
        info "$(gt "R√©pertoire des fichiers GLPI d√©plac√© avec succ√®s.")"
    else
        warn "$(gt "√âchec du d√©placement du r√©pertoire des fichiers GLPI.")"
        return 1
    fi
    # Cr√©ation du fichier local_define.php
    info "$(gt "Cr√©ation du fichier local_define.php")"
    if sudo tee "${GLPI_DIRS[CONFIG]}/local_define.php" >/dev/null <<EOF
<?php
    define('GLPI_VAR_DIR', '${GLPI_DIRS[FILES]}');
    define('GLPI_LOG_DIR', '${GLPI_DIRS[LOGS]}');
EOF
    then
        info "$(gt "Fichier local_define.php cr√©√© avec succ√®s.")"
    else
        warn "$(gt "√âchec de la cr√©ation du fichier local_define.php.")"
        return 1
    fi
    info "$(gt "Cr√©ation du fichier downstream.php")"
    if sudo tee "${REP_GLPI}"/inc/downstream.php >/dev/null <<EOF
<?php
    define('GLPI_CONFIG_DIR', '${FOLDER_CONFIG}');
    if (file_exists(GLPI_CONFIG_DIR . '/local_define.php')) {
        require_once GLPI_CONFIG_DIR . '/local_define.php';
    }
EOF
    then
        info "$(gt "Fichier downstream.php cr√©√© avec succ√®s.")"
    else
        warn "$(gt "√âchec de la cr√©ation du fichier downstream.php.")"
        return 1
    fi
    # Change permissions
    info "$(gt "Modification des permissions de") ${REP_GLPI}"
    if rights_glpi "${REP_GLPI}"; then
        info "$(gt "Permissions de") ${REP_GLPI} $(gt "modifi√©es avec succ√®s.")"
    else
        warn "$(gt "√âchec de la modification des permissions de") ${REP_GLPI}"
        return 1
    fi
    sync # S'assurer que toutes les √©critures sont termin√©es
    info "$(gt "Configuration du serveur WEB pour GLPI :") ${REP_GLPI}"
    if check_install_user "${REP_GLPI}"; then
        info "$(gt "Utilisateur WEB d√©tect√© :") ${WEB_USER}"
        if [[ "${WEB_USER}" == "www-data" ]]; then
            network_info
            info "$(gt "Configuration pour Apache avec utilisateur :") ${WEB_USER}" # Pour le d√©bogage
            # Configuration d'Apache pour GLPI
            info "$(gt "Configuration Virtual host d'Apache pour GLPI")"
            if tee "${FILE_APACHE_CONF}" <<EOF > /dev/null
<VirtualHost *:80>
    ServerName ${IPADRESS}
    DocumentRoot ${REP_GLPI}public
    <Directory ${REP_GLPI}public>
        Require all granted
        RewriteEngine On
        RewriteCond %{HTTP:Authorization} ^(.+)$
        RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
        RewriteCond %{REQUEST_FILENAME} !-f
        RewriteRule ^(.*)$ index.php [QSA,L]
    </Directory>
    ErrorLog /var/log/glpi/error.log
    CustomLog /var/log/glpi/access.log combined
</VirtualHost>
EOF
            then
                echo "$(gt "Fichier de configuration Apache pour GLPI cr√©√© avec succ√®s.")"
            else
                erreur "$(gt "√âchec de la cr√©ation du fichier de configuration Apache pour GLPI.")"
                return 1
            fi
            phpversion=$(php -v | grep -i '(cli)' | awk '{print $2}' | cut -d. -f1,2)
            sed -i 's/^\(;\?\)\(session.cookie_httponly\).*/\2 =on/' /etc/php/"$phpversion"/apache2/php.ini
            # Disable Apache Web Server Signature
            echo "ServerSignature Off" >> /etc/apache2/apache2.conf
            echo "ServerTokens Prod" >> /etc/apache2/apache2.conf
            # Activation du module rewrite d'apache
            if ! a2enmod rewrite | tee -a "${DEBUGFILE}"; then
                warn "$(gt "√âchec de l'activation du module rewrite d'Apache.")"
                return 1
            fi
            # D√©activer le site par d√©faut
            if ! a2dissite 000-default.conf | tee -a "${DEBUGFILE}"; then
                warn "$(gt "√âchec de la d√©sactivation du site par d√©faut d'Apache.")"
                return 1
            fi
            # Activer le site GLPI
            if ! a2ensite "${DB_NAME}".conf | tee -a "${DEBUGFILE}"; then
                warn "$(gt "√âchec de l'activation du site GLPI.")"
                return 1
            fi
            # Recharger la configuration d'Apache
            if ! systemctl reload apache2 | tee -a "${DEBUGFILE}"; then
                warn "$(gt "√âchec du rechargement de la configuration d'Apache.")"
                return 1
            fi
            # Change permissions
            info "$(gt "Permissions de") ${REP_GLPI}" "$(gt "modifi√©es avec succ√®s.")"
            if ! rights_glpi "${REP_GLPI}"; then
                warn "$(gt "√âchec de la modification des permissions de") ${REP_GLPI}"
                return 1
            fi
            sync # S'assurer que toutes les √©critures sont termin√©es
            # Installation de GLPI en ligne de commande
            debug "$(date '+%Y-%m-%d %H:%M:%S') - [INFO] Ex√©cution : sudo -u ${WEB_USER} php ${CMD[*]}"
            # Ex√©cuter la commande en tant que "${WEB_USER}". Utiliser sudo tee pour √©crire vers les fichiers prot√©g√©s.
            if sudo -u "${WEB_USER}" "${CMD[@]}" | sudo tee -a "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
                info "Installation GLPI r√©ussie."
                sync # S'assurer que toutes les √©critures sont termin√©es
            else
                warn "√âchec de l‚Äôinstallation GLPI."
                tail -n 10 "${ERRORFILE}" >&2  # affiche les derni√®res erreurs
                return 1
            fi
            manage_service "apache2" "Apache2" || return 1
        fi
    elif [[ "${WEB_USER}" == "nginx" ]]; then
        network_info
        info "$(gt "Configuration de Nginx pour GLPI. Utilisateur :") ${WEB_USER}"
        # Configuration de Nginx pour GLPI
        info "$(gt "Configuration Virtual host de Nginx pour GLPI.")"
        sudo tee "/etc/nginx/conf.d/glpi.conf" <<EOF > /dev/null
server {
    listen 80;
    server_name ${IPADRESS};
    root ${REP_GLPI}public;
    location / {
        try_files \$uri /index.php\$is_args\$args;
    }
    location ~ ^/index\.php$ {
        # the following line needs to be adapted, as it changes depending on OS distributions and PHP versions
        fastcgi_pass unix:/var/run/php-fpm/www.sock;
        fastcgi_split_path_info ^(.+\.php)(/.*)$;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;
    }
}
EOF
        info "$(gt "Cr√©ation de la configuration logrotate pour GLPI.")"
        # Configuration de logrotate pour GLPI
        sudo tee "/etc/logrotate.d/glpi" <<EOF > /dev/null
/var/lib/glpi/files/_log/*.log {
    su nginx nginx
    daily
    rotate 14
    compress
    notifempty
    missingok
    create 644 nginx nginx
}
EOF
        if [ -f /etc/logrotate.d/glpi ]; then
            info "$(gt "Configuration logrotate pour GLPI cr√©√©e avec succ√®s.")"
        fi
        chmod 0644 /etc/logrotate.d/glpi
        chown root:root /etc/logrotate.d/glpi
        chcon system_u:object_r:etc_t:s0 /etc/logrotate.d/glpi
        sed -i 's/^\(;\?\)\(session.cookie_httponly\).*/\2 = on/' /etc/php.ini
        # Change permissions
        if rights_glpi "${REP_GLPI}"; then
            info "$(gt "Permissions de") ${REP_GLPI} $(gt "modifi√©es avec succ√®s.")"
        else
            warn "$(gt "√âchec de la modification des permissions de") ${REP_GLPI}"
            return 1
        fi
        # Recharger la configuration de Nginx
        if ! systemctl reload nginx php-fpm; then
            warn "$(gt "√âchec du rechargement de Nginx ou PHP-FPM.")"
            return 1
        fi
        # Installation de GLPI en ligne de commande
        if sudo -u "${WEB_USER}" "${CMD[@]}" 1>>"${DEBUGFILE}" 2>>"${ERRORFILE}"; then
            info "$(gt "Installation de GLPI en console termin√©e avec succ√®s.")"
        else
            warn "$(gt "√âchec de l'installation de GLPI en console.")"
            return 1
        fi
        # Configuration de la t√¢che Cron
        info "$(gt "Configuration de la t√¢che Cron pour GLPI.")"
        echo "*/2 * * * * ${WEB_USER} /usr/bin/php ${REP_GLPI}front/cron.php &>/dev/null" >> /etc/cron.d/glpi
    fi
    sync # S'assurer que toutes les √©critures sont termin√©es
    info "$(gt "Suppression du fichier d'installation de GLPI")"
    if rm -Rf "${REP_GLPI}install/install.php"; then
        info "$(gt "Fichier d'installation de GLPI supprim√© avec succ√®s.")"
    else
        warn "$(gt "√âchec de la suppression du fichier d'installation de GLPI.")"
        return 1
    fi
    sleep 2
    info "$(gt "Installation de GLPI r√©ussie.")"
    debug_end
}
# Mise √† jour des mot de passe des utilisateurs de GLPI
function maj_user_glpi(){
    trap 'on_error' ERR
    set -Euo pipefail
    debug_start    
    info " $(gt "Mise √† jour des mots de passe des utilisateurs GLPI")"
    # Ensure we have a mysql client command; fallback to detecting it if not set
    network_info
    get_timezone
    local MYSQL_CMD
    MYSQL_CMD=$(command -v mysql  || command -v mariadb || echo mysql)
    # Verify mysql client exists
    if ! command -v "${MYSQL_CMD}"; then
        warn "$(gt "Commande MySQL/MariaDB introuvable.") ${MYSQL_CMD}"
        return 1
    fi
    # --- V√©rification des variables critiques ---
    if [ -z "${DB_NAME:-}" ] || [ -z "${DB_USER:-}" ] || [ -z "${SQLGLPIPWD:-}" ] || [ -z "${IPADRESS:-}" ]; then
        error "$(gt "Variables manquantes : DB_NAME, DB_USER, SQLGLPIPWD, IPADRESS")"
        return 1
    fi
    if [ -z "${ADMINGLPIPWD:-}" ] || [ -z "${POSTGLPIPWD:-}" ] || [ -z "${TECHGLPIPWD:-}" ] || [ -z "${NORMGLPIPWD:-}" ]; then
        error "$(gt "Un ou plusieurs mots de passe GLPI ne sont pas d√©finis")"
        return 1
    fi
    # Construire la requ√™te SQL et ex√©cuter via -e
    local _sql_user
    debug "Pr√©paration des commandes SQL pour mettre √† jour les mots de passe des utilisateurs GLPI." # Pour le d√©bogage
    debug "Base de donn√©es: ${DB_NAME}, Utilisateur: ${DB_USER}, Mot de passe SQL: ${SQLGLPIPWD}" # Pour le d√©bogage
    debug "Nouveaux mots de passe des utilisateurs GLPI:" # Pour le d√©bogage
    debug "  - glpi: ${ADMINGLPIPWD}" # Pour le d√©bogage
    debug "  - post-only: ${POSTGLPIPWD}" # Pour le d√©bogage
    debug "  - tech: ${TECHGLPIPWD}" # Pour le d√©bogage
    debug "  - normal: ${NORMGLPIPWD}" # Pour le d√©bogage
    debug "Construction des commandes SQL..." # Pour le d√©bogage
    # --- Construction du SQL ---
    local _sql_user
    _sql_user=$(
        cat <<SQL
USE ${DB_NAME};
UPDATE glpi_users SET password = MD5('${ADMINGLPIPWD}') WHERE name = 'glpi';
UPDATE glpi_users SET password = MD5('${POSTGLPIPWD}') WHERE name = 'post-only';
UPDATE glpi_users SET password = MD5('${TECHGLPIPWD}') WHERE name = 'tech';
UPDATE glpi_users SET password = MD5('${NORMGLPIPWD}') WHERE name = 'normal';
UPDATE glpi_configs SET value = '${TIMEZONE}' WHERE context = 'core' AND name = 'timezone';
UPDATE glpi_configs SET value = '${LANGUAGE}' WHERE context = 'core' AND name = 'language';
UPDATE glpi_configs SET value = '${IPADRESS}' WHERE context = 'core' AND name = 'url_base';
SQL
    )
    # --- Ex√©cution SQL ---
    if ! PAGER=cat MYSQL_PWD="${SQLGLPIPWD}" "${MYSQL_CMD}" -u "${DB_USER}" --batch --silent -e "${_sql_user}" 2>/dev/null; then
        error "$(gt "√âchec de la mise √† jour des mots de passe des utilisateurs GLPI.")"
        return 1
    fi
    info " $(gt "Mise √† jour des mots de passe des utilisateurs GLPI r√©ussie.")"
    debug_end
}
function source_os_release(){
    debug_start    
    if [[ -f /etc/os-release ]]; then
        # shellcheck disable=SC1091
        . /etc/os-release
    fi
    if [[ -f /etc/lsb-release ]]; then
        # shellcheck disable=SC1091
        . /etc/lsb-release
    fi
    if [[ -z "${ID:-}" ]]; then
        ID=$(uname -s | tr '[:upper:]' '[:lower:]')
    fi
    if [[ -z "${VERSION_ID:-}" ]]; then
        VERSION_ID=$(uname -r)
    fi
    if [ -z "${ID:-}" ] || [ -z "${VERSION_ID:-}" ]; then
        warn "$(gt "Variables ID ou VERSION_ID non d√©finies apr√®s sourcing de /etc/os-release ou /etc/lsb-release.")"
        return 1
    fi
    export ID VERSION_ID
    info "$(gt "Distribution d√©tect√©e :") ${ID} ${VERSION_ID}"
    debug "$(date '+%F %T') [$$][DEBUG: Fin de ${FUNCNAME[0]:-main}] Appeler par ${FUNCNAME[1]:-main}"
}
function rights_glpi(){
    debug_start    
    REP_GLPI="${1:-/var/www/html/glpi}"
    # Changer les droits des r√©pertoires et fichiers
    info "${MSG_SETUP_GLPI_RIGHTS_MODIFY}"
    find "${REP_GLPI}" -type d -exec chmod 755 {} \; 1> >(tee -a "${DEBUGFILE}") 2> >(tee -a "${ERRORFILE}" >&2)
    find "${REP_GLPI}" -type f -exec chmod 644 {} \; 1> >(tee -a "${DEBUGFILE}") 2> >(tee -a "${ERRORFILE}" >&2)
    # Changer le propri√©taire des r√©pertoires
    if check_distro ; then
        sudo chown -Rc "${WEB_USER}":"${WEB_USER}" /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}"
    fi
    # SELinux configuration
    if [[ "${WEB_USER}" == "nginx" ]]; then
        if command -v semanage; then
            setsebool -P httpd_can_network_connect on
            setsebool -P httpd_can_network_connect_db on
            setsebool -P httpd_can_sendmail on
            for p in "${REP_GLPI}" /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}marketplace"; do
                semanage fcontext -a -t httpd_sys_rw_content_t "${p}(/.*)?"
            done
            restorecon -R "${REP_GLPI}" /etc/glpi /var/lib/glpi /var/log/glpi "${REP_GLPI}marketplace"
        else
            error "$(date '+%F %T'): WARN: semanage non disponible ‚Äî SELinux non configur√©"
        fi
    fi
    info " $(gt "Permissions de GLPI modifi√©es avec succ√®s.")"
    debug_end
}
# Ecriture du fichier pour sauvegarder les mot de passe du serveur GLPI
function write_credentials(){
    debug_start    
    info "$(gt "√âcriture du fichier pour sauvegarder les mots de passe du serveur GLPI")"
    local folder_save_credentials="" file_save=""
    folder_save_credentials="${INVOKING_HOME}/saved_credentials"
    mkdir -p "${folder_save_credentials}"
    # Nettoie le nom du fichier pour √©viter les / ou espaces
    local safe_name
    safe_name="$(basename "${FICHIER_MSG}" .txt)_${DB_NAME}.txt"
    file_save="${folder_save_credentials}/${safe_name}"
    if [[ "${LANGUAGE}" == "fr_FR" ]]; then
        cat > "${file_save}" << EOF
<==========================> D√©tails de l'installation de GLPI <=================================>
 GLPI Version: ${VERSION_SELECT}
 R√©pertoire d'installation de GLPI: ${REP_GLPI}

 Les comptes utilisateurs par d√©faut sont :
 UTILISATEUR   -  MOT DE PASSE       -       ACCES
  glpi         -  ${ADMINGLPIPWD}     -  compte admin
  post-only    -  ${POSTGLPIPWD}     -  compte post-only
  tech         -  ${TECHGLPIPWD}     -  compte tech
  normal       -  ${NORMGLPIPWD}     -  compte normal

 Vous pouvez acc√©der √† la page web de GLPI √† partir d'une adresse IP ou d'un nom d'h√¥te :
 http://${DB_HOST}

 ==> Base de donn√©es:
 H√¥te de la base de donn√©es: ${DB_HOST}
 Port de la base de donn√©es: 3306
 Nom de la base de donn√©es GLPI: ${DB_NAME}
 Mot de passe root: ${SQLROOTPWD}
 Mot de passe ${DB_USER}: ${SQLGLPIPWD}

 Fichier de sauvegarde enregistr√© dans ${FICHIER_MSG}
 <===============================================================================================>

 Si vous rencontrez un probl√©me avec ce script, veuillez le signaler sur GitHub : https://github.com/PapyPoc/glpi_install/issues
EOF
	else
		cat > "${file_save}" << EOF
<=============================> GLPI installation details <=====================================>
 GLPI version: ${VERSION_SELECT}
 GLPI installation directory: ${REP_GLPI}

 The default user accounts are:
    USER         -    PASSWORD        -       ACCESS
  glpi           -  ${ADMINGLPIPWD}      -  admin account
  post-only      -  ${POSTGLPIPWD}      -  post-only account
  tech           -  ${TECHGLPIPWD}      -  tech account
  normal         -  ${NORMGLPIPWD}      -  normal account

 You can access the GLPI web page from the following address :
 http://${DB_HOST}

 ==> Database:
 Database host: ${DB_HOST}
 Database port: 3306
 GLPI database name: ${DB_NAME}
 Root password: ${SQLROOTPWD}
 ${DB_USER} password: ${SQLGLPIPWD}

 Backup file saved to ${FICHIER_MSG}
 <===============================================================================================>

 If you encounter a problem with this script, please report it on GitHub : https://github.com/PapyPoc/glpi_install/issues
EOF
	fi
    info "$(gt "Fichier de sauvegarde des mots de passe du serveur GLPI cr√©√© avec succ√®s.")"
    debug_end
}
# Afficher le r√©sultat final
function display_result() {
    debug_start    info " $(gt "Affichage des r√©sultats")"
    local MESSAGE="" file_save=""
    file_save=$(find "${INVOKING_HOME}/saved_credentials" -type f -name "${FICHIER_MSG}${DB_NAME}*" | head -n 1)
	if [[ -f "${file_save}" ]]; then
        while IFS= read -r ligne; do
            MESSAGE+="${ligne}\n"
        done < "${file_save}"
        dialog --clear --backtitle "$(gt "Affichage des r√©sultats")" --title "$(gt "Installation termin√©e")" --msgbox "${MESSAGE}" 0 0 >/dev/tty 2>&1
    else
        dialog --clear --backtitle "$(gt "Affichage des r√©sultats")" --title "$(gt "Installation √©chou√©e")" --msgbox "\n\n$(gt "Impossible de cr√©er le fichier de messages d'installation.")" 0 0 >/dev/tty 2>&1
    fi
    info " $(gt "Fin de l'affichage des r√©sultats")"
    debug_end
}
# Activ√© ou d√©activ√© le mode maintenance (1 ou 0)
function maintenance(){ 
    debug_start    
    check_install_user "${REP_GLPI}"
    if [ "$1" == "1" ]; then
        info " $(get "Activation du mode maintenance")"
        sudo -u "${WEB_USER}" php "${REP_GLPI}"bin/console glpi:maintenance:enable 1> >(tee -a "${DEBUGFILE}") 2> >(tee -a "${ERRORFILE}" >&2)
    elif [ "$1" == "0" ]; then
        info " $(get "D√©sactivation du mode maintenance")"
        sudo -u "${WEB_USER}" php "${REP_GLPI}"bin/console glpi:maintenance:disable 1> >(tee -a "${DEBUGFILE}") 2> >(tee -a "${ERRORFILE}" >&2)
    fi
	sleep 2;
    debug_end
}
function get_glpi_db_info() {
    debug_start
    set -euo pipefail    
    trap 'on_error' ERR
    info "$(gt "R√©cup√©ration des informations de la base de donn√©es GLPI")"
    REP_GLPI="${1:-/var/www/html/glpi}"
    file_downstream="${REP_GLPI}/inc/downstream.php"
    #local GLPI_CONFIG_DIR file_conf_glpi _conf_tmp
    # V√©rification du fichier principal
    if [[ ! -f "${file_downstream}" ]]; then
        error "$(gt "Fichier introuvable :") ${file_downstream}"
        return 1
    fi
    # Extraction du r√©pertoire de configuration via PHP
    GLPI_CONFIG_DIR=$(php -r "require '${file_downstream}'; echo (defined('GLPI_CONFIG_DIR')?GLPI_CONFIG_DIR:'');")
    if [[ -z "${GLPI_CONFIG_DIR}" ]]; then
        error "$(gt "Impossible de d√©terminer GLPI_CONFIG_DIR")"
        return 1
    fi
    file_conf_glpi="${GLPI_CONFIG_DIR}/config_db.php"
    if [[ ! -f "${file_conf_glpi}" ]]; then
        error "$(gt "Fichier introuvable :") ${file_conf_glpi}"
        return 1
    fi
    # Cr√©ation d‚Äôun fichier temporaire nettoy√© des CRLF
    _conf_tmp=$(mktemp)
    tr -d '\r' < "${file_conf_glpi}" > "${_conf_tmp}"
    # Extraction des valeurs (tol√©rante aux espaces)
    local DB_HOST DB_USER DB_PASSWORD DB_NAME GLPI_VERSION
    DB_HOST=$(sed -n "s/.*public[[:space:]]\+\$dbhost[[:space:]]*=[[:space:]]*'\([^']*\)'.*/\1/p" "${_conf_tmp}")
    DB_USER=$(sed -n "s/.*public[[:space:]]\+\$dbuser[[:space:]]*=[[:space:]]*'\([^']*\)'.*/\1/p" "${_conf_tmp}")
    DB_PASSWORD=$(sed -n "s/.*public[[:space:]]\+\$dbpassword[[:space:]]*=[[:space:]]*'\([^']*\)'.*/\1/p" "${_conf_tmp}")
    DB_NAME=$(sed -n "s/.*public[[:space:]]\+\$dbdefault[[:space:]]*=[[:space:]]*'\([^']*\)'.*/\1/p" "${_conf_tmp}")
    rm -f "${_conf_tmp}"
    # D√©tection de version GLPI
    GLPI_VERSION=$(php -r "require '${file_downstream}'; echo (defined('GLPI_VERSION')?GLPI_VERSION:'inconnue');")
    # V√©rification des r√©sultats
    if [[ -z "${DB_NAME}" || -z "${DB_USER}" ]]; then
        warn "$(gt "Impossible d‚Äôextraire les infos de base de donn√©es depuis") ${file_conf_glpi}"
        return 1
    fi
    # Affichage
    info "Informations GLPI d√©tect√©es :"
    info "  Version GLPI : ${GLPI_VERSION}"
    info "  üñ•Ô∏è H√¥te DB      : ${DB_HOST}"
    info "  üì¶ Base DB      : ${DB_NAME}"
    info "  üë§ Utilisateur  : ${DB_USER}"
    info "  üîí Mot de passe : ${DB_PASSWORD}"
    info "$(gt "Impossible de r√©cup√©rer les informations de la base de donn√©es GLPI.")"
    # Export des variables dans l‚Äôenvironnement appelant
    export GLPI_VERSION DB_HOST DB_NAME DB_USER DB_PASSWORD
}
# Sauvegarde de la base de donn√©e et des fichiers de GLPI
function backup_glpi() {
    debug_start    
    info "$(gt "Cr√©ation de la sauvegarde")"
    # R√©cup√©ration du nom de la base de donn√©es dans le fichier config de GLPI suivant le r√©pertoire de GLPI
    info "$(gt "Lecture des variables de base de donn√©es de GLPI")"
    get_glpi_db_info "${REP_GLPI}"
    # D√©termination de l‚Äôoutil de dump
    local MYSQLDUMP_CMD
    MYSQLDUMP_CMD=$(command -v mysqldump 2>/dev/null || command -v mariadb-dump 2>/dev/null || echo mysqldump)
    # R√©pertoires de sauvegarde
    REP_BACKUP="${INVOKING_HOME}/backup_glpi_$(date +"%Y-%m-%d")"
    BDD_BACKUP="bdd_glpi_$(date +"%Y-%m-%d_%H-%M-%S").sql"
    if ! mkdir -p "${REP_BACKUP}"; then
        warn "$(gt "√âchec de la cr√©ation du r√©pertoire de sauvegarde :") ${REP_BACKUP}"
        return 1
    fi
    # --- Export de la BDD ---
    info "$(gt "Exportation de la base de donn√©es.")"
    if ${MYSQLDUMP_CMD} -u "${DB_USER}" -p"${DB_PASSWORD}" --databases "${DB_NAME}" | \
        tea -a "${REP_BACKUP}/${BDD_BACKUP}" >>"${DEBUGFILE}" 2>>"${ERRORFILE}"; then
        if [[ -s "${REP_BACKUP}/${BDD_BACKUP}" ]]; then
            info "$(gt "Exportation de la base de donn√©es termin√©e avec succ√®s.")"
        else
            warn "$(gt "Fichier de sauvegarde de la base de donn√©es vide :") ${REP_BACKUP}/${BDD_BACKUP}"
            return 1
        fi
    else
        error "$(gt "√âchec de l'exportation de la base de donn√©es.")"
        return 1
    fi
    # --- Sauvegarde des fichiers ---
    info "$(gt "Sauvegarde des fichiers de GLPI")"
    for SRC in "/etc/glpi/config" "/var/lib/glpi/files" "${REP_GLPI}/plugins" "${REP_GLPI}/marketplace" "${REP_GLPI}/inc/downstream.php"; do
        if [ -e "${SRC}" ]; then
            info "$(gt "Copie de ${SRC} vers ${REP_BACKUP}/")"
            cp -Rf "${SRC}" "${REP_BACKUP}/"
        else
            warn "$(gt "Source manquante :") ${SRC}"
        fi
    done
    info "$(gt "Sauvegarde des fichiers termin√©e avec succ√®s.")"
    # --- Compression ---
    info "$(gt "Compression de la sauvegarde")"
    mkdir -p "${REP_BACKUP_COMPRESS}"
    local BACKUP_FILE
    BACKUP_FILE="${REP_BACKUP_COMPRESS}/glpi_$(date +"%Y-%m-%d")_${GLPI_CLI_VERSION}->${VERSION_SELECT}.tar.gz"
    if tar -czf "${BACKUP_FILE}" -C "${REP_BACKUP}" . 2>> "${ERRORFILE}"; then
        info "$(gt "Compression termin√©e avec succ√®s. Fichier cr√©√© :") (${BACKUP_FILE})"
        # V√©rifier que le fichier compress√© n'est pas vide
        if [ ! -s "${BACKUP_FILE}" ]; then
            warn "$(gt "Fichier de sauvegarde vide.") ${BACKUP_FILE}"
            return 1
        fi
    else
        warn "$(gt "√âchec de la compression de la sauvegarde.")"
        return 1
    fi
    info "$(gt "Sauvegarde de GLPI termin√©e avec succ√®s.")"
    sleep 2
    export REP_BACKUP REP_GLPI
    debug_end
}
function remove_old_glpi(){
    debug_start    # Suppression s√©curis√©e de l‚Äôancien GLPI
        info "$(gt "Suppression de l'ancien r√©pertoire GLPI :") ${REP_GLPI}"
        if [ -n "${REP_GLPI}" ] && [ -d "${REP_GLPI}" ]; then
            rm -rf "${REP_GLPI:?}/" >> "${DEBUGFILE}" 2>> "${ERRORFILE}"
            info "$(gt "R√©pertoire supprim√© :") ${REP_GLPI}"
        else
            warn "$(gt "R√©pertoire non trouv√© :") ${REP_GLPI}"
        fi
    debug_end
}
# Mise √† jour de GLPI
function update_glpi() {
    debug_start    
    info "$(gt "Mise √† jour de GLPI")"
    # Restauration des fichiers de configuration et des plugins
    info "${MSG_UPDATE_GLPI_RESTORE_FILES}"
    for DIR in config files plugins marketplace; do
        SRC="${REP_BACKUP}/${DIR}"
        if [ -d "${SRC}" ]; then
            case "${DIR}" in
                config) DEST="/etc/glpi/config" ;;
                files) DEST="/var/lib/glpi/files" ;;
                plugins) DEST="${REP_GLPI}/plugins" ;;
                marketplace) DEST="${REP_GLPI}/marketplace" ;;
            esac
            mkdir -p "${DEST}"
            if compgen -G "${SRC}/*" > /dev/null; then
                if cp -Rf "${SRC}/"* "${DEST}/"; then
                    info "$(get "Restauration de ${DIR} vers ${DEST} termin√©e.")"
                else
                    warn "$(get "Erreur lors de la copie de ${DIR} vers ${DEST}.")"
                fi
            else
                warn "$(gt "R√©pertoire ${SRC} vide, rien √† copier.")"
            fi
        fi
    done
    # Restauration du fichier downstream.php
    REP_BACKUP=$(find "${INVOKING_HOME}" -maxdepth 1 -type d -name "backup_glpi_*")
    info "$(gt "Restauration du fichier ${REP_BACKUP}/downstream.php si pr√©sent.")"
    if [ -f "${REP_BACKUP}/downstream.php" ]; then
        mkdir -p "${REP_GLPI}/inc" 1>> "${DEBUGFILE}" 2>> "${ERRORFILE}"
        if cp -Rf "${REP_BACKUP}/downstream.php" "${REP_GLPI}/inc/" 1>> "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
            info "$(gt "Restauration du fichier ${REP_BACKUP}/downstream.php termin√©e.")"
        else
            warn "$(gt "Erreur lors de la copie de ${REP_BACKUP}/downstream.php vers ${REP_GLPI}/inc/.")"
        fi
    fi
    # Suppression de la sauvegarde
    info "$(gt "Suppression des anciens fichiers")"
    if [ -d "${INVOKING_HOME}" ]; then
        if find "${INVOKING_HOME}" -maxdepth 1 -type d -name "backup_glpi_*" -exec rm -rf {} + >> "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
            info "$(gt "Suppression des anciens fichiers termin√©e.")"
        else
            warn "$(gt "R√©pertoire ${REP_BACKUP} introuvable. Rien √† supprimer.")"
        fi
    fi
    # Mise √† jour de la base GLPI
    info "$(gt "Mise √† jour de la base de donn√©es GLPI")"
    if check_install_user "${REP_GLPI}"; then
        rights_glpi "${REP_GLPI}"
        debug "Repertoire GLPI pour la mise √† jour de la base : ${REP_GLPI}"
        debug "Utilisateur web pour la mise √† jour de la base : ${WEB_USER}"
        local CMD
        CMD="${REP_GLPI}/bin/console db:update --force --no-telemetry --quiet --no-interaction"
        # shellcheck disable=SC2086
        if sudo -u "${WEB_USER}" php ${CMD} 1>> "${DEBUGFILE}" 2>> "${ERRORFILE}"; then
            info "$(gt "Mise √† jour de la base GLPI r√©ussie.\n\nProfitez de GLPI ${VERSION_SELECT} !")"
            exec 3>&1
            dialog --clear --title "$(gt "Mise √† jour de la base de donn√©es GLPI")" --msgbox "$(gt "Mise √† jour de la base GLPI r√©ussie.\n\nProfitez de GLPI ${VERSION_SELECT} !")" 7 50
            exec 3>&-
        else
            warn "$(gt "√âchec de la mise √† jour de la base de donn√©es GLPI (voir ${ERRORFILE}).")"
            exec 3>&1
            dialog --clear --title "$(gt "Mise √† jour de la base de donn√©es GLPI")" --msgbox "$(gt "√âchec de la mise √† jour de la base de donn√©es GLPI (voir ${ERRORFILE}).")" 7 50
            exec 3>&-
            return 1
        fi
    fi
    # Nettoyage final
    info "$(gt "Nettoyage final")"
    if find "${REP_GLPI}/install/" -maxdepth 1 -type f -name "install.php" -exec sudo rm -f {} +  ; then
        info "$(gt "Fichier ${REP_GLPI}/install/install.php supprim√© avec succ√®s.")"
    else
        warn "$(gt "Impossible de supprimer install.php dans ${REP_GLPI}/install/")"
        exit 1
    fi
    info "$(gt "Mise √† jour de GLPI r√©ussie.")"
    debug_end
}